
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>accesslog: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/chilla55/proxy-manager/accesslog/accesslog.go (0.0%)</option>
				
				<option value="file1">github.com/chilla55/proxy-manager/analytics/analytics.go (82.7%)</option>
				
				<option value="file2">github.com/chilla55/proxy-manager/audit/audit.go (0.0%)</option>
				
				<option value="file3">github.com/chilla55/proxy-manager/certmonitor/certmonitor.go (0.0%)</option>
				
				<option value="file4">github.com/chilla55/proxy-manager/config/config.go (57.3%)</option>
				
				<option value="file5">github.com/chilla55/proxy-manager/database/database.go (0.0%)</option>
				
				<option value="file6">github.com/chilla55/proxy-manager/health/health.go (0.0%)</option>
				
				<option value="file7">github.com/chilla55/proxy-manager/main.go (0.0%)</option>
				
				<option value="file8">github.com/chilla55/proxy-manager/metrics/metrics.go (89.8%)</option>
				
				<option value="file9">github.com/chilla55/proxy-manager/middleware/middleware.go (0.0%)</option>
				
				<option value="file10">github.com/chilla55/proxy-manager/nginx/controller.go (0.0%)</option>
				
				<option value="file11">github.com/chilla55/proxy-manager/pii/pii.go (0.0%)</option>
				
				<option value="file12">github.com/chilla55/proxy-manager/proxy/proxy.go (0.0%)</option>
				
				<option value="file13">github.com/chilla55/proxy-manager/ratelimit/ratelimit.go (68.8%)</option>
				
				<option value="file14">github.com/chilla55/proxy-manager/registry/registry.go (0.0%)</option>
				
				<option value="file15">github.com/chilla55/proxy-manager/retention/retention.go (0.0%)</option>
				
				<option value="file16">github.com/chilla55/proxy-manager/traffic/traffic.go (72.6%)</option>
				
				<option value="file17">github.com/chilla55/proxy-manager/updater/cloudflare.go (0.0%)</option>
				
				<option value="file18">github.com/chilla55/proxy-manager/waf/waf.go (66.7%)</option>
				
				<option value="file19">github.com/chilla55/proxy-manager/watcher/cert.go (0.0%)</option>
				
				<option value="file20">github.com/chilla55/proxy-manager/watcher/site.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package accesslog

import (
        "container/ring"
        "sync"
        "time"

        "github.com/chilla55/proxy-manager/database"
        "github.com/rs/zerolog/log"
)

// Logger handles request/error logging with ring buffer and database persistence
type Logger struct {
        db         Database
        ringBuffer *ring.Ring
        ringMutex  sync.RWMutex
        bufferSize int
        enabled    bool
}

// Database interface for access log persistence
type Database interface {
        LogAccessRequest(entry database.AccessLogEntry) error
        GetRecentRequests(limit int) ([]database.AccessLogEntry, error)
        GetRequestsByRoute(route string, limit int) ([]database.AccessLogEntry, error)
        GetErrorRequests(limit int) ([]database.AccessLogEntry, error)
}

// AccessLogEntry is an alias for database.AccessLogEntry
type AccessLogEntry = database.AccessLogEntry

// NewLogger creates a new access logger
func NewLogger(db Database, bufferSize int) *Logger <span class="cov0" title="0">{
        if bufferSize &lt;= 0 </span><span class="cov0" title="0">{
                bufferSize = 1000 // Default: last 1000 requests
        }</span>

        <span class="cov0" title="0">return &amp;Logger{
                db:         db,
                ringBuffer: ring.New(bufferSize),
                bufferSize: bufferSize,
                enabled:    true,
        }</span>
}

// LogRequest logs an HTTP request to both ring buffer and database
func (l *Logger) LogRequest(entry AccessLogEntry) <span class="cov0" title="0">{
        if !l.enabled </span><span class="cov0" title="0">{
                return
        }</span>

        // Set timestamp if not set
        <span class="cov0" title="0">if entry.Timestamp == 0 </span><span class="cov0" title="0">{
                entry.Timestamp = time.Now().Unix()
        }</span>

        // Store in ring buffer (in-memory)
        <span class="cov0" title="0">l.ringMutex.Lock()
        l.ringBuffer.Value = entry
        l.ringBuffer = l.ringBuffer.Next()
        l.ringMutex.Unlock()

        // Store in database (async, non-blocking)
        go func() </span><span class="cov0" title="0">{
                if err := l.db.LogAccessRequest(entry); err != nil </span><span class="cov0" title="0">{
                        log.Error().
                                Err(err).
                                Str("domain", entry.Domain).
                                Str("path", entry.Path).
                                Msg("Failed to log access request to database")
                }</span>
        }()

        // Log errors to stderr for immediate visibility
        <span class="cov0" title="0">if entry.Status &gt;= 400 </span><span class="cov0" title="0">{
                logLevel := log.Warn()
                if entry.Status &gt;= 500 </span><span class="cov0" title="0">{
                        logLevel = log.Error()
                }</span>

                <span class="cov0" title="0">logLevel.
                        Str("domain", entry.Domain).
                        Str("method", entry.Method).
                        Str("path", entry.Path).
                        Int("status", entry.Status).
                        Int64("response_ms", entry.ResponseTimeMs).
                        Str("client_ip", entry.ClientIP).
                        Str("error", entry.Error).
                        Msg("Request error")</span>
        }
}

// GetRecentRequests returns the last N requests from ring buffer
func (l *Logger) GetRecentRequests(limit int) []AccessLogEntry <span class="cov0" title="0">{
        if limit &lt;= 0 || limit &gt; l.bufferSize </span><span class="cov0" title="0">{
                limit = l.bufferSize
        }</span>

        <span class="cov0" title="0">l.ringMutex.RLock()
        defer l.ringMutex.RUnlock()

        var entries []AccessLogEntry
        count := 0

        // Walk the ring buffer backwards
        l.ringBuffer.Do(func(value interface{}) </span><span class="cov0" title="0">{
                if count &gt;= limit </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">if value != nil </span><span class="cov0" title="0">{
                        if entry, ok := value.(AccessLogEntry); ok </span><span class="cov0" title="0">{
                                entries = append(entries, entry)
                                count++
                        }</span>
                }
        })

        // Reverse to get chronological order (newest first)
        <span class="cov0" title="0">for i, j := 0, len(entries)-1; i &lt; j; i, j = i+1, j-1 </span><span class="cov0" title="0">{
                entries[i], entries[j] = entries[j], entries[i]
        }</span>

        <span class="cov0" title="0">return entries</span>
}

// GetRecentErrors returns recent error requests from ring buffer
func (l *Logger) GetRecentErrors(limit int) []AccessLogEntry <span class="cov0" title="0">{
        l.ringMutex.RLock()
        defer l.ringMutex.RUnlock()

        var errors []AccessLogEntry
        count := 0

        l.ringBuffer.Do(func(value interface{}) </span><span class="cov0" title="0">{
                if count &gt;= limit </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">if value != nil </span><span class="cov0" title="0">{
                        if entry, ok := value.(AccessLogEntry); ok &amp;&amp; entry.Status &gt;= 400 </span><span class="cov0" title="0">{
                                errors = append(errors, entry)
                                count++
                        }</span>
                }
        })

        // Reverse to get chronological order (newest first)
        <span class="cov0" title="0">for i, j := 0, len(errors)-1; i &lt; j; i, j = i+1, j-1 </span><span class="cov0" title="0">{
                errors[i], errors[j] = errors[j], errors[i]
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// GetStats returns access log statistics
func (l *Logger) GetStats() LogStats <span class="cov0" title="0">{
        l.ringMutex.RLock()
        defer l.ringMutex.RUnlock()

        stats := LogStats{
                BufferSize: l.bufferSize,
        }

        var totalResponseTime int64
        statusCounts := make(map[int]int)
        methodCounts := make(map[string]int)

        l.ringBuffer.Do(func(value interface{}) </span><span class="cov0" title="0">{
                if value != nil </span><span class="cov0" title="0">{
                        if entry, ok := value.(AccessLogEntry); ok </span><span class="cov0" title="0">{
                                stats.TotalEntries++
                                totalResponseTime += entry.ResponseTimeMs

                                if entry.Status &gt;= 400 </span><span class="cov0" title="0">{
                                        stats.ErrorCount++
                                }</span>

                                <span class="cov0" title="0">statusCounts[entry.Status]++
                                methodCounts[entry.Method]++</span>
                        }
                }
        })

        <span class="cov0" title="0">if stats.TotalEntries &gt; 0 </span><span class="cov0" title="0">{
                stats.AverageResponseTimeMs = float64(totalResponseTime) / float64(stats.TotalEntries)
                stats.ErrorRate = float64(stats.ErrorCount) / float64(stats.TotalEntries) * 100
        }</span>

        <span class="cov0" title="0">stats.StatusCounts = statusCounts
        stats.MethodCounts = methodCounts

        return stats</span>
}

// LogStats represents access log buffer statistics
type LogStats struct {
        BufferSize            int            `json:"buffer_size"`
        TotalEntries          int            `json:"total_entries"`
        ErrorCount            int            `json:"error_count"`
        ErrorRate             float64        `json:"error_rate_percent"`
        AverageResponseTimeMs float64        `json:"average_response_time_ms"`
        StatusCounts          map[int]int    `json:"status_counts"`
        MethodCounts          map[string]int `json:"method_counts"`
}

// Enable enables access logging
func (l *Logger) Enable() <span class="cov0" title="0">{
        l.enabled = true
        log.Info().Msg("Access logging enabled")
}</span>

// Disable disables access logging
func (l *Logger) Disable() <span class="cov0" title="0">{
        l.enabled = false
        log.Info().Msg("Access logging disabled")
}</span>

// IsEnabled returns whether access logging is enabled
func (l *Logger) IsEnabled() bool <span class="cov0" title="0">{
        return l.enabled
}</span>

// Clear clears the ring buffer
func (l *Logger) Clear() <span class="cov0" title="0">{
        l.ringMutex.Lock()
        defer l.ringMutex.Unlock()

        l.ringBuffer = ring.New(l.bufferSize)
        log.Info().Msg("Access log ring buffer cleared")
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package analytics

import (
        "math"
        "sort"
        "sync"
        "time"

        "github.com/rs/zerolog/log"
)

// Aggregator performs advanced metrics aggregation and analysis
type Aggregator struct {
        responseTimes []float64 // milliseconds
        bandwidthIn   []uint64  // bytes
        bandwidthOut  []uint64  // bytes
        errorCounts   []int
        requestCounts []int
        timestamps    []int64 // unix timestamps

        mu           sync.RWMutex
        windowSize   int           // number of samples to keep
        samplePeriod time.Duration // how often to sample
        startTime    time.Time
}

// AggregatedMetrics represents advanced metrics calculations
type AggregatedMetrics struct {
        // Response Time Analysis
        ResponseTimeP50    float64 `json:"response_time_p50_ms"`
        ResponseTimeP90    float64 `json:"response_time_p90_ms"`
        ResponseTimeP95    float64 `json:"response_time_p95_ms"`
        ResponseTimeP99    float64 `json:"response_time_p99_ms"`
        ResponseTimeMean   float64 `json:"response_time_mean_ms"`
        ResponseTimeStdDev float64 `json:"response_time_stddev_ms"`

        // Bandwidth Analysis
        BandwidthInMean   float64 `json:"bandwidth_in_mean_bytes"`
        BandwidthOutMean  float64 `json:"bandwidth_out_mean_bytes"`
        BandwidthInTotal  uint64  `json:"bandwidth_in_total_bytes"`
        BandwidthOutTotal uint64  `json:"bandwidth_out_total_bytes"`
        BandwidthInPeak   uint64  `json:"bandwidth_in_peak_bytes"`
        BandwidthOutPeak  uint64  `json:"bandwidth_out_peak_bytes"`

        // Error Rate Analysis
        ErrorRateMean  float64 `json:"error_rate_mean_percent"`
        ErrorRatePeak  float64 `json:"error_rate_peak_percent"`
        ErrorRateTrend string  `json:"error_rate_trend"` // "increasing", "decreasing", "stable"

        // Traffic Analysis
        RequestsPerSecond float64 `json:"requests_per_second"`
        RequestsPeak      int     `json:"requests_peak"`
        TrafficTrend      string  `json:"traffic_trend"` // "increasing", "decreasing", "stable"

        // Time Window
        WindowStart int64 `json:"window_start"`
        WindowEnd   int64 `json:"window_end"`
        SampleCount int   `json:"sample_count"`
}

// NewAggregator creates a new metrics aggregator
func NewAggregator(windowSize int, samplePeriod time.Duration) *Aggregator <span class="cov3" title="5">{
        if windowSize &lt;= 0 </span><span class="cov0" title="0">{
                windowSize = 1000 // Default: keep last 1000 samples
        }</span>
        <span class="cov3" title="5">if samplePeriod &lt;= 0 </span><span class="cov0" title="0">{
                samplePeriod = 10 * time.Second // Default: sample every 10 seconds
        }</span>

        <span class="cov3" title="5">return &amp;Aggregator{
                responseTimes: make([]float64, 0, windowSize),
                bandwidthIn:   make([]uint64, 0, windowSize),
                bandwidthOut:  make([]uint64, 0, windowSize),
                errorCounts:   make([]int, 0, windowSize),
                requestCounts: make([]int, 0, windowSize),
                timestamps:    make([]int64, 0, windowSize),
                windowSize:    windowSize,
                samplePeriod:  samplePeriod,
                startTime:     time.Now(),
        }</span>
}

// AddSample adds a new metrics sample
func (a *Aggregator) AddSample(responseTime float64, bytesIn, bytesOut uint64, errors, requests int) <span class="cov8" title="123">{
        a.mu.Lock()
        defer a.mu.Unlock()

        now := time.Now().Unix()

        // Add new sample
        a.responseTimes = append(a.responseTimes, responseTime)
        a.bandwidthIn = append(a.bandwidthIn, bytesIn)
        a.bandwidthOut = append(a.bandwidthOut, bytesOut)
        a.errorCounts = append(a.errorCounts, errors)
        a.requestCounts = append(a.requestCounts, requests)
        a.timestamps = append(a.timestamps, now)

        // Keep only the last N samples (sliding window)
        if len(a.responseTimes) &gt; a.windowSize </span><span class="cov3" title="5">{
                a.responseTimes = a.responseTimes[1:]
                a.bandwidthIn = a.bandwidthIn[1:]
                a.bandwidthOut = a.bandwidthOut[1:]
                a.errorCounts = a.errorCounts[1:]
                a.requestCounts = a.requestCounts[1:]
                a.timestamps = a.timestamps[1:]
        }</span>
}

// GetAggregatedMetrics calculates and returns aggregated metrics
func (a *Aggregator) GetAggregatedMetrics() AggregatedMetrics <span class="cov3" title="4">{
        a.mu.RLock()
        defer a.mu.RUnlock()

        metrics := AggregatedMetrics{
                SampleCount: len(a.responseTimes),
        }

        if len(a.timestamps) &gt; 0 </span><span class="cov3" title="4">{
                metrics.WindowStart = a.timestamps[0]
                metrics.WindowEnd = a.timestamps[len(a.timestamps)-1]
        }</span>

        <span class="cov3" title="4">if metrics.SampleCount == 0 </span><span class="cov0" title="0">{
                return metrics
        }</span>

        // Calculate response time percentiles
        <span class="cov3" title="4">metrics.ResponseTimeP50 = a.calculatePercentile(a.responseTimes, 0.50)
        metrics.ResponseTimeP90 = a.calculatePercentile(a.responseTimes, 0.90)
        metrics.ResponseTimeP95 = a.calculatePercentile(a.responseTimes, 0.95)
        metrics.ResponseTimeP99 = a.calculatePercentile(a.responseTimes, 0.99)
        metrics.ResponseTimeMean = a.calculateMean(a.responseTimes)
        metrics.ResponseTimeStdDev = a.calculateStdDev(a.responseTimes, metrics.ResponseTimeMean)

        // Calculate bandwidth metrics
        metrics.BandwidthInMean = a.calculateMeanUint64(a.bandwidthIn)
        metrics.BandwidthOutMean = a.calculateMeanUint64(a.bandwidthOut)
        metrics.BandwidthInTotal = a.calculateSumUint64(a.bandwidthIn)
        metrics.BandwidthOutTotal = a.calculateSumUint64(a.bandwidthOut)
        metrics.BandwidthInPeak = a.calculateMaxUint64(a.bandwidthIn)
        metrics.BandwidthOutPeak = a.calculateMaxUint64(a.bandwidthOut)

        // Calculate error rate metrics
        metrics.ErrorRateMean = a.calculateErrorRate()
        metrics.ErrorRatePeak = a.calculatePeakErrorRate()
        metrics.ErrorRateTrend = a.calculateTrend(a.errorRateHistory())

        // Calculate traffic metrics
        if len(a.timestamps) &gt;= 2 </span><span class="cov3" title="4">{
                duration := float64(a.timestamps[len(a.timestamps)-1] - a.timestamps[0])
                if duration &gt; 0 </span><span class="cov0" title="0">{
                        totalRequests := 0
                        for _, count := range a.requestCounts </span><span class="cov0" title="0">{
                                totalRequests += count
                        }</span>
                        <span class="cov0" title="0">metrics.RequestsPerSecond = float64(totalRequests) / duration</span>
                }
        }
        <span class="cov3" title="4">metrics.RequestsPeak = a.calculateMaxInt(a.requestCounts)
        metrics.TrafficTrend = a.calculateTrend(a.requestHistory())

        return metrics</span>
}

// calculatePercentile calculates the Nth percentile of a dataset
func (a *Aggregator) calculatePercentile(data []float64, percentile float64) float64 <span class="cov5" title="16">{
        if len(data) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        // Create a copy and sort
        <span class="cov5" title="16">sorted := make([]float64, len(data))
        copy(sorted, data)
        sort.Float64s(sorted)

        index := percentile * float64(len(sorted)-1)
        lower := int(math.Floor(index))
        upper := int(math.Ceil(index))

        if lower == upper </span><span class="cov2" title="2">{
                return sorted[lower]
        }</span>

        // Linear interpolation
        <span class="cov5" title="14">weight := index - float64(lower)
        return sorted[lower]*(1-weight) + sorted[upper]*weight</span>
}

// calculateMean calculates the mean of float64 values
func (a *Aggregator) calculateMean(data []float64) float64 <span class="cov3" title="4">{
        if len(data) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov3" title="4">sum := 0.0
        for _, val := range data </span><span class="cov8" title="118">{
                sum += val
        }</span>
        <span class="cov3" title="4">return sum / float64(len(data))</span>
}

// calculateStdDev calculates the standard deviation
func (a *Aggregator) calculateStdDev(data []float64, mean float64) float64 <span class="cov3" title="4">{
        if len(data) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov3" title="4">variance := 0.0
        for _, val := range data </span><span class="cov8" title="118">{
                diff := val - mean
                variance += diff * diff
        }</span>
        <span class="cov3" title="4">variance /= float64(len(data))
        return math.Sqrt(variance)</span>
}

// calculateMeanUint64 calculates the mean of uint64 values
func (a *Aggregator) calculateMeanUint64(data []uint64) float64 <span class="cov4" title="8">{
        if len(data) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov4" title="8">sum := uint64(0)
        for _, val := range data </span><span class="cov10" title="236">{
                sum += val
        }</span>
        <span class="cov4" title="8">return float64(sum) / float64(len(data))</span>
}

// calculateSumUint64 calculates the sum of uint64 values
func (a *Aggregator) calculateSumUint64(data []uint64) uint64 <span class="cov4" title="8">{
        sum := uint64(0)
        for _, val := range data </span><span class="cov10" title="236">{
                sum += val
        }</span>
        <span class="cov4" title="8">return sum</span>
}

// calculateMaxUint64 finds the maximum uint64 value
func (a *Aggregator) calculateMaxUint64(data []uint64) uint64 <span class="cov4" title="8">{
        if len(data) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov4" title="8">max := data[0]
        for _, val := range data[1:] </span><span class="cov9" title="228">{
                if val &gt; max </span><span class="cov5" title="20">{
                        max = val
                }</span>
        }
        <span class="cov4" title="8">return max</span>
}

// calculateMaxInt finds the maximum int value
func (a *Aggregator) calculateMaxInt(data []int) int <span class="cov3" title="4">{
        if len(data) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov3" title="4">max := data[0]
        for _, val := range data[1:] </span><span class="cov8" title="114">{
                if val &gt; max </span><span class="cov0" title="0">{
                        max = val
                }</span>
        }
        <span class="cov3" title="4">return max</span>
}

// errorRateHistory returns error rate for each sample
func (a *Aggregator) errorRateHistory() []float64 <span class="cov3" title="4">{
        history := make([]float64, len(a.errorCounts))
        for i := range a.errorCounts </span><span class="cov8" title="118">{
                if a.requestCounts[i] &gt; 0 </span><span class="cov8" title="118">{
                        history[i] = float64(a.errorCounts[i]) / float64(a.requestCounts[i]) * 100
                }</span>
        }
        <span class="cov3" title="4">return history</span>
}

// requestHistory returns normalized request counts
func (a *Aggregator) requestHistory() []float64 <span class="cov3" title="4">{
        history := make([]float64, len(a.requestCounts))
        for i := range a.requestCounts </span><span class="cov8" title="118">{
                history[i] = float64(a.requestCounts[i])
        }</span>
        <span class="cov3" title="4">return history</span>
}

// calculateErrorRate calculates mean error rate
func (a *Aggregator) calculateErrorRate() float64 <span class="cov3" title="4">{
        totalErrors := 0
        totalRequests := 0
        for i := range a.errorCounts </span><span class="cov8" title="118">{
                totalErrors += a.errorCounts[i]
                totalRequests += a.requestCounts[i]
        }</span>

        <span class="cov3" title="4">if totalRequests == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov3" title="4">return float64(totalErrors) / float64(totalRequests) * 100</span>
}

// calculatePeakErrorRate calculates peak error rate in any sample
func (a *Aggregator) calculatePeakErrorRate() float64 <span class="cov3" title="4">{
        peak := 0.0
        for i := range a.errorCounts </span><span class="cov8" title="118">{
                if a.requestCounts[i] &gt; 0 </span><span class="cov8" title="118">{
                        rate := float64(a.errorCounts[i]) / float64(a.requestCounts[i]) * 100
                        if rate &gt; peak </span><span class="cov1" title="1">{
                                peak = rate
                        }</span>
                }
        }
        <span class="cov3" title="4">return peak</span>
}

// calculateTrend determines if values are increasing, decreasing, or stable
func (a *Aggregator) calculateTrend(data []float64) string <span class="cov4" title="8">{
        if len(data) &lt; 3 </span><span class="cov0" title="0">{
                return "stable"
        }</span>

        // Simple linear regression slope calculation
        <span class="cov4" title="8">n := float64(len(data))
        sumX, sumY, sumXY, sumX2 := 0.0, 0.0, 0.0, 0.0

        for i, y := range data </span><span class="cov10" title="236">{
                x := float64(i)
                sumX += x
                sumY += y
                sumXY += x * y
                sumX2 += x * x
        }</span>

        // Calculate slope: (n*sumXY - sumX*sumY) / (n*sumX2 - sumX*sumX)
        <span class="cov4" title="8">numerator := n*sumXY - sumX*sumY
        denominator := n*sumX2 - sumX*sumX

        if denominator == 0 </span><span class="cov0" title="0">{
                return "stable"
        }</span>

        <span class="cov4" title="8">slope := numerator / denominator

        // Determine trend based on slope
        // Use relative slope compared to mean value
        mean := sumY / n
        if mean == 0 </span><span class="cov2" title="3">{
                return "stable"
        }</span>

        <span class="cov3" title="5">relativeSlope := slope / mean

        if relativeSlope &gt; 0.05 </span><span class="cov1" title="1">{ // More than 5% increase per sample
                return "increasing"
        }</span> else<span class="cov3" title="4"> if relativeSlope &lt; -0.05 </span><span class="cov0" title="0">{ // More than 5% decrease per sample
                return "decreasing"
        }</span>
        <span class="cov3" title="4">return "stable"</span>
}

// Reset clears all metrics data
func (a *Aggregator) Reset() <span class="cov0" title="0">{
        a.mu.Lock()
        defer a.mu.Unlock()

        a.responseTimes = make([]float64, 0, a.windowSize)
        a.bandwidthIn = make([]uint64, 0, a.windowSize)
        a.bandwidthOut = make([]uint64, 0, a.windowSize)
        a.errorCounts = make([]int, 0, a.windowSize)
        a.requestCounts = make([]int, 0, a.windowSize)
        a.timestamps = make([]int64, 0, a.windowSize)
        a.startTime = time.Now()

        log.Info().Msg("Analytics aggregator reset")
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package audit

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "strconv"
        "time"

        "github.com/rs/zerolog/log"
)

// Action types for audit logging
const (
        ActionConfigReload    = "config_reload"
        ActionRouteAdd        = "route_add"
        ActionRouteRemove     = "route_remove"
        ActionRouteUpdate     = "route_update"
        ActionCertUpdate      = "certificate_update"
        ActionServiceRegister = "service_register"
        ActionServiceRemove   = "service_remove"
        ActionRateLimitChange = "rate_limit_change"
        ActionWAFRuleChange   = "waf_rule_change"
        ActionStartup         = "startup"
        ActionShutdown        = "shutdown"
)

// Logger handles audit logging
type Logger struct {
        db      Database
        enabled bool
}

// Database interface for audit logging
type Database interface {
        LogAudit(user, action, resourceType, resourceID, oldValue, newValue, ipAddress, metadata string) error
        GetAuditLogs(limit int, action, resourceType string, since time.Time) ([]AuditEntry, error)
}

// AuditEntry represents an audit log entry
type AuditEntry struct {
        ID           int64
        Timestamp    int64
        User         string
        Action       string
        ResourceType string
        ResourceID   string
        OldValue     string
        NewValue     string
        IPAddress    string
        Metadata     string
}

// NewLogger creates a new audit logger
func NewLogger(db Database, enabled bool) *Logger <span class="cov0" title="0">{
        return &amp;Logger{
                db:      db,
                enabled: enabled,
        }
}</span>

// Log logs an audit event
func (l *Logger) Log(action, resourceType, resourceID, oldValue, newValue, ipAddress, metadata string) error <span class="cov0" title="0">{
        if !l.enabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">user := "system" // Default user, could be extended to support actual users

        if err := l.db.LogAudit(user, action, resourceType, resourceID, oldValue, newValue, ipAddress, metadata); err != nil </span><span class="cov0" title="0">{
                log.Error().
                        Err(err).
                        Str("action", action).
                        Str("resource_type", resourceType).
                        Str("resource_id", resourceID).
                        Msg("Failed to log audit entry")
                return err
        }</span>

        <span class="cov0" title="0">log.Info().
                Str("action", action).
                Str("resource_type", resourceType).
                Str("resource_id", resourceID).
                Msg("Audit log recorded")

        return nil</span>
}

// LogConfigReload logs a configuration reload event
func (l *Logger) LogConfigReload(configPath, reason string) error <span class="cov0" title="0">{
        metadata := map[string]string{
                "reason": reason,
        }
        metadataJSON, _ := json.Marshal(metadata)

        return l.Log(
                ActionConfigReload,
                "config",
                configPath,
                "",
                "",
                "",
                string(metadataJSON),
        )
}</span>

// LogRouteChange logs a route add/remove/update event
func (l *Logger) LogRouteChange(action string, domains []string, path, backend string) error <span class="cov0" title="0">{
        domainsStr := fmt.Sprintf("%v", domains)
        routeInfo := fmt.Sprintf("%s -&gt; %s", path, backend)

        return l.Log(
                action,
                "route",
                domainsStr,
                "",
                routeInfo,
                "",
                "",
        )
}</span>

// LogCertUpdate logs a certificate update event
func (l *Logger) LogCertUpdate(domains []string) error <span class="cov0" title="0">{
        domainsStr := fmt.Sprintf("%v", domains)

        return l.Log(
                ActionCertUpdate,
                "certificate",
                domainsStr,
                "",
                "",
                "",
                "",
        )
}</span>

// LogServiceChange logs a service registration/removal event
func (l *Logger) LogServiceChange(action, serviceName, hostname string, port int) error <span class="cov0" title="0">{
        serviceID := fmt.Sprintf("%s:%s:%d", serviceName, hostname, port)

        return l.Log(
                action,
                "service",
                serviceID,
                "",
                "",
                "",
                "",
        )
}</span>

// LogStartup logs application startup
func (l *Logger) LogStartup(version string) error <span class="cov0" title="0">{
        metadata := map[string]string{
                "version": version,
        }
        metadataJSON, _ := json.Marshal(metadata)

        return l.Log(
                ActionStartup,
                "application",
                "proxy-manager",
                "",
                "",
                "",
                string(metadataJSON),
        )
}</span>

// LogShutdown logs application shutdown
func (l *Logger) LogShutdown(reason string) error <span class="cov0" title="0">{
        metadata := map[string]string{
                "reason": reason,
        }
        metadataJSON, _ := json.Marshal(metadata)

        return l.Log(
                ActionShutdown,
                "application",
                "proxy-manager",
                "",
                "",
                "",
                string(metadataJSON),
        )
}</span>

// APIHandler returns an HTTP handler for querying audit logs
func (l *Logger) APIHandler() http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                        http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                        return
                }</span>

                // Parse query parameters
                <span class="cov0" title="0">query := r.URL.Query()
                limitStr := query.Get("limit")
                action := query.Get("action")
                resourceType := query.Get("resource_type")
                sinceStr := query.Get("since")

                // Default limit
                limit := 100
                if limitStr != "" </span><span class="cov0" title="0">{
                        if l, err := strconv.Atoi(limitStr); err == nil &amp;&amp; l &gt; 0 </span><span class="cov0" title="0">{
                                limit = l
                                if limit &gt; 1000 </span><span class="cov0" title="0">{
                                        limit = 1000 // Max 1000 entries
                                }</span>
                        }
                }

                // Parse since timestamp
                <span class="cov0" title="0">var since time.Time
                if sinceStr != "" </span><span class="cov0" title="0">{
                        if ts, err := strconv.ParseInt(sinceStr, 10, 64); err == nil </span><span class="cov0" title="0">{
                                since = time.Unix(ts, 0)
                        }</span>
                }

                // Get audit logs
                <span class="cov0" title="0">entries, err := l.db.GetAuditLogs(limit, action, resourceType, since)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Err(err).Msg("Failed to get audit logs")
                        http.Error(w, "Internal server error", http.StatusInternalServerError)
                        return
                }</span>

                // Return as JSON
                <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
                if err := json.NewEncoder(w).Encode(map[string]interface{}{
                        "count":   len(entries),
                        "entries": entries,
                }); err != nil </span><span class="cov0" title="0">{
                        log.Error().Err(err).Msg("Failed to encode audit logs")
                }</span>
        }
}

// GetStats returns audit logging statistics
func (l *Logger) GetStats() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "enabled": l.enabled,
        }
}</span>

// Start starts background tasks (currently none needed)
func (l *Logger) Start(ctx context.Context) <span class="cov0" title="0">{
        log.Info().Bool("enabled", l.enabled).Msg("Audit logger initialized")
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package certmonitor

import (
        "crypto/tls"
        "crypto/x509"
        "fmt"
        "sync"
        "time"

        "github.com/rs/zerolog/log"
)

// Monitor tracks SSL/TLS certificate expiry dates
type Monitor struct {
        certs      map[string]*CertInfo
        certsMutex sync.RWMutex
        enabled    bool
}

// CertInfo represents SSL/TLS certificate information
type CertInfo struct {
        Domain        string    `json:"domain"`
        Issuer        string    `json:"issuer"`
        Subject       string    `json:"subject"`
        NotBefore     time.Time `json:"not_before"`
        NotAfter      time.Time `json:"not_after"`
        DaysRemaining int       `json:"days_remaining"`
        WarningLevel  string    `json:"warning_level"` // ok, warning, urgent, critical
        SerialNumber  string    `json:"serial_number"`
        SignatureAlgo string    `json:"signature_algorithm"`
        PublicKeyAlgo string    `json:"public_key_algorithm"`
        DNSNames      []string  `json:"dns_names"`
        LastChecked   time.Time `json:"last_checked"`
}

// WarningLevel constants
const (
        LevelOK       = "ok"
        LevelWarning  = "warning"  // 30 days
        LevelUrgent   = "urgent"   // 14 days
        LevelCritical = "critical" // 7 days
)

// NewMonitor creates a new certificate monitor
func NewMonitor() *Monitor <span class="cov0" title="0">{
        return &amp;Monitor{
                certs:   make(map[string]*CertInfo),
                enabled: true,
        }
}</span>

// AddCertificate adds or updates a certificate for monitoring
func (m *Monitor) AddCertificate(domain string, cert *x509.Certificate) <span class="cov0" title="0">{
        if !m.enabled || cert == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">info := m.parseCertificate(domain, cert)

        m.certsMutex.Lock()
        m.certs[domain] = info
        m.certsMutex.Unlock()

        // Log warnings for expiring certificates
        if info.WarningLevel != LevelOK </span><span class="cov0" title="0">{
                log.Warn().
                        Str("domain", domain).
                        Str("warning_level", info.WarningLevel).
                        Int("days_remaining", info.DaysRemaining).
                        Time("expires", info.NotAfter).
                        Msg("Certificate expiring soon")
        }</span>
}

// AddCertificateFromTLS adds a certificate from tls.Certificate
func (m *Monitor) AddCertificateFromTLS(domain string, tlsCert *tls.Certificate) error <span class="cov0" title="0">{
        if tlsCert == nil || len(tlsCert.Certificate) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid TLS certificate")
        }</span>

        // Parse the first certificate in the chain (leaf certificate)
        <span class="cov0" title="0">cert, err := x509.ParseCertificate(tlsCert.Certificate[0])
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse certificate: %w", err)
        }</span>

        <span class="cov0" title="0">m.AddCertificate(domain, cert)
        return nil</span>
}

// parseCertificate extracts information from an x509 certificate
func (m *Monitor) parseCertificate(domain string, cert *x509.Certificate) *CertInfo <span class="cov0" title="0">{
        now := time.Now()
        daysRemaining := int(time.Until(cert.NotAfter).Hours() / 24)

        info := &amp;CertInfo{
                Domain:        domain,
                Issuer:        cert.Issuer.String(),
                Subject:       cert.Subject.String(),
                NotBefore:     cert.NotBefore,
                NotAfter:      cert.NotAfter,
                DaysRemaining: daysRemaining,
                SerialNumber:  cert.SerialNumber.String(),
                SignatureAlgo: cert.SignatureAlgorithm.String(),
                PublicKeyAlgo: cert.PublicKeyAlgorithm.String(),
                DNSNames:      cert.DNSNames,
                LastChecked:   now,
        }

        // Calculate warning level
        switch </span>{
        case daysRemaining &lt;= 7:<span class="cov0" title="0">
                info.WarningLevel = LevelCritical</span>
        case daysRemaining &lt;= 14:<span class="cov0" title="0">
                info.WarningLevel = LevelUrgent</span>
        case daysRemaining &lt;= 30:<span class="cov0" title="0">
                info.WarningLevel = LevelWarning</span>
        default:<span class="cov0" title="0">
                info.WarningLevel = LevelOK</span>
        }

        <span class="cov0" title="0">return info</span>
}

// GetCertificate returns certificate info for a domain
func (m *Monitor) GetCertificate(domain string) (*CertInfo, bool) <span class="cov0" title="0">{
        m.certsMutex.RLock()
        defer m.certsMutex.RUnlock()

        info, exists := m.certs[domain]
        return info, exists
}</span>

// GetAllCertificates returns all monitored certificates
func (m *Monitor) GetAllCertificates() map[string]*CertInfo <span class="cov0" title="0">{
        m.certsMutex.RLock()
        defer m.certsMutex.RUnlock()

        // Create a copy to avoid race conditions
        result := make(map[string]*CertInfo, len(m.certs))
        for domain, info := range m.certs </span><span class="cov0" title="0">{
                // Create a copy of the cert info
                infoCopy := *info
                result[domain] = &amp;infoCopy
        }</span>

        <span class="cov0" title="0">return result</span>
}

// GetExpiringCertificates returns certificates that are expiring soon
func (m *Monitor) GetExpiringCertificates(minWarningLevel string) []*CertInfo <span class="cov0" title="0">{
        m.certsMutex.RLock()
        defer m.certsMutex.RUnlock()

        var expiring []*CertInfo

        for _, info := range m.certs </span><span class="cov0" title="0">{
                // Filter by warning level
                include := false
                switch minWarningLevel </span>{
                case LevelCritical:<span class="cov0" title="0">
                        include = info.WarningLevel == LevelCritical</span>
                case LevelUrgent:<span class="cov0" title="0">
                        include = info.WarningLevel == LevelUrgent || info.WarningLevel == LevelCritical</span>
                case LevelWarning:<span class="cov0" title="0">
                        include = info.WarningLevel != LevelOK</span>
                default:<span class="cov0" title="0">
                        include = true</span>
                }

                <span class="cov0" title="0">if include </span><span class="cov0" title="0">{
                        infoCopy := *info
                        expiring = append(expiring, &amp;infoCopy)
                }</span>
        }

        <span class="cov0" title="0">return expiring</span>
}

// GetExpiredCertificates returns certificates that have already expired
func (m *Monitor) GetExpiredCertificates() []*CertInfo <span class="cov0" title="0">{
        m.certsMutex.RLock()
        defer m.certsMutex.RUnlock()

        var expired []*CertInfo
        now := time.Now()

        for _, info := range m.certs </span><span class="cov0" title="0">{
                if info.NotAfter.Before(now) </span><span class="cov0" title="0">{
                        infoCopy := *info
                        expired = append(expired, &amp;infoCopy)
                }</span>
        }

        <span class="cov0" title="0">return expired</span>
}

// GetStats returns certificate monitoring statistics
func (m *Monitor) GetStats() CertStats <span class="cov0" title="0">{
        m.certsMutex.RLock()
        defer m.certsMutex.RUnlock()

        stats := CertStats{
                TotalCertificates: len(m.certs),
        }

        now := time.Now()

        for _, info := range m.certs </span><span class="cov0" title="0">{
                if info.NotAfter.Before(now) </span><span class="cov0" title="0">{
                        stats.ExpiredCount++
                }</span>

                <span class="cov0" title="0">switch info.WarningLevel </span>{
                case LevelCritical:<span class="cov0" title="0">
                        stats.CriticalCount++</span>
                case LevelUrgent:<span class="cov0" title="0">
                        stats.UrgentCount++</span>
                case LevelWarning:<span class="cov0" title="0">
                        stats.WarningCount++</span>
                case LevelOK:<span class="cov0" title="0">
                        stats.HealthyCount++</span>
                }
        }

        <span class="cov0" title="0">return stats</span>
}

// CertStats represents certificate monitoring statistics
type CertStats struct {
        TotalCertificates int `json:"total_certificates"`
        HealthyCount      int `json:"healthy_count"`
        WarningCount      int `json:"warning_count"`
        UrgentCount       int `json:"urgent_count"`
        CriticalCount     int `json:"critical_count"`
        ExpiredCount      int `json:"expired_count"`
}

// RemoveCertificate removes a certificate from monitoring
func (m *Monitor) RemoveCertificate(domain string) <span class="cov0" title="0">{
        m.certsMutex.Lock()
        defer m.certsMutex.Unlock()

        delete(m.certs, domain)
        log.Info().Str("domain", domain).Msg("Certificate removed from monitoring")
}</span>

// Enable enables certificate monitoring
func (m *Monitor) Enable() <span class="cov0" title="0">{
        m.enabled = true
        log.Info().Msg("Certificate monitoring enabled")
}</span>

// Disable disables certificate monitoring
func (m *Monitor) Disable() <span class="cov0" title="0">{
        m.enabled = false
        log.Info().Msg("Certificate monitoring disabled")
}</span>

// IsEnabled returns whether certificate monitoring is enabled
func (m *Monitor) IsEnabled() bool <span class="cov0" title="0">{
        return m.enabled
}</span>

// CheckAll rechecks all certificates and updates their expiry info
func (m *Monitor) CheckAll() <span class="cov0" title="0">{
        m.certsMutex.Lock()
        defer m.certsMutex.Unlock()

        now := time.Now()

        for domain, info := range m.certs </span><span class="cov0" title="0">{
                // Recalculate days remaining
                daysRemaining := int(time.Until(info.NotAfter).Hours() / 24)
                info.DaysRemaining = daysRemaining
                info.LastChecked = now

                // Recalculate warning level
                switch </span>{
                case daysRemaining &lt;= 7:<span class="cov0" title="0">
                        info.WarningLevel = LevelCritical</span>
                case daysRemaining &lt;= 14:<span class="cov0" title="0">
                        info.WarningLevel = LevelUrgent</span>
                case daysRemaining &lt;= 30:<span class="cov0" title="0">
                        info.WarningLevel = LevelWarning</span>
                default:<span class="cov0" title="0">
                        info.WarningLevel = LevelOK</span>
                }

                // Log if status changed to warning/critical
                <span class="cov0" title="0">if info.WarningLevel != LevelOK </span><span class="cov0" title="0">{
                        log.Warn().
                                Str("domain", domain).
                                Str("warning_level", info.WarningLevel).
                                Int("days_remaining", daysRemaining).
                                Time("expires", info.NotAfter).
                                Msg("Certificate expiring soon")
                }</span>
        }

        <span class="cov0" title="0">log.Debug().Int("count", len(m.certs)).Msg("Rechecked all certificates")</span>
}

// StartPeriodicCheck starts periodic certificate expiry checks
func (m *Monitor) StartPeriodicCheck(interval time.Duration) <span class="cov0" title="0">{
        go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(interval)
                defer ticker.Stop()

                log.Info().
                        Dur("interval", interval).
                        Msg("Started periodic certificate expiry checks")

                for range ticker.C </span><span class="cov0" title="0">{
                        if m.enabled </span><span class="cov0" title="0">{
                                m.CheckAll()
                        }</span>
                }
        }()
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package config

import (
        "fmt"
        "os"
        "time"

        "gopkg.in/yaml.v3"
)

// GlobalConfig holds proxy-wide configuration
type GlobalConfig struct {
        Defaults struct {
                Headers map[string]string `yaml:"headers"`
                Options OptionConfig      `yaml:"options"`
        } `yaml:"defaults"`

        Blackhole struct {
                UnknownDomains bool `yaml:"unknown_domains"`
                MetricsOnly    bool `yaml:"metrics_only"`
        } `yaml:"blackhole"`

        TLS struct {
                Certificates []CertConfig `yaml:"certificates"`
        } `yaml:"tls"`
}

// CertConfig represents a TLS certificate configuration
type CertConfig struct {
        Domains  []string `yaml:"domains"`
        CertFile string   `yaml:"cert_file"`
        KeyFile  string   `yaml:"key_file"`
}

// SiteConfig represents a single site configuration file
type SiteConfig struct {
        Enabled bool `yaml:"enabled"`

        Service struct {
                Name            string `yaml:"name"`
                MaintenancePort int    `yaml:"maintenance_port,omitempty"`
        } `yaml:"service"`

        Routes []RouteConfig `yaml:"routes,omitempty"`

        Headers map[string]string `yaml:"headers,omitempty"`

        Options OptionConfig `yaml:"options,omitempty"`
}

// RouteConfig represents a routing rule
type RouteConfig struct {
        Domains   []string          `yaml:"domains"`
        Path      string            `yaml:"path"`
        Backend   string            `yaml:"backend"`
        WebSocket bool              `yaml:"websocket,omitempty"`
        Headers   map[string]string `yaml:"headers,omitempty"`
}

// OptionConfig represents service options
type OptionConfig struct {
        HealthCheckPath     string        `yaml:"health_check_path,omitempty"`
        HealthCheckInterval string        `yaml:"health_check_interval,omitempty"`
        HealthCheckTimeout  string        `yaml:"health_check_timeout,omitempty"`
        Timeout             string        `yaml:"timeout,omitempty"`
        MaxBodySize         string        `yaml:"max_body_size,omitempty"`
        Compression         *bool         `yaml:"compression,omitempty"`
        WebSocket           *bool         `yaml:"websocket,omitempty"`
        HTTP2               *bool         `yaml:"http2,omitempty"`
        HTTP3               *bool         `yaml:"http3,omitempty"`
        Timeouts            TimeoutConfig `yaml:"timeouts,omitempty"`
        Limits              LimitConfig   `yaml:"limits,omitempty"`
}

// TimeoutConfig represents timeout settings for a route
type TimeoutConfig struct {
        Connect time.Duration `yaml:"connect,omitempty"` // Default: 5s
        Read    time.Duration `yaml:"read,omitempty"`    // Default: 30s
        Write   time.Duration `yaml:"write,omitempty"`   // Default: 30s
        Idle    time.Duration `yaml:"idle,omitempty"`    // Default: 120s
}

// LimitConfig represents size limits for requests/responses
type LimitConfig struct {
        MaxRequestBody  int64 `yaml:"max_request_body,omitempty"`  // Bytes, default: 10MB
        MaxResponseBody int64 `yaml:"max_response_body,omitempty"` // Bytes, default: 10MB
}

// GetTimeouts returns timeout configuration with defaults
func (t *TimeoutConfig) GetTimeouts() TimeoutConfig <span class="cov0" title="0">{
        defaults := TimeoutConfig{
                Connect: 5 * time.Second,
                Read:    30 * time.Second,
                Write:   30 * time.Second,
                Idle:    120 * time.Second,
        }

        if t.Connect &gt; 0 </span><span class="cov0" title="0">{
                defaults.Connect = t.Connect
        }</span>
        <span class="cov0" title="0">if t.Read &gt; 0 </span><span class="cov0" title="0">{
                defaults.Read = t.Read
        }</span>
        <span class="cov0" title="0">if t.Write &gt; 0 </span><span class="cov0" title="0">{
                defaults.Write = t.Write
        }</span>
        <span class="cov0" title="0">if t.Idle &gt; 0 </span><span class="cov0" title="0">{
                defaults.Idle = t.Idle
        }</span>

        <span class="cov0" title="0">return defaults</span>
}

// GetLimits returns limit configuration with defaults
func (l *LimitConfig) GetLimits() LimitConfig <span class="cov0" title="0">{
        defaults := LimitConfig{
                MaxRequestBody:  10 * 1024 * 1024, // 10 MB
                MaxResponseBody: 10 * 1024 * 1024, // 10 MB
        }

        if l.MaxRequestBody &gt; 0 </span><span class="cov0" title="0">{
                defaults.MaxRequestBody = l.MaxRequestBody
        }</span>
        <span class="cov0" title="0">if l.MaxResponseBody &gt; 0 </span><span class="cov0" title="0">{
                defaults.MaxResponseBody = l.MaxResponseBody
        }</span>

        <span class="cov0" title="0">return defaults</span>
}

// LoadGlobalConfig loads global configuration from YAML file
func LoadGlobalConfig(path string) (*GlobalConfig, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read config file: %w", err)
        }</span>

        <span class="cov8" title="1">var cfg GlobalConfig
        if err := yaml.Unmarshal(data, &amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse YAML: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;cfg, nil</span>
}

// LoadSiteConfig loads a site configuration from YAML file
func LoadSiteConfig(path string) (*SiteConfig, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read config file: %w", err)
        }</span>

        <span class="cov8" title="1">var cfg SiteConfig
        if err := yaml.Unmarshal(data, &amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse YAML: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;cfg, nil</span>
}

// Validate validates the site configuration
func (c *SiteConfig) Validate() error <span class="cov8" title="1">{
        if c.Service.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("service.name is required")
        }</span>

        <span class="cov8" title="1">if len(c.Routes) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("at least one route is required")
        }</span>

        <span class="cov8" title="1">for i, route := range c.Routes </span><span class="cov8" title="1">{
                if len(route.Domains) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("route %d: domains is required", i)
                }</span>
                <span class="cov8" title="1">if route.Path == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("route %d: path is required", i)
                }</span>
                <span class="cov8" title="1">if route.Backend == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("route %d: backend is required", i)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// GetOptions returns parsed options with defaults
func (c *SiteConfig) GetOptions() (map[string]interface{}, error) <span class="cov8" title="1">{
        opts := make(map[string]interface{})

        if c.Options.HealthCheckPath != "" </span><span class="cov0" title="0">{
                opts["health_check_path"] = c.Options.HealthCheckPath
        }</span>

        <span class="cov8" title="1">if c.Options.HealthCheckInterval != "" </span><span class="cov8" title="1">{
                dur, err := time.ParseDuration(c.Options.HealthCheckInterval)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid health_check_interval: %w", err)
                }</span>
                <span class="cov8" title="1">opts["health_check_interval"] = dur</span>
        }

        <span class="cov8" title="1">if c.Options.HealthCheckTimeout != "" </span><span class="cov8" title="1">{
                dur, err := time.ParseDuration(c.Options.HealthCheckTimeout)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid health_check_timeout: %w", err)
                }</span>
                <span class="cov8" title="1">opts["health_check_timeout"] = dur</span>
        }

        <span class="cov8" title="1">if c.Options.Timeout != "" </span><span class="cov8" title="1">{
                dur, err := time.ParseDuration(c.Options.Timeout)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid timeout: %w", err)
                }</span>
                <span class="cov8" title="1">opts["timeout"] = dur</span>
        }

        <span class="cov8" title="1">if c.Options.MaxBodySize != "" </span><span class="cov8" title="1">{
                size, err := parseSize(c.Options.MaxBodySize)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid max_body_size: %w", err)
                }</span>
                <span class="cov8" title="1">opts["max_body_size"] = size</span>
        }

        <span class="cov8" title="1">if c.Options.Compression != nil </span><span class="cov0" title="0">{
                opts["compression"] = *c.Options.Compression
        }</span>

        <span class="cov8" title="1">if c.Options.WebSocket != nil </span><span class="cov0" title="0">{
                opts["websocket"] = *c.Options.WebSocket
        }</span>

        <span class="cov8" title="1">if c.Options.HTTP2 != nil </span><span class="cov8" title="1">{
                opts["http2"] = *c.Options.HTTP2
        }</span>

        <span class="cov8" title="1">if c.Options.HTTP3 != nil </span><span class="cov8" title="1">{
                opts["http3"] = *c.Options.HTTP3
        }</span>

        <span class="cov8" title="1">return opts, nil</span>
}

// parseSize parses size strings like "10M", "1G", "512K"
func parseSize(s string) (int64, error) <span class="cov8" title="1">{
        if len(s) == 0 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("empty size string")
        }</span>

        <span class="cov8" title="1">multiplier := int64(1)
        unit := s[len(s)-1]

        switch unit </span>{
        case 'K', 'k':<span class="cov0" title="0">
                multiplier = 1024
                s = s[:len(s)-1]</span>
        case 'M', 'm':<span class="cov8" title="1">
                multiplier = 1024 * 1024
                s = s[:len(s)-1]</span>
        case 'G', 'g':<span class="cov0" title="0">
                multiplier = 1024 * 1024 * 1024
                s = s[:len(s)-1]</span>
        }

        <span class="cov8" title="1">var size int64
        if _, err := fmt.Sscanf(s, "%d", &amp;size); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid size format: %w", err)
        }</span>

        <span class="cov8" title="1">return size * multiplier, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package database

import (
        "database/sql"
        "fmt"
        "time"

        "github.com/rs/zerolog/log"
        _ "modernc.org/sqlite"
)

// DB wraps the SQLite database connection
type DB struct {
        *sql.DB
}

// AccessLogEntry represents an HTTP access log entry
type AccessLogEntry struct {
        Timestamp      int64  `json:"timestamp"`
        Domain         string `json:"domain"`
        Method         string `json:"method"`
        Path           string `json:"path"`
        Query          string `json:"query,omitempty"`
        Status         int    `json:"status"`
        ResponseTimeMs int64  `json:"response_time_ms"`
        Backend        string `json:"backend"`
        BackendIP      string `json:"backend_ip,omitempty"`
        ClientIP       string `json:"client_ip"`
        UserAgent      string `json:"user_agent,omitempty"`
        Referer        string `json:"referer,omitempty"`
        BytesSent      uint64 `json:"bytes_sent"`
        BytesReceived  uint64 `json:"bytes_received"`
        Protocol       string `json:"protocol"`
        Error          string `json:"error,omitempty"`
}

// HealthCheckResult represents a health check result from database
type HealthCheckResult struct {
        Timestamp  int64  `json:"timestamp"`
        Service    string `json:"service"`
        URL        string `json:"url"`
        Success    bool   `json:"success"`
        Duration   int64  `json:"duration_ms"`
        StatusCode int    `json:"status_code"`
        Error      string `json:"error,omitempty"`
}

// Open opens a SQLite database connection and initializes schema
func Open(path string) (*DB, error) <span class="cov0" title="0">{
        log.Info().Str("path", path).Msg("Opening database")

        db, err := sql.Open("sqlite", path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open database: %w", err)
        }</span>

        // Configure connection pool
        <span class="cov0" title="0">db.SetMaxOpenConns(1) // SQLite only supports 1 writer
        db.SetMaxIdleConns(1)
        db.SetConnMaxLifetime(0)

        // Test connection
        if err := db.Ping(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to ping database: %w", err)
        }</span>

        <span class="cov0" title="0">wrapper := &amp;DB{DB: db}

        // Initialize schema
        if err := wrapper.initSchema(); err != nil </span><span class="cov0" title="0">{
                db.Close()
                return nil, fmt.Errorf("failed to initialize schema: %w", err)
        }</span>

        <span class="cov0" title="0">log.Info().Msg("Database initialized successfully")
        return wrapper, nil</span>
}

// initSchema creates all required tables
func (db *DB) initSchema() error <span class="cov0" title="0">{
        schema := `
        -- Enable foreign keys
        PRAGMA foreign_keys = ON;
        PRAGMA journal_mode = WAL;

        -- Service Registry
        CREATE TABLE IF NOT EXISTS services (
                service_id INTEGER PRIMARY KEY AUTOINCREMENT,
                service_name TEXT NOT NULL,
                container_id TEXT,
                ip_address TEXT,
                port INTEGER NOT NULL,
                protocol TEXT DEFAULT 'http',
                status TEXT DEFAULT 'unknown',
                last_check INTEGER,
                metadata TEXT,
                UNIQUE(service_name, port)
        );

        -- Route Configurations
        CREATE TABLE IF NOT EXISTS routes (
                route_id INTEGER PRIMARY KEY AUTOINCREMENT,
                domain TEXT NOT NULL,
                path TEXT DEFAULT '/',
                service_id INTEGER,
                backend_url TEXT NOT NULL,
                enabled INTEGER DEFAULT 1,
                config_hash TEXT,
                created_at INTEGER DEFAULT (strftime('%s', 'now')),
                updated_at INTEGER DEFAULT (strftime('%s', 'now')),
                FOREIGN KEY(service_id) REFERENCES services(service_id)
        );
        CREATE INDEX IF NOT EXISTS idx_routes_domain ON routes(domain);
        CREATE INDEX IF NOT EXISTS idx_routes_enabled ON routes(enabled);

        -- Time-Series Metrics
        CREATE TABLE IF NOT EXISTS metrics (
                metric_id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp INTEGER NOT NULL,
                route_id INTEGER,
                service_id INTEGER,
                metric_type TEXT NOT NULL,
                value REAL NOT NULL,
                labels TEXT,
                FOREIGN KEY(route_id) REFERENCES routes(route_id),
                FOREIGN KEY(service_id) REFERENCES services(service_id)
        );
        CREATE INDEX IF NOT EXISTS idx_metrics_timestamp ON metrics(timestamp);
        CREATE INDEX IF NOT EXISTS idx_metrics_service ON metrics(service_id);
        CREATE INDEX IF NOT EXISTS idx_metrics_type ON metrics(metric_type);

        -- Request Logs
        CREATE TABLE IF NOT EXISTS request_logs (
                log_id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp INTEGER NOT NULL,
                route_id INTEGER,
                service_id INTEGER,
                request_id TEXT NOT NULL,
                client_ip TEXT NOT NULL,
                method TEXT NOT NULL,
                path TEXT NOT NULL,
                status_code INTEGER,
                response_time_ms INTEGER,
                bytes_sent INTEGER,
                bytes_received INTEGER,
                user_agent TEXT,
                referer TEXT,
                error_message TEXT,
                FOREIGN KEY(route_id) REFERENCES routes(route_id),
                FOREIGN KEY(service_id) REFERENCES services(service_id)
        );
        CREATE INDEX IF NOT EXISTS idx_logs_timestamp ON request_logs(timestamp);
        CREATE INDEX IF NOT EXISTS idx_logs_status ON request_logs(status_code);
        CREATE INDEX IF NOT EXISTS idx_logs_request_id ON request_logs(request_id);
        CREATE INDEX IF NOT EXISTS idx_logs_client_ip ON request_logs(client_ip);

        -- Health Checks
        CREATE TABLE IF NOT EXISTS health_checks (
                check_id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp INTEGER NOT NULL,
                service_id INTEGER NOT NULL,
                success INTEGER NOT NULL,
                response_time_ms INTEGER,
                error_message TEXT,
                FOREIGN KEY(service_id) REFERENCES services(service_id)
        );
        CREATE INDEX IF NOT EXISTS idx_health_timestamp ON health_checks(timestamp);
        CREATE INDEX IF NOT EXISTS idx_health_service ON health_checks(service_id);

        -- Certificates
        CREATE TABLE IF NOT EXISTS certificates (
                cert_id INTEGER PRIMARY KEY AUTOINCREMENT,
                domain TEXT NOT NULL UNIQUE,
                cert_path TEXT NOT NULL,
                key_path TEXT NOT NULL,
                issuer TEXT,
                subject TEXT,
                not_before INTEGER,
                not_after INTEGER,
                san_domains TEXT,
                auto_renew INTEGER DEFAULT 1,
                last_check INTEGER,
                created_at INTEGER DEFAULT (strftime('%s', 'now')),
                updated_at INTEGER DEFAULT (strftime('%s', 'now'))
        );
        CREATE INDEX IF NOT EXISTS idx_certs_domain ON certificates(domain);
        CREATE INDEX IF NOT EXISTS idx_certs_expiry ON certificates(not_after);

        -- Rate Limits
        CREATE TABLE IF NOT EXISTS rate_limits (
                ip_address TEXT NOT NULL,
                route_id INTEGER NOT NULL,
                window_start INTEGER NOT NULL,
                request_count INTEGER DEFAULT 1,
                last_request INTEGER NOT NULL,
                PRIMARY KEY (ip_address, route_id, window_start),
                FOREIGN KEY(route_id) REFERENCES routes(route_id)
        );
        CREATE INDEX IF NOT EXISTS idx_ratelimit_window ON rate_limits(window_start);

        -- Rate Limit Violations
        CREATE TABLE IF NOT EXISTS rate_limit_violations (
                violation_id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp INTEGER NOT NULL,
                ip_address TEXT NOT NULL,
                route_id INTEGER,
                request_count INTEGER,
                limit_value INTEGER,
                action TEXT
        );
        CREATE INDEX IF NOT EXISTS idx_violations_timestamp ON rate_limit_violations(timestamp);
        CREATE INDEX IF NOT EXISTS idx_violations_ip ON rate_limit_violations(ip_address);

        -- WAF Blocks
        CREATE TABLE IF NOT EXISTS waf_blocks (
                block_id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp INTEGER NOT NULL,
                ip_address TEXT NOT NULL,
                route_id INTEGER,
                attack_type TEXT NOT NULL,
                pattern_matched TEXT,
                request_path TEXT,
                request_method TEXT,
                action TEXT
        );
        CREATE INDEX IF NOT EXISTS idx_waf_timestamp ON waf_blocks(timestamp);
        CREATE INDEX IF NOT EXISTS idx_waf_ip ON waf_blocks(ip_address);
        CREATE INDEX IF NOT EXISTS idx_waf_type ON waf_blocks(attack_type);

        -- Audit Log
        CREATE TABLE IF NOT EXISTS audit_log (
                audit_id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp INTEGER NOT NULL,
                user TEXT,
                action TEXT NOT NULL,
                resource_type TEXT,
                resource_id TEXT,
                old_value TEXT,
                new_value TEXT,
                ip_address TEXT,
                notes TEXT
        );
        CREATE INDEX IF NOT EXISTS idx_audit_timestamp ON audit_log(timestamp);
        CREATE INDEX IF NOT EXISTS idx_audit_action ON audit_log(action);

        -- WebSocket Connections
        CREATE TABLE IF NOT EXISTS websocket_connections (
                conn_id INTEGER PRIMARY KEY AUTOINCREMENT,
                request_id TEXT NOT NULL,
                route_id INTEGER,
                client_ip TEXT NOT NULL,
                connected_at INTEGER NOT NULL,
                disconnected_at INTEGER,
                bytes_sent INTEGER DEFAULT 0,
                bytes_received INTEGER DEFAULT 0,
                messages_sent INTEGER DEFAULT 0,
                messages_received INTEGER DEFAULT 0,
                close_reason TEXT,
                FOREIGN KEY(route_id) REFERENCES routes(route_id)
        );
        CREATE INDEX IF NOT EXISTS idx_ws_connected ON websocket_connections(connected_at);
        CREATE INDEX IF NOT EXISTS idx_ws_active ON websocket_connections(disconnected_at) WHERE disconnected_at IS NULL;
        `

        _, err := db.Exec(schema)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute schema: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// LogRequest logs an HTTP request
func (db *DB) LogRequest(req *RequestLog) error <span class="cov0" title="0">{
        query := `
                INSERT INTO request_logs (
                        timestamp, route_id, service_id, request_id, client_ip,
                        method, path, status_code, response_time_ms,
                        bytes_sent, bytes_received, user_agent, referer, error_message
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err := db.Exec(query,
                req.Timestamp, req.RouteID, req.ServiceID, req.RequestID, req.ClientIP,
                req.Method, req.Path, req.StatusCode, req.ResponseTimeMs,
                req.BytesSent, req.BytesReceived, req.UserAgent, req.Referer, req.ErrorMessage,
        )

        return err
}</span>

// RecordMetric records a metric value
func (db *DB) RecordMetric(metric *Metric) error <span class="cov0" title="0">{
        query := `
                INSERT INTO metrics (timestamp, route_id, service_id, metric_type, value, labels)
                VALUES (?, ?, ?, ?, ?, ?)
        `

        _, err := db.Exec(query,
                metric.Timestamp, metric.RouteID, metric.ServiceID, metric.Type, metric.Value, metric.Labels,
        )

        return err
}</span>

// CleanupOldData removes data older than retention period
func (db *DB) CleanupOldData(retentionDays int) error <span class="cov0" title="0">{
        cutoff := time.Now().AddDate(0, 0, -retentionDays).Unix()

        queries := []string{
                fmt.Sprintf("DELETE FROM request_logs WHERE timestamp &lt; %d", cutoff),
                fmt.Sprintf("DELETE FROM metrics WHERE timestamp &lt; %d", cutoff),
                fmt.Sprintf("DELETE FROM health_checks WHERE timestamp &lt; %d", cutoff),
                fmt.Sprintf("DELETE FROM rate_limits WHERE window_start &lt; %d", cutoff),
                fmt.Sprintf("DELETE FROM rate_limit_violations WHERE timestamp &lt; %d", cutoff),
                fmt.Sprintf("DELETE FROM waf_blocks WHERE timestamp &lt; %d", cutoff),
        }

        for _, query := range queries </span><span class="cov0" title="0">{
                if _, err := db.Exec(query); err != nil </span><span class="cov0" title="0">{
                        log.Warn().Err(err).Str("query", query).Msg("Failed to cleanup old data")
                }</span>
        }

        // Vacuum to reclaim space
        <span class="cov0" title="0">if _, err := db.Exec("VACUUM"); err != nil </span><span class="cov0" title="0">{
                log.Warn().Err(err).Msg("Failed to vacuum database")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RequestLog represents a logged HTTP request
type RequestLog struct {
        Timestamp      int64
        RouteID        *int64
        ServiceID      *int64
        RequestID      string
        ClientIP       string
        Method         string
        Path           string
        StatusCode     int
        ResponseTimeMs int64
        BytesSent      int64
        BytesReceived  int64
        UserAgent      string
        Referer        string
        ErrorMessage   string
}

// Metric represents a collected metric
type Metric struct {
        Timestamp int64
        RouteID   *int64
        ServiceID *int64
        Type      string
        Value     float64
        Labels    string
}

// LogRateLimitViolation logs a rate limit violation to the database
func (db *DB) LogRateLimitViolation(ip, route, reason string, requestCount int) error <span class="cov0" title="0">{
        query := `
                INSERT INTO rate_limit_violations (
                        timestamp, ip_address, route, reason, 
                        request_count, metadata
                ) VALUES (?, ?, ?, ?, ?, ?)
        `

        _, err := db.Exec(
                query,
                time.Now().Unix(),
                ip,
                route,
                reason,
                requestCount,
                "", // metadata (JSON for additional info)
        )

        if err != nil </span><span class="cov0" title="0">{
                log.Error().
                        Err(err).
                        Str("ip", ip).
                        Str("route", route).
                        Str("reason", reason).
                        Msg("Failed to log rate limit violation")
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// LogWAFBlock logs a WAF block event to the database
func (db *DB) LogWAFBlock(ip, route, attackType, payload, userAgent string) error <span class="cov0" title="0">{
        query := `
                INSERT INTO waf_blocks (
                        timestamp, ip_address, route, attack_type,
                        payload, user_agent, blocked, metadata
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err := db.Exec(
                query,
                time.Now().Unix(),
                ip,
                route,
                attackType,
                payload,
                userAgent,
                1,  // blocked = true
                "", // metadata (JSON for additional info)
        )

        if err != nil </span><span class="cov0" title="0">{
                log.Error().
                        Err(err).
                        Str("ip", ip).
                        Str("route", route).
                        Str("attack_type", attackType).
                        Msg("Failed to log WAF block")
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// LogAudit logs an audit event to the database
func (db *DB) LogAudit(user, action, resourceType, resourceID, oldValue, newValue, ipAddress, metadata string) error <span class="cov0" title="0">{
        query := `
                INSERT INTO audit_log (
                        timestamp, user, action, resource_type,
                        resource_id, old_value, new_value, ip_address, metadata
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err := db.Exec(
                query,
                time.Now().Unix(),
                user,
                action,
                resourceType,
                resourceID,
                oldValue,
                newValue,
                ipAddress,
                metadata,
        )

        if err != nil </span><span class="cov0" title="0">{
                log.Error().
                        Err(err).
                        Str("action", action).
                        Str("resource_type", resourceType).
                        Msg("Failed to log audit entry")
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// AuditEntry represents an audit log entry
type AuditEntry struct {
        ID           int64  `json:"id"`
        Timestamp    int64  `json:"timestamp"`
        User         string `json:"user"`
        Action       string `json:"action"`
        ResourceType string `json:"resource_type"`
        ResourceID   string `json:"resource_id"`
        OldValue     string `json:"old_value,omitempty"`
        NewValue     string `json:"new_value,omitempty"`
        IPAddress    string `json:"ip_address,omitempty"`
        Metadata     string `json:"metadata,omitempty"`
}

// GetAuditLogs retrieves audit logs with optional filters
func (db *DB) GetAuditLogs(limit int, action, resourceType string, since time.Time) ([]AuditEntry, error) <span class="cov0" title="0">{
        query := `
                SELECT id, timestamp, user, action, resource_type,
                       resource_id, old_value, new_value, ip_address, metadata
                FROM audit_log
                WHERE 1=1
        `
        args := []interface{}{}

        if action != "" </span><span class="cov0" title="0">{
                query += " AND action = ?"
                args = append(args, action)
        }</span>

        <span class="cov0" title="0">if resourceType != "" </span><span class="cov0" title="0">{
                query += " AND resource_type = ?"
                args = append(args, resourceType)
        }</span>

        <span class="cov0" title="0">if !since.IsZero() </span><span class="cov0" title="0">{
                query += " AND timestamp &gt;= ?"
                args = append(args, since.Unix())
        }</span>

        <span class="cov0" title="0">query += " ORDER BY timestamp DESC LIMIT ?"
        args = append(args, limit)

        rows, err := db.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var entries []AuditEntry
        for rows.Next() </span><span class="cov0" title="0">{
                var entry AuditEntry
                err := rows.Scan(
                        &amp;entry.ID,
                        &amp;entry.Timestamp,
                        &amp;entry.User,
                        &amp;entry.Action,
                        &amp;entry.ResourceType,
                        &amp;entry.ResourceID,
                        &amp;entry.OldValue,
                        &amp;entry.NewValue,
                        &amp;entry.IPAddress,
                        &amp;entry.Metadata,
                )
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Err(err).Msg("Failed to scan audit entry")
                        continue</span>
                }
                <span class="cov0" title="0">entries = append(entries, entry)</span>
        }

        <span class="cov0" title="0">return entries, nil</span>
}

// CleanupAccessLogs removes old access logs based on retention policy
func (db *DB) CleanupAccessLogs(days int, routePattern string) error <span class="cov0" title="0">{
        cutoff := time.Now().AddDate(0, 0, -days).Unix()

        var query string
        var args []interface{}

        if routePattern == "*" </span><span class="cov0" title="0">{
                query = "DELETE FROM access_log WHERE timestamp &lt; ?"
                args = []interface{}{cutoff}
        }</span> else<span class="cov0" title="0"> {
                query = "DELETE FROM access_log WHERE timestamp &lt; ? AND route LIKE ?"
                args = []interface{}{cutoff, routePattern}
        }</span>

        <span class="cov0" title="0">result, err := db.Exec(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().
                        Err(err).
                        Int("days", days).
                        Str("route_pattern", routePattern).
                        Msg("Failed to cleanup access logs")
                return err
        }</span>

        <span class="cov0" title="0">rows, _ := result.RowsAffected()
        if rows &gt; 0 </span><span class="cov0" title="0">{
                log.Info().
                        Int64("rows_deleted", rows).
                        Int("days", days).
                        Str("route_pattern", routePattern).
                        Msg("Cleaned up access logs")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CleanupSecurityLogs removes old security logs (WAF blocks, rate limit violations)
func (db *DB) CleanupSecurityLogs(days int, routePattern string) error <span class="cov0" title="0">{
        cutoff := time.Now().AddDate(0, 0, -days).Unix()

        var totalRows int64

        // Cleanup WAF blocks
        var wafQuery string
        var wafArgs []interface{}

        if routePattern == "*" </span><span class="cov0" title="0">{
                wafQuery = "DELETE FROM waf_blocks WHERE timestamp &lt; ?"
                wafArgs = []interface{}{cutoff}
        }</span> else<span class="cov0" title="0"> {
                wafQuery = "DELETE FROM waf_blocks WHERE timestamp &lt; ? AND route LIKE ?"
                wafArgs = []interface{}{cutoff, routePattern}
        }</span>

        <span class="cov0" title="0">wafResult, err := db.Exec(wafQuery, wafArgs...)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().
                        Err(err).
                        Int("days", days).
                        Str("route_pattern", routePattern).
                        Msg("Failed to cleanup WAF blocks")
                return err
        }</span>

        <span class="cov0" title="0">wafRows, _ := wafResult.RowsAffected()
        totalRows += wafRows

        // Cleanup rate limit violations
        var rlQuery string
        var rlArgs []interface{}

        if routePattern == "*" </span><span class="cov0" title="0">{
                rlQuery = "DELETE FROM rate_limit_violations WHERE timestamp &lt; ?"
                rlArgs = []interface{}{cutoff}
        }</span> else<span class="cov0" title="0"> {
                rlQuery = "DELETE FROM rate_limit_violations WHERE timestamp &lt; ? AND route LIKE ?"
                rlArgs = []interface{}{cutoff, routePattern}
        }</span>

        <span class="cov0" title="0">rlResult, err := db.Exec(rlQuery, rlArgs...)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().
                        Err(err).
                        Int("days", days).
                        Str("route_pattern", routePattern).
                        Msg("Failed to cleanup rate limit violations")
                return err
        }</span>

        <span class="cov0" title="0">rlRows, _ := rlResult.RowsAffected()
        totalRows += rlRows

        if totalRows &gt; 0 </span><span class="cov0" title="0">{
                log.Info().
                        Int64("rows_deleted", totalRows).
                        Int64("waf_blocks", wafRows).
                        Int64("rate_limit_violations", rlRows).
                        Int("days", days).
                        Str("route_pattern", routePattern).
                        Msg("Cleaned up security logs")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CleanupAuditLogs removes old audit logs
func (db *DB) CleanupAuditLogs(days int) error <span class="cov0" title="0">{
        cutoff := time.Now().AddDate(0, 0, -days).Unix()

        result, err := db.Exec("DELETE FROM audit_log WHERE timestamp &lt; ?", cutoff)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().
                        Err(err).
                        Int("days", days).
                        Msg("Failed to cleanup audit logs")
                return err
        }</span>

        <span class="cov0" title="0">rows, _ := result.RowsAffected()
        if rows &gt; 0 </span><span class="cov0" title="0">{
                log.Info().
                        Int64("rows_deleted", rows).
                        Int("days", days).
                        Msg("Cleaned up audit logs")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CleanupMetrics removes old metrics data
func (db *DB) CleanupMetrics(days int, routePattern string) error <span class="cov0" title="0">{
        cutoff := time.Now().AddDate(0, 0, -days).Unix()

        var query string
        var args []interface{}

        if routePattern == "*" </span><span class="cov0" title="0">{
                query = "DELETE FROM metrics WHERE timestamp &lt; ?"
                args = []interface{}{cutoff}
        }</span> else<span class="cov0" title="0"> {
                query = "DELETE FROM metrics WHERE timestamp &lt; ? AND route LIKE ?"
                args = []interface{}{cutoff, routePattern}
        }</span>

        <span class="cov0" title="0">result, err := db.Exec(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().
                        Err(err).
                        Int("days", days).
                        Str("route_pattern", routePattern).
                        Msg("Failed to cleanup metrics")
                return err
        }</span>

        <span class="cov0" title="0">rows, _ := result.RowsAffected()
        if rows &gt; 0 </span><span class="cov0" title="0">{
                log.Info().
                        Int64("rows_deleted", rows).
                        Int("days", days).
                        Str("route_pattern", routePattern).
                        Msg("Cleaned up metrics")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CleanupHealthChecks removes old health check logs
func (db *DB) CleanupHealthChecks(days int) error <span class="cov0" title="0">{
        cutoff := time.Now().AddDate(0, 0, -days).Unix()

        result, err := db.Exec("DELETE FROM health_checks WHERE timestamp &lt; ?", cutoff)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().
                        Err(err).
                        Int("days", days).
                        Msg("Failed to cleanup health checks")
                return err
        }</span>

        <span class="cov0" title="0">rows, _ := result.RowsAffected()
        if rows &gt; 0 </span><span class="cov0" title="0">{
                log.Info().
                        Int64("rows_deleted", rows).
                        Int("days", days).
                        Msg("Cleaned up health checks")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RecordHealthCheck records a health check result
func (db *DB) RecordHealthCheck(service, url string, success bool, duration time.Duration, statusCode int, errorMsg string) error <span class="cov0" title="0">{
        query := `
                INSERT INTO health_checks (
                        timestamp, service_name, url, success, response_time_ms, status_code, error
                ) VALUES (?, ?, ?, ?, ?, ?, ?)
        `

        _, err := db.Exec(
                query,
                time.Now().Unix(),
                service,
                url,
                success,
                duration.Milliseconds(),
                statusCode,
                errorMsg,
        )

        if err != nil </span><span class="cov0" title="0">{
                log.Error().
                        Err(err).
                        Str("service", service).
                        Msg("Failed to record health check")
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetHealthCheckHistory retrieves health check history for a service
func (db *DB) GetHealthCheckHistory(service string, limit int) ([]HealthCheckResult, error) <span class="cov0" title="0">{
        query := `
                SELECT timestamp, service_name, url, success, response_time_ms, status_code, error
                FROM health_checks
                WHERE service_name = ?
                ORDER BY timestamp DESC
                LIMIT ?
        `

        rows, err := db.Query(query, service, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var results []HealthCheckResult
        for rows.Next() </span><span class="cov0" title="0">{
                var result HealthCheckResult
                var errorMsg sql.NullString

                err := rows.Scan(
                        &amp;result.Timestamp,
                        &amp;result.Service,
                        &amp;result.URL,
                        &amp;result.Success,
                        &amp;result.Duration,
                        &amp;result.StatusCode,
                        &amp;errorMsg,
                )
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Err(err).Msg("Failed to scan health check result")
                        continue</span>
                }

                <span class="cov0" title="0">if errorMsg.Valid </span><span class="cov0" title="0">{
                        result.Error = errorMsg.String
                }</span>

                <span class="cov0" title="0">results = append(results, result)</span>
        }

        <span class="cov0" title="0">return results, nil</span>
}

// LogAccessRequest logs an HTTP access request to the database
func (db *DB) LogAccessRequest(entry AccessLogEntry) error <span class="cov0" title="0">{
        query := `
        INSERT INTO access_log (
                timestamp, domain, method, path, query, status, 
                response_time_ms, backend, backend_ip, client_ip, 
                user_agent, referer, bytes_sent, bytes_received, 
                protocol, error
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err := db.Exec(query,
                entry.Timestamp,
                entry.Domain,
                entry.Method,
                entry.Path,
                entry.Query,
                entry.Status,
                entry.ResponseTimeMs,
                entry.Backend,
                entry.BackendIP,
                entry.ClientIP,
                entry.UserAgent,
                entry.Referer,
                entry.BytesSent,
                entry.BytesReceived,
                entry.Protocol,
                entry.Error,
        )

        return err
}</span>

// GetRecentRequests returns the most recent N access log entries
func (db *DB) GetRecentRequests(limit int) ([]AccessLogEntry, error) <span class="cov0" title="0">{
        query := `
        SELECT 
                timestamp, domain, method, path, query, status, 
                response_time_ms, backend, backend_ip, client_ip, 
                user_agent, referer, bytes_sent, bytes_received, 
                protocol, error
        FROM access_log
        ORDER BY timestamp DESC
        LIMIT ?
        `

        rows, err := db.Query(query, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var entries []AccessLogEntry
        for rows.Next() </span><span class="cov0" title="0">{
                var entry AccessLogEntry
                var query, backendIP, userAgent, referer, protocol, errMsg sql.NullString

                err := rows.Scan(
                        &amp;entry.Timestamp,
                        &amp;entry.Domain,
                        &amp;entry.Method,
                        &amp;entry.Path,
                        &amp;query,
                        &amp;entry.Status,
                        &amp;entry.ResponseTimeMs,
                        &amp;entry.Backend,
                        &amp;backendIP,
                        &amp;entry.ClientIP,
                        &amp;userAgent,
                        &amp;referer,
                        &amp;entry.BytesSent,
                        &amp;entry.BytesReceived,
                        &amp;protocol,
                        &amp;errMsg,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if query.Valid </span><span class="cov0" title="0">{
                        entry.Query = query.String
                }</span>
                <span class="cov0" title="0">if backendIP.Valid </span><span class="cov0" title="0">{
                        entry.BackendIP = backendIP.String
                }</span>
                <span class="cov0" title="0">if userAgent.Valid </span><span class="cov0" title="0">{
                        entry.UserAgent = userAgent.String
                }</span>
                <span class="cov0" title="0">if referer.Valid </span><span class="cov0" title="0">{
                        entry.Referer = referer.String
                }</span>
                <span class="cov0" title="0">if protocol.Valid </span><span class="cov0" title="0">{
                        entry.Protocol = protocol.String
                }</span>
                <span class="cov0" title="0">if errMsg.Valid </span><span class="cov0" title="0">{
                        entry.Error = errMsg.String
                }</span>

                <span class="cov0" title="0">entries = append(entries, entry)</span>
        }

        <span class="cov0" title="0">return entries, rows.Err()</span>
}

// GetRequestsByRoute returns access log entries for a specific route
func (db *DB) GetRequestsByRoute(route string, limit int) ([]AccessLogEntry, error) <span class="cov0" title="0">{
        query := `
        SELECT 
                timestamp, domain, method, path, query, status, 
                response_time_ms, backend, backend_ip, client_ip, 
                user_agent, referer, bytes_sent, bytes_received, 
                protocol, error
        FROM access_log
        WHERE path = ? OR domain = ?
        ORDER BY timestamp DESC
        LIMIT ?
        `

        rows, err := db.Query(query, route, route, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var entries []AccessLogEntry
        for rows.Next() </span><span class="cov0" title="0">{
                var entry AccessLogEntry
                var query, backendIP, userAgent, referer, protocol, errMsg sql.NullString

                err := rows.Scan(
                        &amp;entry.Timestamp,
                        &amp;entry.Domain,
                        &amp;entry.Method,
                        &amp;entry.Path,
                        &amp;query,
                        &amp;entry.Status,
                        &amp;entry.ResponseTimeMs,
                        &amp;entry.Backend,
                        &amp;backendIP,
                        &amp;entry.ClientIP,
                        &amp;userAgent,
                        &amp;referer,
                        &amp;entry.BytesSent,
                        &amp;entry.BytesReceived,
                        &amp;protocol,
                        &amp;errMsg,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if query.Valid </span><span class="cov0" title="0">{
                        entry.Query = query.String
                }</span>
                <span class="cov0" title="0">if backendIP.Valid </span><span class="cov0" title="0">{
                        entry.BackendIP = backendIP.String
                }</span>
                <span class="cov0" title="0">if userAgent.Valid </span><span class="cov0" title="0">{
                        entry.UserAgent = userAgent.String
                }</span>
                <span class="cov0" title="0">if referer.Valid </span><span class="cov0" title="0">{
                        entry.Referer = referer.String
                }</span>
                <span class="cov0" title="0">if protocol.Valid </span><span class="cov0" title="0">{
                        entry.Protocol = protocol.String
                }</span>
                <span class="cov0" title="0">if errMsg.Valid </span><span class="cov0" title="0">{
                        entry.Error = errMsg.String
                }</span>

                <span class="cov0" title="0">entries = append(entries, entry)</span>
        }

        <span class="cov0" title="0">return entries, rows.Err()</span>
}

// GetErrorRequests returns access log entries with status &gt;= 400
func (db *DB) GetErrorRequests(limit int) ([]AccessLogEntry, error) <span class="cov0" title="0">{
        query := `
        SELECT 
                timestamp, domain, method, path, query, status, 
                response_time_ms, backend, backend_ip, client_ip, 
                user_agent, referer, bytes_sent, bytes_received, 
                protocol, error
        FROM access_log
        WHERE status &gt;= 400
        ORDER BY timestamp DESC
        LIMIT ?
        `

        rows, err := db.Query(query, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var entries []AccessLogEntry
        for rows.Next() </span><span class="cov0" title="0">{
                var entry AccessLogEntry
                var query, backendIP, userAgent, referer, protocol, errMsg sql.NullString

                err := rows.Scan(
                        &amp;entry.Timestamp,
                        &amp;entry.Domain,
                        &amp;entry.Method,
                        &amp;entry.Path,
                        &amp;query,
                        &amp;entry.Status,
                        &amp;entry.ResponseTimeMs,
                        &amp;entry.Backend,
                        &amp;backendIP,
                        &amp;entry.ClientIP,
                        &amp;userAgent,
                        &amp;referer,
                        &amp;entry.BytesSent,
                        &amp;entry.BytesReceived,
                        &amp;protocol,
                        &amp;errMsg,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if query.Valid </span><span class="cov0" title="0">{
                        entry.Query = query.String
                }</span>
                <span class="cov0" title="0">if backendIP.Valid </span><span class="cov0" title="0">{
                        entry.BackendIP = backendIP.String
                }</span>
                <span class="cov0" title="0">if userAgent.Valid </span><span class="cov0" title="0">{
                        entry.UserAgent = userAgent.String
                }</span>
                <span class="cov0" title="0">if referer.Valid </span><span class="cov0" title="0">{
                        entry.Referer = referer.String
                }</span>
                <span class="cov0" title="0">if protocol.Valid </span><span class="cov0" title="0">{
                        entry.Protocol = protocol.String
                }</span>
                <span class="cov0" title="0">if errMsg.Valid </span><span class="cov0" title="0">{
                        entry.Error = errMsg.String
                }</span>

                <span class="cov0" title="0">entries = append(entries, entry)</span>
        }

        <span class="cov0" title="0">return entries, rows.Err()</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package health

import (
        "context"
        "fmt"
        "net/http"
        "sync"
        "time"

        "github.com/chilla55/proxy-manager/database"
        "github.com/rs/zerolog/log"
)

// Status represents service health status
type Status string

const (
        StatusHealthy  Status = "healthy"  // 90%+ success rate
        StatusDegraded Status = "degraded" // 50-90% success rate
        StatusDown     Status = "down"     // &lt;50% success rate
        StatusUnknown  Status = "unknown"  // No data yet
)

// Checker performs health checks on backend services
type Checker struct {
        services map[string]*ServiceHealth
        db       Database
        mu       sync.RWMutex
}

// Database interface for health check persistence
type Database interface {
        RecordHealthCheck(service, url string, success bool, duration time.Duration, statusCode int, error string) error
        GetHealthCheckHistory(service string, limit int) ([]database.HealthCheckResult, error)
}

// ServiceHealth tracks health for a single service
type ServiceHealth struct {
        Name           string
        URL            string
        Interval       time.Duration
        Timeout        time.Duration
        ExpectedStatus int
        SuccessCount   int
        FailureCount   int
        TotalChecks    int
        LastCheck      time.Time
        LastSuccess    time.Time
        LastFailure    time.Time
        LastError      string
        Status         Status
        ResponseTime   time.Duration
        mu             sync.RWMutex
}

// HealthCheckResult is an alias for database.HealthCheckResult
type HealthCheckResult = database.HealthCheckResult

// NewChecker creates a new health checker
func NewChecker(db Database) *Checker <span class="cov0" title="0">{
        return &amp;Checker{
                services: make(map[string]*ServiceHealth),
                db:       db,
        }
}</span>

// AddService adds a service to monitor
func (c *Checker) AddService(name, url string, interval, timeout time.Duration, expectedStatus int) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.services[name] = &amp;ServiceHealth{
                Name:           name,
                URL:            url,
                Interval:       interval,
                Timeout:        timeout,
                ExpectedStatus: expectedStatus,
                Status:         StatusUnknown,
        }

        log.Info().
                Str("service", name).
                Str("url", url).
                Dur("interval", interval).
                Msg("Added service for health monitoring")
}</span>

// Start starts health checking for all services
func (c *Checker) Start(ctx context.Context) <span class="cov0" title="0">{
        c.mu.RLock()
        services := make([]*ServiceHealth, 0, len(c.services))
        for _, svc := range c.services </span><span class="cov0" title="0">{
                services = append(services, svc)
        }</span>
        <span class="cov0" title="0">c.mu.RUnlock()

        // Start a goroutine for each service
        for _, svc := range services </span><span class="cov0" title="0">{
                go c.monitorService(ctx, svc)
        }</span>

        <span class="cov0" title="0">log.Info().
                Int("services", len(services)).
                Msg("Health checker started")</span>
}

// monitorService continuously monitors a single service
func (c *Checker) monitorService(ctx context.Context, svc *ServiceHealth) <span class="cov0" title="0">{
        // Perform initial check immediately
        c.check(svc)

        ticker := time.NewTicker(svc.Interval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        log.Info().
                                Str("service", svc.Name).
                                Msg("Stopping health checks")
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        c.check(svc)</span>
                }
        }
}

// check performs a single health check
func (c *Checker) check(svc *ServiceHealth) <span class="cov0" title="0">{
        startTime := time.Now()

        client := &amp;http.Client{
                Timeout: svc.Timeout,
                CheckRedirect: func(req *http.Request, via []*http.Request) error </span><span class="cov0" title="0">{
                        return http.ErrUseLastResponse // Don't follow redirects
                }</span>,
        }

        <span class="cov0" title="0">resp, err := client.Get(svc.URL)
        duration := time.Since(startTime)

        success := false
        statusCode := 0
        errorMsg := ""

        if err != nil </span><span class="cov0" title="0">{
                errorMsg = err.Error()
                log.Debug().
                        Str("service", svc.Name).
                        Str("url", svc.URL).
                        Err(err).
                        Msg("Health check failed")
        }</span> else<span class="cov0" title="0"> {
                defer resp.Body.Close()
                statusCode = resp.StatusCode

                // Check if status code matches expected
                if svc.ExpectedStatus == 0 || statusCode == svc.ExpectedStatus </span><span class="cov0" title="0">{
                        success = true
                }</span> else<span class="cov0" title="0"> {
                        errorMsg = fmt.Sprintf("unexpected status code: %d (expected %d)", statusCode, svc.ExpectedStatus)
                }</span>

                <span class="cov0" title="0">log.Debug().
                        Str("service", svc.Name).
                        Int("status", statusCode).
                        Dur("duration", duration).
                        Bool("success", success).
                        Msg("Health check completed")</span>
        }

        // Update service health
        <span class="cov0" title="0">svc.mu.Lock()
        svc.LastCheck = startTime
        svc.ResponseTime = duration
        svc.TotalChecks++

        if success </span><span class="cov0" title="0">{
                svc.SuccessCount++
                svc.LastSuccess = startTime
                svc.LastError = ""
        }</span> else<span class="cov0" title="0"> {
                svc.FailureCount++
                svc.LastFailure = startTime
                svc.LastError = errorMsg
        }</span>

        // Calculate status based on success rate
        <span class="cov0" title="0">svc.Status = c.calculateStatus(svc.SuccessCount, svc.TotalChecks)
        svc.mu.Unlock()

        // Log status changes
        if svc.Status == StatusDown &amp;&amp; success == false </span><span class="cov0" title="0">{
                log.Warn().
                        Str("service", svc.Name).
                        Str("status", string(svc.Status)).
                        Str("error", errorMsg).
                        Msg("Service health degraded")
        }</span> else<span class="cov0" title="0"> if svc.Status == StatusHealthy &amp;&amp; success == true &amp;&amp; svc.FailureCount &gt; 0 </span><span class="cov0" title="0">{
                log.Info().
                        Str("service", svc.Name).
                        Msg("Service recovered")
        }</span>

        // Store in database
        <span class="cov0" title="0">if c.db != nil </span><span class="cov0" title="0">{
                err := c.db.RecordHealthCheck(svc.Name, svc.URL, success, duration, statusCode, errorMsg)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().
                                Err(err).
                                Str("service", svc.Name).
                                Msg("Failed to record health check")
                }</span>
        }
}

// calculateStatus determines health status based on success rate
func (c *Checker) calculateStatus(successCount, totalChecks int) Status <span class="cov0" title="0">{
        if totalChecks == 0 </span><span class="cov0" title="0">{
                return StatusUnknown
        }</span>

        <span class="cov0" title="0">successRate := float64(successCount) / float64(totalChecks) * 100

        if successRate &gt;= 90 </span><span class="cov0" title="0">{
                return StatusHealthy
        }</span> else<span class="cov0" title="0"> if successRate &gt;= 50 </span><span class="cov0" title="0">{
                return StatusDegraded
        }</span>
        <span class="cov0" title="0">return StatusDown</span>
}

// GetStatus returns the current status of a service
func (c *Checker) GetStatus(name string) (*ServiceHealth, error) <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        svc, ok := c.services[name]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("service not found: %s", name)
        }</span>

        // Return a copy to avoid race conditions
        <span class="cov0" title="0">svc.mu.RLock()
        defer svc.mu.RUnlock()

        return &amp;ServiceHealth{
                Name:         svc.Name,
                URL:          svc.URL,
                Status:       svc.Status,
                SuccessCount: svc.SuccessCount,
                FailureCount: svc.FailureCount,
                TotalChecks:  svc.TotalChecks,
                LastCheck:    svc.LastCheck,
                LastSuccess:  svc.LastSuccess,
                LastFailure:  svc.LastFailure,
                LastError:    svc.LastError,
                ResponseTime: svc.ResponseTime,
        }, nil</span>
}

// GetAllStatuses returns status for all services
func (c *Checker) GetAllStatuses() map[string]ServiceHealthStatus <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        statuses := make(map[string]ServiceHealthStatus, len(c.services))

        for name, svc := range c.services </span><span class="cov0" title="0">{
                svc.mu.RLock()

                successRate := float64(0)
                if svc.TotalChecks &gt; 0 </span><span class="cov0" title="0">{
                        successRate = float64(svc.SuccessCount) / float64(svc.TotalChecks) * 100
                }</span>

                <span class="cov0" title="0">statuses[name] = ServiceHealthStatus{
                        Status:         string(svc.Status),
                        SuccessRate:    successRate,
                        TotalChecks:    svc.TotalChecks,
                        SuccessCount:   svc.SuccessCount,
                        FailureCount:   svc.FailureCount,
                        LastCheck:      svc.LastCheck.Unix(),
                        LastSuccess:    svc.LastSuccess.Unix(),
                        LastFailure:    svc.LastFailure.Unix(),
                        LastError:      svc.LastError,
                        ResponseTimeMs: svc.ResponseTime.Milliseconds(),
                }

                svc.mu.RUnlock()</span>
        }

        <span class="cov0" title="0">return statuses</span>
}

// ServiceHealthStatus represents JSON-serializable health status
type ServiceHealthStatus struct {
        Status         string  `json:"status"`
        SuccessRate    float64 `json:"success_rate_percent"`
        TotalChecks    int     `json:"total_checks"`
        SuccessCount   int     `json:"success_count"`
        FailureCount   int     `json:"failure_count"`
        LastCheck      int64   `json:"last_check"`
        LastSuccess    int64   `json:"last_success"`
        LastFailure    int64   `json:"last_failure"`
        LastError      string  `json:"last_error,omitempty"`
        ResponseTimeMs int64   `json:"response_time_ms"`
}

// IsHealthy returns true if all services are healthy
func (c *Checker) IsHealthy() bool <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        for _, svc := range c.services </span><span class="cov0" title="0">{
                svc.mu.RLock()
                status := svc.Status
                svc.mu.RUnlock()

                if status == StatusDown </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

// GetUnhealthyServices returns list of unhealthy services
func (c *Checker) GetUnhealthyServices() []string <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        var unhealthy []string

        for name, svc := range c.services </span><span class="cov0" title="0">{
                svc.mu.RLock()
                status := svc.Status
                svc.mu.RUnlock()

                if status == StatusDown || status == StatusDegraded </span><span class="cov0" title="0">{
                        unhealthy = append(unhealthy, name)
                }</span>
        }

        <span class="cov0" title="0">return unhealthy</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package main

import (
        "context"
        "crypto/tls"
        "flag"
        "fmt"
        "net/http"
        "os"
        "os/signal"
        "path/filepath"
        "syscall"
        "time"

        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"

        "github.com/chilla55/proxy-manager/accesslog"
        "github.com/chilla55/proxy-manager/analytics"
        "github.com/chilla55/proxy-manager/certmonitor"
        "github.com/chilla55/proxy-manager/config"
        "github.com/chilla55/proxy-manager/database"
        "github.com/chilla55/proxy-manager/health"
        "github.com/chilla55/proxy-manager/metrics"
        "github.com/chilla55/proxy-manager/proxy"
        "github.com/chilla55/proxy-manager/registry"
        "github.com/chilla55/proxy-manager/traffic"
        "github.com/chilla55/proxy-manager/watcher"
)

var (
        sitesPath       = flag.String("sites-path", getEnv("SITES_PATH", "/etc/proxy/sites-available"), "Path to site YAML configs")
        globalConfig    = flag.String("global-config", getEnv("GLOBAL_CONFIG", "/etc/proxy/global.yaml"), "Path to global config")
        httpAddr        = flag.String("http-addr", getEnv("HTTP_ADDR", ":80"), "HTTP listen address")
        httpsAddr       = flag.String("https-addr", getEnv("HTTPS_ADDR", ":443"), "HTTPS listen address")
        registryPort    = flag.Int("registry-port", getIntEnv("REGISTRY_PORT", 81), "Service registry port")
        healthPort      = flag.Int("health-port", getIntEnv("HEALTH_PORT", 8080), "Health check HTTP port")
        upstreamTimeout = flag.Duration("upstream-timeout", getDurationEnv("UPSTREAM_CHECK_TIMEOUT", 2*time.Second), "Upstream check timeout")
        shutdownTimeout = flag.Duration("shutdown-timeout", getDurationEnv("SHUTDOWN_TIMEOUT", 30*time.Second), "Graceful shutdown timeout")
        debug           = flag.Bool("debug", getEnv("DEBUG", "0") == "1", "Enable debug logging")
        dbPath          = flag.String("db-path", getEnv("DB_PATH", "/data/proxy.db"), "Path to SQLite database")
)

func main() <span class="cov0" title="0">{
        flag.Parse()

        // Setup structured logging
        setupLogging()

        log.Info().Msg("Starting unified reverse proxy service")
        log.Info().Str("sites_path", *sitesPath).Msg("Configuration")
        log.Info().Str("global_config", *globalConfig).Msg("Configuration")
        log.Info().Int("registry_port", *registryPort).Msg("Configuration")
        log.Info().Str("db_path", *dbPath).Msg("Configuration")

        // Validate configuration before starting
        if err := validateConfiguration(); err != nil </span><span class="cov0" title="0">{
                log.Fatal().Err(err).Msg("Configuration validation failed")
        }</span>

        // Validate configuration before starting
        <span class="cov0" title="0">if err := validateConfiguration(); err != nil </span><span class="cov0" title="0">{
                log.Fatal().Err(err).Msg("Configuration validation failed")
        }</span>

        // Create context for graceful shutdown
        <span class="cov0" title="0">ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        // Load global configuration
        globalCfg, err := config.LoadGlobalConfig(*globalConfig)
        if err != nil </span><span class="cov0" title="0">{
                log.Warn().Err(err).Msg("Failed to load global config, using defaults")
                globalCfg = getDefaultGlobalConfig()
        }</span>

        // Load TLS certificates
        <span class="cov0" title="0">certificates, err := loadCertificates(globalCfg)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal().Err(err).Msg("Failed to load TLS certificates")
        }</span>

        <span class="cov0" title="0">if len(certificates) == 0 </span><span class="cov0" title="0">{
                log.Fatal().Msg("No TLS certificates configured. Please add certificates to global.yaml")
        }</span>

        <span class="cov0" title="0">log.Info().Int("count", len(certificates)).Msg("Loaded TLS certificates")

        // Initialize database
        db, err := database.Open(*dbPath)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal().Err(err).Msg("Failed to open database")
        }</span>
        <span class="cov0" title="0">defer db.Close()

        // Initialize Phase 2 monitoring systems
        metricsCollector := metrics.NewCollector()
        accessLogger := accesslog.NewLogger(db, 1000) // 1000-entry ring buffer
        certMonitor := certmonitor.NewMonitor()
        healthChecker := health.NewChecker(db)
        analyticsAggregator := analytics.NewAggregator(1000, 10*time.Second) // 1000 samples, 10s period
        trafficAnalyzer := traffic.NewAnalyzer(1 * time.Hour)                // 1 hour window

        // Add certificates to certificate monitor
        for i, certMapping := range certificates </span><span class="cov0" title="0">{
                for _, domain := range certMapping.Domains </span><span class="cov0" title="0">{
                        if err := certMonitor.AddCertificateFromTLS(domain, &amp;certificates[i].Cert); err != nil </span><span class="cov0" title="0">{
                                log.Warn().Err(err).Str("domain", domain).Msg("Failed to add certificate to monitor")
                        }</span> else<span class="cov0" title="0"> {
                                log.Info().Str("domain", domain).Msg("Added certificate to monitoring")
                        }</span>
                }
        }

        // Start periodic certificate expiry checks (every 6 hours)
        <span class="cov0" title="0">certMonitor.StartPeriodicCheck(6 * time.Hour)

        // Start daily cleanup job
        go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(24 * time.Hour)
                defer ticker.Stop()

                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                log.Info().Msg("Running daily database cleanup")
                                if err := db.CleanupOldData(30); err != nil </span><span class="cov0" title="0">{
                                        log.Error().Err(err).Msg("Database cleanup failed")
                                }</span>
                        }
                }
        }()

        // Initialize proxy server
        <span class="cov0" title="0">proxyServer := proxy.NewServer(proxy.Config{
                HTTPAddr:         *httpAddr,
                HTTPSAddr:        *httpsAddr,
                Certificates:     certificates,
                GlobalHeaders:    buildSecurityHeaders(globalCfg),
                BlackholeUnknown: globalCfg.Blackhole.UnknownDomains,
                Debug:            *debug,
                DB:               db,
                MetricsCollector: metricsCollector,
                AccessLogger:     accessLogger,
                CertMonitor:      certMonitor,
                HealthChecker:    healthChecker,
        })

        // Initialize service registry
        reg := registry.NewRegistry(*registryPort, *upstreamTimeout, proxyServer, *debug)

        // Initialize site watcher
        siteWatcher := watcher.NewSiteWatcher(*sitesPath, proxyServer, *debug)

        // Initialize certificate watcher
        certWatcher := watcher.NewCertWatcher(*globalConfig, proxyServer, *debug)

        // Start health check server
        go startHealthServer(*healthPort, proxyServer, metricsCollector, accessLogger, certMonitor, healthChecker, analyticsAggregator, trafficAnalyzer)

        // Start site watcher
        go siteWatcher.Start(ctx)

        // Start certificate watcher (monitors for cert renewals)
        go func() </span><span class="cov0" title="0">{
                if err := certWatcher.Start(ctx); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[proxy-manager] Certificate watcher error: %s", err)
                }</span>
        }()

        // Start service registry
        <span class="cov0" title="0">go reg.Start(ctx)

        // Start proxy servers (HTTP, HTTPS, HTTP/3)
        go func() </span><span class="cov0" title="0">{
                if err := proxyServer.Start(ctx, *httpAddr, *httpsAddr); err != nil </span><span class="cov0" title="0">{
                        log.Error().Err(err).Msg("Proxy server error")
                }</span>
        }()

        <span class="cov0" title="0">log.Info().Msg("All services started successfully")

        // Wait for shutdown signal
        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)
        sig := &lt;-sigChan

        log.Info().Str("signal", sig.String()).Msg("Shutdown signal received")

        // Create shutdown context with timeout
        shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), *shutdownTimeout)
        defer shutdownCancel()

        // Notify all connected services
        log.Info().Msg("Notifying connected services...")
        reg.NotifyShutdown()

        // Give services time to receive shutdown notification
        time.Sleep(2 * time.Second)

        // Cancel main context to stop all goroutines
        cancel()

        // Wait for graceful shutdown or timeout
        done := make(chan struct{})
        go func() </span><span class="cov0" title="0">{
                // Wait for all background goroutines
                time.Sleep(1 * time.Second)
                close(done)
        }</span>()

        <span class="cov0" title="0">select </span>{
        case &lt;-done:<span class="cov0" title="0">
                log.Info().Msg("Shutdown complete")</span>
        case &lt;-shutdownCtx.Done():<span class="cov0" title="0">
                log.Warn().Msg("Shutdown timeout exceeded, forcing exit")</span>
        }
}

func startHealthServer(port int, proxyServer *proxy.Server, metricsCollector *metrics.Collector, accessLogger *accesslog.Logger, certMonitor *certmonitor.Monitor, healthChecker *health.Checker, analyticsAggregator *analytics.Aggregator, trafficAnalyzer *traffic.Analyzer) <span class="cov0" title="0">{
        http.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Check if proxy is responding
                // Simple check - server is running if we got here
                w.WriteHeader(http.StatusOK)
                w.Write([]byte("healthy"))
        }</span>)

        <span class="cov0" title="0">http.HandleFunc("/ready", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Simple readiness check
                w.WriteHeader(http.StatusOK)
                w.Write([]byte("ready"))
        }</span>)

        // Phase 2: Prometheus-compatible metrics endpoint (Task #2)
        <span class="cov0" title="0">http.HandleFunc("/metrics", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "text/plain; version=0.0.4")
                w.Write([]byte(metricsCollector.PrometheusMetrics()))
        }</span>)

        // Phase 2: Access log API endpoints (Task #6)
        <span class="cov0" title="0">http.HandleFunc("/api/logs/recent", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                entries := accessLogger.GetRecentRequests(100)
                fmt.Fprintf(w, "%v", entries) // TODO: proper JSON marshaling
        }</span>)

        <span class="cov0" title="0">http.HandleFunc("/api/logs/errors", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                entries := accessLogger.GetRecentErrors(50)
                fmt.Fprintf(w, "%v", entries) // TODO: proper JSON marshaling
        }</span>)

        <span class="cov0" title="0">http.HandleFunc("/api/logs/stats", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                stats := accessLogger.GetStats()
                fmt.Fprintf(w, "%v", stats) // TODO: proper JSON marshaling
        }</span>)

        // Phase 2: Certificate expiry monitoring API (Task #7)
        <span class="cov0" title="0">http.HandleFunc("/api/certs", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                certs := certMonitor.GetAllCertificates()
                fmt.Fprintf(w, "%v", certs) // TODO: proper JSON marshaling
        }</span>)

        <span class="cov0" title="0">http.HandleFunc("/api/certs/expiring", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                level := r.URL.Query().Get("level")
                if level == "" </span><span class="cov0" title="0">{
                        level = certmonitor.LevelWarning
                }</span>
                <span class="cov0" title="0">certs := certMonitor.GetExpiringCertificates(level)
                fmt.Fprintf(w, "%v", certs)</span> // TODO: proper JSON marshaling
        })

        <span class="cov0" title="0">http.HandleFunc("/api/certs/stats", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                stats := certMonitor.GetStats()
                fmt.Fprintf(w, "%v", stats) // TODO: proper JSON marshaling
        }</span>)

        // Phase 2: Health check status API (Task #5)
        <span class="cov0" title="0">http.HandleFunc("/api/health/services", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                statuses := healthChecker.GetAllStatuses()
                fmt.Fprintf(w, "%v", statuses) // TODO: proper JSON marshaling
        }</span>)

        <span class="cov0" title="0">http.HandleFunc("/api/health/unhealthy", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                unhealthy := healthChecker.GetUnhealthyServices()
                fmt.Fprintf(w, "%v", unhealthy) // TODO: proper JSON marshaling
        }</span>)

        // Phase 2 Task #3: Advanced metrics aggregation API
        <span class="cov0" title="0">http.HandleFunc("/api/analytics/metrics", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                aggregated := analyticsAggregator.GetAggregatedMetrics()
                fmt.Fprintf(w, "%v", aggregated) // TODO: proper JSON marshaling
        }</span>)

        // Phase 2 Task #4: Traffic analysis API
        <span class="cov0" title="0">http.HandleFunc("/api/traffic/analysis", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                topN := 10
                if n := r.URL.Query().Get("top"); n != "" </span><span class="cov0" title="0">{
                        if parsed, err := fmt.Sscanf(n, "%d", &amp;topN); err == nil &amp;&amp; parsed == 1 </span>{<span class="cov0" title="0">
                                // Use parsed value
                        }</span>
                }
                <span class="cov0" title="0">analysis := trafficAnalyzer.Analyze(topN)
                fmt.Fprintf(w, "%v", analysis)</span> // TODO: proper JSON marshaling
        })

        <span class="cov0" title="0">http.HandleFunc("/api/traffic/ip", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                ip := r.URL.Query().Get("ip")
                if ip == "" </span><span class="cov0" title="0">{
                        http.Error(w, "Missing ip parameter", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
                reputation := trafficAnalyzer.GetIPReputation(ip)
                fmt.Fprintf(w, `{"ip":"%s","reputation_score":%.2f}`, ip, reputation)</span>
        })

        <span class="cov0" title="0">http.HandleFunc("/api/traffic/anomalies", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                analysis := trafficAnalyzer.Analyze(10)
                fmt.Fprintf(w, "%v", analysis.AnomalousPatterns) // TODO: proper JSON marshaling
        }</span>)

        // Legacy blackhole metrics
        <span class="cov0" title="0">http.HandleFunc("/api/blackhole", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                blackholeCount := proxyServer.GetBlackholeCount()
                fmt.Fprintf(w, "# HELP blackhole_requests_total Total number of blackholed requests\n")
                fmt.Fprintf(w, "# TYPE blackhole_requests_total counter\n")
                fmt.Fprintf(w, "blackhole_requests_total %d\n", blackholeCount)
        }</span>)

        <span class="cov0" title="0">addr := fmt.Sprintf(":%d", port)
        log.Info().Str("addr", addr).Msg("Health check server starting")
        if err := http.ListenAndServe(addr, nil); err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Msg("Health server error")
        }</span>
}

// setupLogging configures zerolog based on environment
func setupLogging() <span class="cov0" title="0">{
        // Set log level from environment
        logLevel := getEnv("LOG_LEVEL", "info")
        switch logLevel </span>{
        case "debug":<span class="cov0" title="0">
                zerolog.SetGlobalLevel(zerolog.DebugLevel)</span>
        case "info":<span class="cov0" title="0">
                zerolog.SetGlobalLevel(zerolog.InfoLevel)</span>
        case "warn":<span class="cov0" title="0">
                zerolog.SetGlobalLevel(zerolog.WarnLevel)</span>
        case "error":<span class="cov0" title="0">
                zerolog.SetGlobalLevel(zerolog.ErrorLevel)</span>
        default:<span class="cov0" title="0">
                zerolog.SetGlobalLevel(zerolog.InfoLevel)</span>
        }

        // Set log format from environment
        <span class="cov0" title="0">logFormat := getEnv("LOG_FORMAT", "json")
        if logFormat == "console" </span><span class="cov0" title="0">{
                log.Logger = log.Output(zerolog.ConsoleWriter{Out: os.Stderr, TimeFormat: time.RFC3339})
        }</span>

        // Add caller information in debug mode
        <span class="cov0" title="0">if logLevel == "debug" </span><span class="cov0" title="0">{
                log.Logger = log.With().Caller().Logger()
        }</span>
}

// validateConfiguration checks that all required directories and files exist
func validateConfiguration() error <span class="cov0" title="0">{
        log.Info().Msg("Validating configuration...")

        // Check required directories exist
        dirs := []string{*sitesPath}
        for _, dir := range dirs </span><span class="cov0" title="0">{
                if _, err := os.Stat(dir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("directory does not exist: %s", dir)
                }</span>
        }

        // Check global config file exists
        <span class="cov0" title="0">if _, err := os.Stat(*globalConfig); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("global config file does not exist: %s", *globalConfig)
        }</span>

        // Ensure database directory exists
        <span class="cov0" title="0">dbDir := filepath.Dir(*dbPath)
        if err := os.MkdirAll(dbDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create database directory: %w", err)
        }</span>

        // Validate ports are not the same
        <span class="cov0" title="0">if *httpAddr == *httpsAddr </span><span class="cov0" title="0">{
                return fmt.Errorf("HTTP and HTTPS addresses cannot be the same")
        }</span>

        // Check shutdown timeout is reasonable
        <span class="cov0" title="0">if *shutdownTimeout &lt; 1*time.Second || *shutdownTimeout &gt; 5*time.Minute </span><span class="cov0" title="0">{
                return fmt.Errorf("shutdown timeout must be between 1s and 5m, got %v", *shutdownTimeout)
        }</span>

        <span class="cov0" title="0">log.Info().Msg("Configuration validation passed")
        return nil</span>
}

func buildSecurityHeaders(cfg *config.GlobalConfig) proxy.SecurityHeaders <span class="cov0" title="0">{
        headers := proxy.SecurityHeaders{}

        if cfg.Defaults.Headers != nil </span><span class="cov0" title="0">{
                headers.HSTS = cfg.Defaults.Headers["Strict-Transport-Security"]
                headers.XFrameOptions = cfg.Defaults.Headers["X-Frame-Options"]
                headers.XContentType = cfg.Defaults.Headers["X-Content-Type-Options"]
                headers.XSSProtection = cfg.Defaults.Headers["X-XSS-Protection"]
                headers.CSP = cfg.Defaults.Headers["Content-Security-Policy"]
                headers.ReferrerPolicy = cfg.Defaults.Headers["Referrer-Policy"]
                headers.PermissionsPolicy = cfg.Defaults.Headers["Permissions-Policy"]
        }</span>

        <span class="cov0" title="0">return headers</span>
}

// loadCertificates loads TLS certificates from global config
func loadCertificates(cfg *config.GlobalConfig) ([]proxy.CertMapping, error) <span class="cov0" title="0">{
        if len(cfg.TLS.Certificates) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no certificates defined in global config")
        }</span>

        <span class="cov0" title="0">certificates := make([]proxy.CertMapping, 0, len(cfg.TLS.Certificates))

        for i, certCfg := range cfg.TLS.Certificates </span><span class="cov0" title="0">{
                // Load certificate and private key
                cert, err := tls.LoadX509KeyPair(certCfg.CertFile, certCfg.KeyFile)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to load certificate %d (%s): %w", i+1, certCfg.CertFile, err)
                }</span>

                <span class="cov0" title="0">if len(certCfg.Domains) == 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("certificate %d has no domains defined", i+1)
                }</span>

                <span class="cov0" title="0">mapping := proxy.CertMapping{
                        Domains: certCfg.Domains,
                        Cert:    cert,
                }

                certificates = append(certificates, mapping)
                log.Info().Strs("domains", certCfg.Domains).Msg("Loaded certificate")</span>
        }

        <span class="cov0" title="0">return certificates, nil</span>
}

func getDefaultGlobalConfig() *config.GlobalConfig <span class="cov0" title="0">{
        cfg := &amp;config.GlobalConfig{}

        // Set sensible defaults
        cfg.Defaults.Headers = map[string]string{
                "Strict-Transport-Security": "max-age=31536000; includeSubDomains",
                "X-Frame-Options":           "DENY",
                "X-Content-Type-Options":    "nosniff",
                "X-XSS-Protection":          "1; mode=block",
                "Referrer-Policy":           "strict-origin-when-cross-origin",
        }

        cfg.Blackhole.UnknownDomains = true
        cfg.Blackhole.MetricsOnly = true

        // No default TLS config - certificates must be explicitly provided
        cfg.TLS.Certificates = []config.CertConfig{}

        return cfg
}</span>

func getEnv(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

func getIntEnv(key string, defaultValue int) int <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                var intVal int
                if _, err := fmt.Sscanf(value, "%d", &amp;intVal); err == nil </span><span class="cov0" title="0">{
                        return intVal
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

func getDurationEnv(key string, defaultValue time.Duration) time.Duration <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if duration, err := time.ParseDuration(value); err == nil </span><span class="cov0" title="0">{
                        return duration
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package metrics

import (
        "sync"
        "sync/atomic"
        "time"

        "github.com/rs/zerolog/log"
)

// Collector collects and exposes Prometheus-compatible metrics
type Collector struct {
        // Request counters
        totalRequests    uint64
        totalErrors      uint64
        requestsByStatus map[int]*uint64
        requestsByRoute  map[string]*RouteMetrics

        // Timing histograms
        requestDurations *Histogram

        // Bandwidth
        totalBytesSent     uint64
        totalBytesReceived uint64

        // Active connections
        activeConnections int64

        // Rate limiting
        rateLimitViolations uint64

        // WAF
        wafBlocks uint64

        // Start time
        startTime time.Time

        // Mutex for maps
        mu sync.RWMutex
}

// RouteMetrics tracks metrics for a specific route
type RouteMetrics struct {
        Requests      uint64
        Errors        uint64
        BytesSent     uint64
        BytesReceived uint64
        TotalDuration uint64 // nanoseconds
        ResponseTimes *Histogram
}

// Histogram tracks request duration distribution
type Histogram struct {
        buckets map[string]*uint64 // "0.1", "0.5", "1.0", "5.0", "10.0", "+Inf"
        sum     uint64
        count   uint64
        mu      sync.RWMutex
}

// NewCollector creates a new metrics collector
func NewCollector() *Collector <span class="cov2" title="2">{
        c := &amp;Collector{
                requestsByStatus: make(map[int]*uint64),
                requestsByRoute:  make(map[string]*RouteMetrics),
                requestDurations: NewHistogram(),
                startTime:        time.Now(),
        }

        // Initialize common status codes
        for _, status := range []int{200, 201, 204, 301, 302, 304, 400, 401, 403, 404, 429, 500, 502, 503, 504} </span><span class="cov8" title="30">{
                count := uint64(0)
                c.requestsByStatus[status] = &amp;count
        }</span>

        <span class="cov2" title="2">return c</span>
}

// NewHistogram creates a new histogram
func NewHistogram() *Histogram <span class="cov4" title="4">{
        h := &amp;Histogram{
                buckets: make(map[string]*uint64),
        }

        // Initialize buckets (seconds)
        for _, bucket := range []string{"0.1", "0.5", "1.0", "5.0", "10.0", "+Inf"} </span><span class="cov8" title="24">{
                count := uint64(0)
                h.buckets[bucket] = &amp;count
        }</span>

        <span class="cov4" title="4">return h</span>
}

// RecordRequest records a completed request
func (c *Collector) RecordRequest(route, method string, status int, duration time.Duration, bytesSent, bytesReceived uint64) <span class="cov3" title="3">{
        // Total counters
        atomic.AddUint64(&amp;c.totalRequests, 1)
        if status &gt;= 400 </span><span class="cov1" title="1">{
                atomic.AddUint64(&amp;c.totalErrors, 1)
        }</span>

        // Bandwidth
        <span class="cov3" title="3">atomic.AddUint64(&amp;c.totalBytesSent, bytesSent)
        atomic.AddUint64(&amp;c.totalBytesReceived, bytesReceived)

        // Status code counter
        c.mu.RLock()
        if counter, ok := c.requestsByStatus[status]; ok </span><span class="cov3" title="3">{
                atomic.AddUint64(counter, 1)
        }</span> else<span class="cov0" title="0"> {
                c.mu.RUnlock()
                c.mu.Lock()
                count := uint64(1)
                c.requestsByStatus[status] = &amp;count
                c.mu.Unlock()
                c.mu.RLock()
        }</span>
        <span class="cov3" title="3">c.mu.RUnlock()

        // Route metrics
        c.mu.Lock()
        routeKey := route + ":" + method
        rm, ok := c.requestsByRoute[routeKey]
        if !ok </span><span class="cov2" title="2">{
                rm = &amp;RouteMetrics{
                        ResponseTimes: NewHistogram(),
                }
                c.requestsByRoute[routeKey] = rm
        }</span>
        <span class="cov3" title="3">c.mu.Unlock()

        atomic.AddUint64(&amp;rm.Requests, 1)
        if status &gt;= 400 </span><span class="cov1" title="1">{
                atomic.AddUint64(&amp;rm.Errors, 1)
        }</span>
        <span class="cov3" title="3">atomic.AddUint64(&amp;rm.BytesSent, bytesSent)
        atomic.AddUint64(&amp;rm.BytesReceived, bytesReceived)
        atomic.AddUint64(&amp;rm.TotalDuration, uint64(duration.Nanoseconds()))

        // Record duration in histograms
        c.requestDurations.Observe(duration)
        rm.ResponseTimes.Observe(duration)</span>
}

// Observe adds a duration observation to the histogram
func (h *Histogram) Observe(duration time.Duration) <span class="cov5" title="6">{
        seconds := duration.Seconds()

        h.mu.Lock()
        defer h.mu.Unlock()

        atomic.AddUint64(&amp;h.sum, uint64(duration.Nanoseconds()))
        atomic.AddUint64(&amp;h.count, 1)

        // Update buckets
        for bucket, counter := range h.buckets </span><span class="cov9" title="36">{
                if bucket == "+Inf" </span><span class="cov5" title="6">{
                        atomic.AddUint64(counter, 1)
                        continue</span>
                }

                <span class="cov8" title="30">var threshold float64
                switch bucket </span>{
                case "0.1":<span class="cov5" title="6">
                        threshold = 0.1</span>
                case "0.5":<span class="cov5" title="6">
                        threshold = 0.5</span>
                case "1.0":<span class="cov5" title="6">
                        threshold = 1.0</span>
                case "5.0":<span class="cov5" title="6">
                        threshold = 5.0</span>
                case "10.0":<span class="cov5" title="6">
                        threshold = 10.0</span>
                }

                <span class="cov8" title="30">if seconds &lt;= threshold </span><span class="cov8" title="22">{
                        atomic.AddUint64(counter, 1)
                }</span>
        }
}

// IncrementActiveConnections increments the active connection counter
func (c *Collector) IncrementActiveConnections() <span class="cov0" title="0">{
        atomic.AddInt64(&amp;c.activeConnections, 1)
}</span>

// DecrementActiveConnections decrements the active connection counter
func (c *Collector) DecrementActiveConnections() <span class="cov0" title="0">{
        atomic.AddInt64(&amp;c.activeConnections, -1)
}</span>

// RecordRateLimitViolation records a rate limit violation
func (c *Collector) RecordRateLimitViolation() <span class="cov0" title="0">{
        atomic.AddUint64(&amp;c.rateLimitViolations, 1)
}</span>

// RecordWAFBlock records a WAF block
func (c *Collector) RecordWAFBlock() <span class="cov0" title="0">{
        atomic.AddUint64(&amp;c.wafBlocks, 1)
}</span>

// GetStats returns current statistics
func (c *Collector) GetStats() Stats <span class="cov2" title="2">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        stats := Stats{
                Uptime:              time.Since(c.startTime).Seconds(),
                TotalRequests:       atomic.LoadUint64(&amp;c.totalRequests),
                TotalErrors:         atomic.LoadUint64(&amp;c.totalErrors),
                TotalBytesSent:      atomic.LoadUint64(&amp;c.totalBytesSent),
                TotalBytesReceived:  atomic.LoadUint64(&amp;c.totalBytesReceived),
                ActiveConnections:   atomic.LoadInt64(&amp;c.activeConnections),
                RateLimitViolations: atomic.LoadUint64(&amp;c.rateLimitViolations),
                WAFBlocks:           atomic.LoadUint64(&amp;c.wafBlocks),
                RequestsByStatus:    make(map[int]uint64),
                RouteMetrics:        make(map[string]RouteStats),
        }

        // Copy status code counters
        for status, counter := range c.requestsByStatus </span><span class="cov8" title="30">{
                stats.RequestsByStatus[status] = atomic.LoadUint64(counter)
        }</span>

        // Copy route metrics
        <span class="cov2" title="2">for route, rm := range c.requestsByRoute </span><span class="cov2" title="2">{
                avgDuration := float64(0)
                if rm.Requests &gt; 0 </span><span class="cov2" title="2">{
                        avgDuration = float64(atomic.LoadUint64(&amp;rm.TotalDuration)) / float64(atomic.LoadUint64(&amp;rm.Requests)) / 1e9 // Convert to seconds
                }</span>

                <span class="cov2" title="2">stats.RouteMetrics[route] = RouteStats{
                        Requests:        atomic.LoadUint64(&amp;rm.Requests),
                        Errors:          atomic.LoadUint64(&amp;rm.Errors),
                        BytesSent:       atomic.LoadUint64(&amp;rm.BytesSent),
                        BytesReceived:   atomic.LoadUint64(&amp;rm.BytesReceived),
                        AverageDuration: avgDuration,
                }</span>
        }

        // Calculate error rate
        <span class="cov2" title="2">if stats.TotalRequests &gt; 0 </span><span class="cov2" title="2">{
                stats.ErrorRate = float64(stats.TotalErrors) / float64(stats.TotalRequests) * 100
        }</span>

        <span class="cov2" title="2">return stats</span>
}

// Stats represents current metrics statistics
type Stats struct {
        Uptime              float64               `json:"uptime_seconds"`
        TotalRequests       uint64                `json:"total_requests"`
        TotalErrors         uint64                `json:"total_errors"`
        ErrorRate           float64               `json:"error_rate_percent"`
        TotalBytesSent      uint64                `json:"total_bytes_sent"`
        TotalBytesReceived  uint64                `json:"total_bytes_received"`
        ActiveConnections   int64                 `json:"active_connections"`
        RateLimitViolations uint64                `json:"rate_limit_violations"`
        WAFBlocks           uint64                `json:"waf_blocks"`
        RequestsByStatus    map[int]uint64        `json:"requests_by_status"`
        RouteMetrics        map[string]RouteStats `json:"route_metrics"`
}

// RouteStats represents metrics for a specific route
type RouteStats struct {
        Requests        uint64  `json:"requests"`
        Errors          uint64  `json:"errors"`
        BytesSent       uint64  `json:"bytes_sent"`
        BytesReceived   uint64  `json:"bytes_received"`
        AverageDuration float64 `json:"average_duration_seconds"`
}

// PrometheusMetrics returns metrics in Prometheus exposition format
func (c *Collector) PrometheusMetrics() string <span class="cov1" title="1">{
        stats := c.GetStats()
        var out string

        // uptime
        out += "# HELP proxy_uptime_seconds Proxy uptime in seconds\n"
        out += "# TYPE proxy_uptime_seconds gauge\n"
        out += formatMetric("proxy_uptime_seconds", stats.Uptime)

        // total requests
        out += "# HELP proxy_requests_total Total number of HTTP requests\n"
        out += "# TYPE proxy_requests_total counter\n"
        out += formatMetric("proxy_requests_total", stats.TotalRequests)

        // total errors
        out += "# HELP proxy_errors_total Total number of HTTP errors\n"
        out += "# TYPE proxy_errors_total counter\n"
        out += formatMetric("proxy_errors_total", stats.TotalErrors)

        // error rate
        out += "# HELP proxy_error_rate_percent Current error rate percentage\n"
        out += "# TYPE proxy_error_rate_percent gauge\n"
        out += formatMetric("proxy_error_rate_percent", stats.ErrorRate)

        // bandwidth
        out += "# HELP proxy_bytes_sent_total Total bytes sent to clients\n"
        out += "# TYPE proxy_bytes_sent_total counter\n"
        out += formatMetric("proxy_bytes_sent_total", stats.TotalBytesSent)

        out += "# HELP proxy_bytes_received_total Total bytes received from clients\n"
        out += "# TYPE proxy_bytes_received_total counter\n"
        out += formatMetric("proxy_bytes_received_total", stats.TotalBytesReceived)

        // active connections
        out += "# HELP proxy_active_connections Current number of active connections\n"
        out += "# TYPE proxy_active_connections gauge\n"
        out += formatMetric("proxy_active_connections", stats.ActiveConnections)

        // rate limiting
        out += "# HELP proxy_rate_limit_violations_total Total rate limit violations\n"
        out += "# TYPE proxy_rate_limit_violations_total counter\n"
        out += formatMetric("proxy_rate_limit_violations_total", stats.RateLimitViolations)

        // WAF
        out += "# HELP proxy_waf_blocks_total Total WAF blocks\n"
        out += "# TYPE proxy_waf_blocks_total counter\n"
        out += formatMetric("proxy_waf_blocks_total", stats.WAFBlocks)

        // requests by status code
        out += "# HELP proxy_requests_by_status_total Total requests by HTTP status code\n"
        out += "# TYPE proxy_requests_by_status_total counter\n"
        for status, count := range stats.RequestsByStatus </span><span class="cov7" title="15">{
                out += formatMetricWithLabel("proxy_requests_by_status_total", count, "status", status)
        }</span>

        // route metrics
        <span class="cov1" title="1">out += "# HELP proxy_route_requests_total Total requests per route\n"
        out += "# TYPE proxy_route_requests_total counter\n"
        for route, rm := range stats.RouteMetrics </span><span class="cov1" title="1">{
                out += formatMetricWithLabel("proxy_route_requests_total", rm.Requests, "route", route)
        }</span>

        <span class="cov1" title="1">out += "# HELP proxy_route_errors_total Total errors per route\n"
        out += "# TYPE proxy_route_errors_total counter\n"
        for route, rm := range stats.RouteMetrics </span><span class="cov1" title="1">{
                out += formatMetricWithLabel("proxy_route_errors_total", rm.Errors, "route", route)
        }</span>

        <span class="cov1" title="1">out += "# HELP proxy_route_duration_average_seconds Average request duration per route\n"
        out += "# TYPE proxy_route_duration_average_seconds gauge\n"
        for route, rm := range stats.RouteMetrics </span><span class="cov1" title="1">{
                out += formatMetricWithLabel("proxy_route_duration_average_seconds", rm.AverageDuration, "route", route)
        }</span>

        <span class="cov1" title="1">return out</span>
}

// Helper functions for formatting Prometheus metrics
func formatMetric(name string, value interface{}) string <span class="cov6" title="9">{
        return name + " " + toString(value) + "\n"
}</span>

func formatMetricWithLabel(name string, value interface{}, labelName string, labelValue interface{}) string <span class="cov7" title="18">{
        return name + "{" + labelName + "=\"" + toString(labelValue) + "\"} " + toString(value) + "\n"
}</span>

func toString(value interface{}) string <span class="cov9" title="45">{
        switch v := value.(type) </span>{
        case int:<span class="cov7" title="15">
                return formatInt(int64(v))</span>
        case int64:<span class="cov1" title="1">
                return formatInt(v)</span>
        case uint64:<span class="cov8" title="23">
                return formatUint(v)</span>
        case float64:<span class="cov3" title="3">
                return formatFloat(v)</span>
        case string:<span class="cov3" title="3">
                return v</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}

func formatInt(value int64) string <span class="cov7" title="16">{
        return formatFloat(float64(value))
}</span>

func formatUint(value uint64) string <span class="cov8" title="23">{
        return formatFloat(float64(value))
}</span>

func formatFloat(value float64) string <span class="cov9" title="42">{
        // Prometheus requires specific formatting
        if value == 0 </span><span class="cov8" title="22">{
                return "0"
        }</span>
        <span class="cov7" title="20">return formatFloatString(value)</span>
}

func formatFloatString(value float64) string <span class="cov7" title="20">{
        s := ""
        if value &lt; 0 </span><span class="cov0" title="0">{
                s = "-"
                value = -value
        }</span>

        // Simple float to string conversion for Prometheus
        <span class="cov7" title="20">if value == float64(int64(value)) </span><span class="cov7" title="18">{
                s += formatIntString(int64(value))
        }</span> else<span class="cov2" title="2"> {
                s += formatFloatPrecision(value, 6)
        }</span>

        <span class="cov7" title="20">return s</span>
}

func formatIntString(value int64) string <span class="cov7" title="20">{
        if value == 0 </span><span class="cov2" title="2">{
                return "0"
        }</span>

        <span class="cov7" title="18">var result []byte
        neg := value &lt; 0
        if neg </span><span class="cov0" title="0">{
                value = -value
        }</span>

        <span class="cov7" title="18">for value &gt; 0 </span><span class="cov10" title="48">{
                result = append([]byte{byte('0' + value%10)}, result...)
                value /= 10
        }</span>

        <span class="cov7" title="18">if neg </span><span class="cov0" title="0">{
                result = append([]byte{'-'}, result...)
        }</span>

        <span class="cov7" title="18">return string(result)</span>
}

func formatFloatPrecision(value float64, precision int) string <span class="cov2" title="2">{
        // Simple float formatting without using fmt
        intPart := int64(value)
        fracPart := value - float64(intPart)

        result := formatIntString(intPart) + "."

        for i := 0; i &lt; precision; i++ </span><span class="cov6" title="12">{
                fracPart *= 10
                digit := int(fracPart)
                result += string(byte('0' + digit))
                fracPart -= float64(digit)
        }</span>

        <span class="cov2" title="2">return result</span>
}

// LogStats logs current statistics
func (c *Collector) LogStats() <span class="cov0" title="0">{
        stats := c.GetStats()

        log.Info().
                Float64("uptime_hours", stats.Uptime/3600).
                Uint64("total_requests", stats.TotalRequests).
                Uint64("total_errors", stats.TotalErrors).
                Float64("error_rate", stats.ErrorRate).
                Int64("active_connections", stats.ActiveConnections).
                Msg("Metrics summary")
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package middleware

import (
        "context"
        "fmt"
        "io"
        "net/http"
        "time"

        "github.com/google/uuid"
        "github.com/rs/zerolog/log"
)

// TimeoutConfig holds timeout settings
type TimeoutConfig struct {
        Connect time.Duration
        Read    time.Duration
        Write   time.Duration
        Idle    time.Duration
}

// LimitConfig holds size limit settings
type LimitConfig struct {
        MaxRequestBody  int64
        MaxResponseBody int64
}

// RequestID middleware adds a unique request ID to each request
func RequestID(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                requestID := r.Header.Get("X-Request-ID")
                if requestID == "" </span><span class="cov0" title="0">{
                        requestID = uuid.New().String()
                }</span>

                // Add to request context
                <span class="cov0" title="0">ctx := context.WithValue(r.Context(), "request_id", requestID)
                r = r.WithContext(ctx)

                // Add to response headers
                w.Header().Set("X-Request-ID", requestID)

                next.ServeHTTP(w, r)</span>
        })
}

// Timeout middleware enforces request timeout
func Timeout(timeout time.Duration) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        ctx, cancel := context.WithTimeout(r.Context(), timeout)
                        defer cancel()

                        r = r.WithContext(ctx)

                        done := make(chan struct{})
                        go func() </span><span class="cov0" title="0">{
                                next.ServeHTTP(w, r)
                                close(done)
                        }</span>()

                        <span class="cov0" title="0">select </span>{
                        case &lt;-done:<span class="cov0" title="0"></span>
                                // Request completed
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                // Timeout occurred
                                if ctx.Err() == context.DeadlineExceeded </span><span class="cov0" title="0">{
                                        http.Error(w, "504 Gateway Timeout", http.StatusGatewayTimeout)
                                        log.Warn().
                                                Str("request_id", getRequestID(r)).
                                                Str("path", r.URL.Path).
                                                Msg("Request timeout")
                                }</span>
                        }
                })
        }
}

// LimitRequestBody enforces maximum request body size
func LimitRequestBody(maxSize int64) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        if r.ContentLength &gt; maxSize </span><span class="cov0" title="0">{
                                http.Error(w, "413 Payload Too Large", http.StatusRequestEntityTooLarge)
                                log.Warn().
                                        Str("request_id", getRequestID(r)).
                                        Int64("content_length", r.ContentLength).
                                        Int64("max_size", maxSize).
                                        Msg("Request body too large")
                                return
                        }</span>

                        // Wrap body reader with limit
                        <span class="cov0" title="0">r.Body = http.MaxBytesReader(w, r.Body, maxSize)

                        next.ServeHTTP(w, r)</span>
                })
        }
}

// LimitResponseBody wraps the response writer to limit response size
type limitedResponseWriter struct {
        http.ResponseWriter
        writer   io.Writer
        maxSize  int64
        written  int64
        exceeded bool
}

func (lrw *limitedResponseWriter) Write(b []byte) (int, error) <span class="cov0" title="0">{
        if lrw.exceeded </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("response size limit exceeded")
        }</span>

        <span class="cov0" title="0">if lrw.written+int64(len(b)) &gt; lrw.maxSize </span><span class="cov0" title="0">{
                lrw.exceeded = true
                lrw.ResponseWriter.WriteHeader(http.StatusInsufficientStorage)
                return 0, fmt.Errorf("response size limit exceeded")
        }</span>

        <span class="cov0" title="0">n, err := lrw.ResponseWriter.Write(b)
        lrw.written += int64(n)
        return n, err</span>
}

// LimitResponseBodySize enforces maximum response body size
func LimitResponseBodySize(maxSize int64) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        lrw := &amp;limitedResponseWriter{
                                ResponseWriter: w,
                                maxSize:        maxSize,
                        }

                        next.ServeHTTP(lrw, r)

                        if lrw.exceeded </span><span class="cov0" title="0">{
                                log.Warn().
                                        Str("request_id", getRequestID(r)).
                                        Int64("written", lrw.written).
                                        Int64("max_size", maxSize).
                                        Msg("Response body too large")
                        }</span>
                })
        }
}

// Logger middleware logs all requests
func Logger(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                start := time.Now()

                // Wrap response writer to capture status code
                wrapped := &amp;responseWriter{ResponseWriter: w, statusCode: http.StatusOK}

                next.ServeHTTP(wrapped, r)

                duration := time.Since(start)

                log.Info().
                        Str("request_id", getRequestID(r)).
                        Str("method", r.Method).
                        Str("path", r.URL.Path).
                        Str("remote_addr", r.RemoteAddr).
                        Int("status", wrapped.statusCode).
                        Dur("duration", duration).
                        Int64("bytes", wrapped.bytesWritten).
                        Msg("Request completed")
        }</span>)
}

type responseWriter struct {
        http.ResponseWriter
        statusCode   int
        bytesWritten int64
}

func (rw *responseWriter) WriteHeader(code int) <span class="cov0" title="0">{
        rw.statusCode = code
        rw.ResponseWriter.WriteHeader(code)
}</span>

func (rw *responseWriter) Write(b []byte) (int, error) <span class="cov0" title="0">{
        n, err := rw.ResponseWriter.Write(b)
        rw.bytesWritten += int64(n)
        return n, err
}</span>

// SecurityHeaders middleware adds security headers
func SecurityHeaders(headers map[string]string) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        for key, value := range headers </span><span class="cov0" title="0">{
                                w.Header().Set(key, value)
                        }</span>
                        <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
                })
        }
}

// getRequestID retrieves the request ID from context
func getRequestID(r *http.Request) string <span class="cov0" title="0">{
        if id, ok := r.Context().Value("request_id").(string); ok </span><span class="cov0" title="0">{
                return id
        }</span>
        <span class="cov0" title="0">return "unknown"</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package nginx

import (
        "log"
        "os/exec"
        "sync"
        "time"
)

// Controller manages nginx reload operations and batches multiple reload requests
type Controller struct {
        mu            sync.Mutex
        pendingReload bool
        reloadTimer   *time.Timer
        batchWindow   time.Duration
        debug         bool
}

func NewController(debug bool) *Controller <span class="cov0" title="0">{
        return &amp;Controller{
                batchWindow: 5 * time.Second,
                debug:       debug,
        }
}</span>

// ScheduleReload schedules a nginx reload, batching requests within the batch window
func (c *Controller) ScheduleReload(reason string) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if c.debug </span><span class="cov0" title="0">{
                log.Printf("[nginx] Reload scheduled: %s", reason)
        }</span>

        <span class="cov0" title="0">if c.pendingReload </span><span class="cov0" title="0">{
                if c.debug </span><span class="cov0" title="0">{
                        log.Printf("[nginx] Reload already pending, batching this request")
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">c.pendingReload = true
        c.reloadTimer = time.AfterFunc(c.batchWindow, func() </span><span class="cov0" title="0">{
                c.executeReload(reason)
                c.mu.Lock()
                c.pendingReload = false
                c.mu.Unlock()
        }</span>)
}

// ReloadNow performs an immediate reload without batching
func (c *Controller) ReloadNow(reason string) error <span class="cov0" title="0">{
        c.mu.Lock()
        if c.reloadTimer != nil </span><span class="cov0" title="0">{
                c.reloadTimer.Stop()
        }</span>
        <span class="cov0" title="0">c.pendingReload = false
        c.mu.Unlock()

        return c.executeReload(reason)</span>
}

func (c *Controller) executeReload(reason string) error <span class="cov0" title="0">{
        log.Printf("[nginx] Reloading nginx: %s", reason)

        // Test configuration first
        cmd := exec.Command("nginx", "-t")
        if output, err := cmd.CombinedOutput(); err != nil </span><span class="cov0" title="0">{
                log.Printf("[nginx] Configuration test failed: %s\n%s", err, output)
                return err
        }</span>

        // Reload nginx
        <span class="cov0" title="0">cmd = exec.Command("nginx", "-s", "reload")
        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                // Try HUP signal as fallback
                cmd = exec.Command("kill", "-HUP", "1")
                if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[nginx] Reload failed: %s", err)
                        return err
                }</span>
        }

        <span class="cov0" title="0">log.Printf("[nginx] Reload successful: %s", reason)
        return nil</span>
}

// TestConfig tests the nginx configuration without reloading
func (c *Controller) TestConfig() error <span class="cov0" title="0">{
        cmd := exec.Command("nginx", "-t")
        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                if c.debug </span><span class="cov0" title="0">{
                        log.Printf("[nginx] Config test failed: %s\n%s", err, output)
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package pii

import (
        "net"
        "net/http"
        "net/url"
        "regexp"
        "strings"

        "github.com/rs/zerolog"
)

// Config holds PII masking configuration
type Config struct {
        Enabled           bool
        MaskIPMethod      string   // "last_octet", "hash", "full"
        MaskIPv6Method    string   // "last_64", "hash", "full"
        StripHeaders      []string // Headers to remove from logs
        MaskQueryParams   []string // Query params to mask
        MaskFormFields    []string // Form fields to mask
        PreserveLocalhost bool     // Don't mask localhost/private IPs
}

// Masker handles PII masking operations
type Masker struct {
        config           Config
        stripHeaders     map[string]bool
        maskQueryParams  map[string]bool
        maskFormFields   map[string]bool
        sensitivePattern *regexp.Regexp
}

// NewMasker creates a new PII masker
func NewMasker(config Config) *Masker <span class="cov0" title="0">{
        // Default sensitive patterns
        if config.MaskIPMethod == "" </span><span class="cov0" title="0">{
                config.MaskIPMethod = "last_octet"
        }</span>
        <span class="cov0" title="0">if config.MaskIPv6Method == "" </span><span class="cov0" title="0">{
                config.MaskIPv6Method = "last_64"
        }</span>

        // Default headers to strip
        <span class="cov0" title="0">if len(config.StripHeaders) == 0 </span><span class="cov0" title="0">{
                config.StripHeaders = []string{
                        "Authorization",
                        "Cookie",
                        "Set-Cookie",
                        "X-API-Key",
                        "X-Auth-Token",
                        "Proxy-Authorization",
                }
        }</span>

        // Default query params to mask
        <span class="cov0" title="0">if len(config.MaskQueryParams) == 0 </span><span class="cov0" title="0">{
                config.MaskQueryParams = []string{
                        "token",
                        "api_key",
                        "apikey",
                        "password",
                        "passwd",
                        "pwd",
                        "secret",
                        "key",
                        "auth",
                        "access_token",
                        "refresh_token",
                        "session",
                        "sessionid",
                }
        }</span>

        // Default form fields to mask
        <span class="cov0" title="0">if len(config.MaskFormFields) == 0 </span><span class="cov0" title="0">{
                config.MaskFormFields = []string{
                        "password",
                        "passwd",
                        "pwd",
                        "credit_card",
                        "creditcard",
                        "card_number",
                        "cvv",
                        "ssn",
                        "social_security",
                }
        }</span>

        <span class="cov0" title="0">m := &amp;Masker{
                config:          config,
                stripHeaders:    make(map[string]bool),
                maskQueryParams: make(map[string]bool),
                maskFormFields:  make(map[string]bool),
        }

        // Build lookup maps for performance
        for _, h := range config.StripHeaders </span><span class="cov0" title="0">{
                m.stripHeaders[strings.ToLower(h)] = true
        }</span>
        <span class="cov0" title="0">for _, p := range config.MaskQueryParams </span><span class="cov0" title="0">{
                m.maskQueryParams[strings.ToLower(p)] = true
        }</span>
        <span class="cov0" title="0">for _, f := range config.MaskFormFields </span><span class="cov0" title="0">{
                m.maskFormFields[strings.ToLower(f)] = true
        }</span>

        // Pattern for finding sensitive data in strings
        <span class="cov0" title="0">m.sensitivePattern = regexp.MustCompile(`(?i)(password|token|key|secret|auth|credit|card|ssn|social)`)

        return m</span>
}

// MaskIP masks an IP address according to configuration
func (m *Masker) MaskIP(ip string) string <span class="cov0" title="0">{
        if !m.config.Enabled </span><span class="cov0" title="0">{
                return ip
        }</span>

        // Check if it's localhost or private IP
        <span class="cov0" title="0">if m.config.PreserveLocalhost &amp;&amp; isPrivateIP(ip) </span><span class="cov0" title="0">{
                return ip
        }</span>

        // Detect IPv4 vs IPv6
        <span class="cov0" title="0">parsedIP := net.ParseIP(ip)
        if parsedIP == nil </span><span class="cov0" title="0">{
                return "[invalid-ip]"
        }</span>

        // IPv4
        <span class="cov0" title="0">if parsedIP.To4() != nil </span><span class="cov0" title="0">{
                switch m.config.MaskIPMethod </span>{
                case "last_octet":<span class="cov0" title="0">
                        return maskIPv4LastOctet(ip)</span>
                case "hash":<span class="cov0" title="0">
                        return hashIP(ip)</span>
                case "full":<span class="cov0" title="0">
                        return "[masked]"</span>
                default:<span class="cov0" title="0">
                        return maskIPv4LastOctet(ip)</span>
                }
        }

        // IPv6
        <span class="cov0" title="0">switch m.config.MaskIPv6Method </span>{
        case "last_64":<span class="cov0" title="0">
                return maskIPv6Last64(ip)</span>
        case "hash":<span class="cov0" title="0">
                return hashIP(ip)</span>
        case "full":<span class="cov0" title="0">
                return "[masked]"</span>
        default:<span class="cov0" title="0">
                return maskIPv6Last64(ip)</span>
        }
}

// MaskHeaders masks sensitive headers from HTTP headers
func (m *Masker) MaskHeaders(headers http.Header) http.Header <span class="cov0" title="0">{
        if !m.config.Enabled </span><span class="cov0" title="0">{
                return headers
        }</span>

        <span class="cov0" title="0">masked := make(http.Header)
        for key, values := range headers </span><span class="cov0" title="0">{
                lowerKey := strings.ToLower(key)

                if m.stripHeaders[lowerKey] </span><span class="cov0" title="0">{
                        masked[key] = []string{"[masked]"}
                }</span> else<span class="cov0" title="0"> {
                        masked[key] = values
                }</span>
        }

        <span class="cov0" title="0">return masked</span>
}

// MaskQueryParams masks sensitive query parameters
func (m *Masker) MaskQueryParams(query url.Values) url.Values <span class="cov0" title="0">{
        if !m.config.Enabled </span><span class="cov0" title="0">{
                return query
        }</span>

        <span class="cov0" title="0">masked := make(url.Values)
        for key, values := range query </span><span class="cov0" title="0">{
                lowerKey := strings.ToLower(key)

                if m.maskQueryParams[lowerKey] </span><span class="cov0" title="0">{
                        masked[key] = []string{"[masked]"}
                }</span> else<span class="cov0" title="0"> {
                        masked[key] = values
                }</span>
        }

        <span class="cov0" title="0">return masked</span>
}

// MaskURL masks sensitive parts of a URL string
func (m *Masker) MaskURL(urlStr string) string <span class="cov0" title="0">{
        if !m.config.Enabled </span><span class="cov0" title="0">{
                return urlStr
        }</span>

        <span class="cov0" title="0">parsed, err := url.Parse(urlStr)
        if err != nil </span><span class="cov0" title="0">{
                return urlStr
        }</span>

        // Mask query parameters
        <span class="cov0" title="0">if parsed.RawQuery != "" </span><span class="cov0" title="0">{
                query := parsed.Query()
                masked := m.MaskQueryParams(query)
                parsed.RawQuery = masked.Encode()
        }</span>

        // Mask user info (username:password in URL)
        <span class="cov0" title="0">if parsed.User != nil </span><span class="cov0" title="0">{
                parsed.User = url.UserPassword("[masked]", "[masked]")
        }</span>

        <span class="cov0" title="0">return parsed.String()</span>
}

// MaskString masks sensitive patterns in a string
func (m *Masker) MaskString(s string) string <span class="cov0" title="0">{
        if !m.config.Enabled </span><span class="cov0" title="0">{
                return s
        }</span>

        // Simple pattern-based masking for log messages
        // This catches things like "password=secret123"
        <span class="cov0" title="0">re := regexp.MustCompile(`(?i)(password|token|key|secret|auth)[\s=:]+([^\s&amp;'"]+)`)
        return re.ReplaceAllString(s, "$1=[masked]")</span>
}

// MaskLogEvent masks PII in zerolog events
func (m *Masker) MaskLogEvent(e *zerolog.Event, ip, url, headers string) *zerolog.Event <span class="cov0" title="0">{
        if !m.config.Enabled </span><span class="cov0" title="0">{
                return e.Str("ip", ip).Str("url", url).Str("headers", headers)
        }</span>

        <span class="cov0" title="0">return e.
                Str("ip", m.MaskIP(ip)).
                Str("url", m.MaskURL(url)).
                Str("headers", m.MaskString(headers))</span>
}

// maskIPv4LastOctet masks the last octet of an IPv4 address
// Example: 203.0.113.45 -&gt; 203.0.113.xxx
func maskIPv4LastOctet(ip string) string <span class="cov0" title="0">{
        parts := strings.Split(ip, ".")
        if len(parts) != 4 </span><span class="cov0" title="0">{
                return "[invalid-ipv4]"
        }</span>

        <span class="cov0" title="0">return strings.Join(parts[:3], ".") + ".xxx"</span>
}

// maskIPv6Last64 masks the last 64 bits of an IPv6 address
// Example: 2001:db8::1 -&gt; 2001:db8::/64
func maskIPv6Last64(ip string) string <span class="cov0" title="0">{
        parsedIP := net.ParseIP(ip)
        if parsedIP == nil </span><span class="cov0" title="0">{
                return "[invalid-ipv6]"
        }</span>

        // Get first 8 bytes (64 bits)
        <span class="cov0" title="0">ipBytes := parsedIP.To16()
        if ipBytes == nil </span><span class="cov0" title="0">{
                return "[invalid-ipv6]"
        }</span>

        // Zero out last 8 bytes
        <span class="cov0" title="0">for i := 8; i &lt; 16; i++ </span><span class="cov0" title="0">{
                ipBytes[i] = 0
        }</span>

        <span class="cov0" title="0">return net.IP(ipBytes).String() + "/64"</span>
}

// hashIP creates a hashed version of an IP (not implemented for simplicity)
func hashIP(ip string) string <span class="cov0" title="0">{
        // Simple hash - in production, use proper crypto hash
        // For now, just return masked placeholder
        return "[hashed]"
}</span>

// isPrivateIP checks if an IP is private/localhost
func isPrivateIP(ip string) bool <span class="cov0" title="0">{
        parsedIP := net.ParseIP(ip)
        if parsedIP == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check for localhost
        <span class="cov0" title="0">if parsedIP.IsLoopback() </span><span class="cov0" title="0">{
                return true
        }</span>

        // Check for private IPv4 ranges
        <span class="cov0" title="0">privateRanges := []string{
                "10.0.0.0/8",
                "172.16.0.0/12",
                "192.168.0.0/16",
        }

        for _, cidr := range privateRanges </span><span class="cov0" title="0">{
                _, network, err := net.ParseCIDR(cidr)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if network.Contains(parsedIP) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        // Check for private IPv6
        <span class="cov0" title="0">if parsedIP.To4() == nil </span><span class="cov0" title="0">{
                // fc00::/7 (Unique Local Addresses)
                if parsedIP[0] == 0xfc || parsedIP[0] == 0xfd </span><span class="cov0" title="0">{
                        return true
                }</span>
                // fe80::/10 (Link-Local)
                <span class="cov0" title="0">if parsedIP[0] == 0xfe &amp;&amp; (parsedIP[1]&amp;0xc0) == 0x80 </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// ShouldMaskField checks if a field name should be masked
func (m *Masker) ShouldMaskField(fieldName string) bool <span class="cov0" title="0">{
        if !m.config.Enabled </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">lowerName := strings.ToLower(fieldName)
        return m.maskFormFields[lowerName] || m.sensitivePattern.MatchString(lowerName)</span>
}

// GetStats returns masking statistics
func (m *Masker) GetStats() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "enabled":             m.config.Enabled,
                "mask_ip_method":      m.config.MaskIPMethod,
                "mask_ipv6_method":    m.config.MaskIPv6Method,
                "preserve_localhost":  m.config.PreserveLocalhost,
                "strip_headers_count": len(m.stripHeaders),
                "mask_params_count":   len(m.maskQueryParams),
                "mask_fields_count":   len(m.maskFormFields),
        }
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package proxy

import (
        "context"
        "crypto/tls"
        "fmt"
        "net"
        "net/http"
        "net/http/httputil"
        "net/url"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        "github.com/quic-go/quic-go/http3"
        "github.com/rs/zerolog/log"
)

// SecurityHeaders defines HTTP security headers
type SecurityHeaders struct {
        HSTS              string
        XFrameOptions     string
        XContentType      string
        XSSProtection     string
        CSP               string
        ReferrerPolicy    string
        PermissionsPolicy string
}

// Backend represents a proxy target
type Backend struct {
        URL           *url.URL
        Proxy         *httputil.ReverseProxy
        Healthy       bool
        HealthPath    string
        HealthTimeout time.Duration
        Timeout       time.Duration
        MaxBodySize   int64
        WebSocket     bool
        mu            sync.RWMutex
}

// Route represents a routing rule
type Route struct {
        Domains   []string
        Path      string
        Backend   *Backend
        Headers   map[string]string
        WebSocket bool
        Priority  int // For sorting (longer paths = higher priority)
}

// CertMapping maps domain patterns to certificates
type CertMapping struct {
        Domains []string // ["*.example.com", "example.com"]
        Cert    tls.Certificate
}

// Server is the main reverse proxy server
type Server struct {
        mu              sync.RWMutex
        routes          []*Route
        routeMap        map[string]*Backend // domain+path -&gt; backend
        globalHeaders   SecurityHeaders
        blackholeMetric int64

        httpServer   *http.Server
        httpsServer  *http.Server
        http3Server  *http3.Server
        certificates []CertMapping // Loaded TLS certificates

        db               interface{} // Database connection (interface to avoid import cycle)
        metricsCollector interface{} // Metrics collector
        accessLogger     interface{} // Access logger
        certMonitor      interface{} // Certificate monitor
        healthChecker    interface{} // Health checker
        debug            bool
}

// Config holds server configuration
type Config struct {
        HTTPAddr         string
        HTTPSAddr        string
        Certificates     []CertMapping
        GlobalHeaders    SecurityHeaders
        BlackholeUnknown bool
        Debug            bool
        DB               interface{} // Database connection
        MetricsCollector interface{} // Metrics collector
        AccessLogger     interface{} // Access logger
        CertMonitor      interface{} // Certificate monitor
        HealthChecker    interface{} // Health checker
}

// NewServer creates a new proxy server
func NewServer(cfg Config) *Server <span class="cov0" title="0">{
        s := &amp;Server{
                routes:           make([]*Route, 0),
                routeMap:         make(map[string]*Backend),
                globalHeaders:    cfg.GlobalHeaders,
                certificates:     cfg.Certificates,
                db:               cfg.DB,
                metricsCollector: cfg.MetricsCollector,
                accessLogger:     cfg.AccessLogger,
                certMonitor:      cfg.CertMonitor,
                healthChecker:    cfg.HealthChecker,
                debug:            cfg.Debug,
        }

        return s
}</span>

// Start starts all HTTP servers (HTTP, HTTPS, HTTP/3)
func (s *Server) Start(ctx context.Context, httpAddr, httpsAddr string) error <span class="cov0" title="0">{
        // HTTP server (redirects to HTTPS)
        s.httpServer = &amp;http.Server{
                Addr:    httpAddr,
                Handler: http.HandlerFunc(s.redirectToHTTPS),
        }

        // HTTPS server (HTTP/1.1 and HTTP/2)
        s.httpsServer = &amp;http.Server{
                Addr:      httpsAddr,
                Handler:   s,
                TLSConfig: s.tlsConfig(),
        }

        // HTTP/3 server
        s.http3Server = &amp;http3.Server{
                Addr:      httpsAddr,
                Handler:   s,
                TLSConfig: s.tlsConfig(),
        }

        // Start HTTP server
        go func() </span><span class="cov0" title="0">{
                log.Info().Str("addr", httpAddr).Msg("Starting HTTP server")
                if err := s.httpServer.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Error().Err(err).Msg("HTTP server error")
                }</span>
        }()

        // Start HTTPS server
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                log.Info().Str("addr", httpsAddr).Msg("Starting HTTPS server (HTTP/2 enabled)")
                if err := s.httpsServer.ListenAndServeTLS("", ""); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Error().Err(err).Msg("HTTPS server error")
                }</span>
        }()

        // Start HTTP/3 server
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                log.Info().Str("addr", httpsAddr).Msg("Starting HTTP/3 server")
                if err := s.http3Server.ListenAndServeTLS("", ""); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Error().Err(err).Msg("HTTP/3 server error")
                }</span>
        }()

        <span class="cov0" title="0">&lt;-ctx.Done()
        return s.Shutdown(context.Background())</span>
}

// ServeHTTP implements http.Handler
func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Find backend for this request
        backend := s.findBackend(r.Host, r.URL.Path)

        if backend == nil </span><span class="cov0" title="0">{
                // Unknown domain - blackhole
                s.blackhole(w, r)
                return
        }</span>

        // Check if backend is healthy
        <span class="cov0" title="0">backend.mu.RLock()
        healthy := backend.Healthy
        backend.mu.RUnlock()

        if !healthy </span><span class="cov0" title="0">{
                http.Error(w, "Service Unavailable", http.StatusServiceUnavailable)
                return
        }</span>

        // Get route for headers
        <span class="cov0" title="0">route := s.findRoute(r.Host, r.URL.Path)

        // Apply security headers
        s.applyHeaders(w, route)

        // Proxy request
        backend.Proxy.ServeHTTP(w, r)</span>
}

// AddRoute adds or updates a route
func (s *Server) AddRoute(domains []string, path, backendURL string, headers map[string]string, websocket bool, options map[string]interface{}) error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        // Parse backend URL
        target, err := url.Parse(backendURL)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid backend URL: %w", err)
        }</span>

        // Create or find backend
        <span class="cov0" title="0">backend := s.getOrCreateBackend(target, options)

        // Create route
        route := &amp;Route{
                Domains:   domains,
                Path:      path,
                Backend:   backend,
                Headers:   headers,
                WebSocket: websocket,
                Priority:  len(path), // Longer paths = higher priority
        }

        // Add route
        s.routes = append(s.routes, route)
        s.sortRoutes()

        // Update route map for all domains
        for _, domain := range domains </span><span class="cov0" title="0">{
                key := s.routeKey(domain, path)
                s.routeMap[key] = backend
        }</span>

        <span class="cov0" title="0">if s.debug </span><span class="cov0" title="0">{
                log.Debug().Strs("domains", domains).Str("path", path).Str("backend", backendURL).Msg("Added route")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RemoveRoute removes routes for given domains and path
func (s *Server) RemoveRoute(domains []string, path string) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        // Remove from route map
        for _, domain := range domains </span><span class="cov0" title="0">{
                key := s.routeKey(domain, path)
                delete(s.routeMap, key)
        }</span>

        // Remove from routes slice
        <span class="cov0" title="0">filtered := make([]*Route, 0, len(s.routes))
        for _, r := range s.routes </span><span class="cov0" title="0">{
                if !s.routeMatches(r, domains, path) </span><span class="cov0" title="0">{
                        filtered = append(filtered, r)
                }</span>
        }
        <span class="cov0" title="0">s.routes = filtered

        if s.debug </span><span class="cov0" title="0">{
                log.Debug().Strs("domains", domains).Str("path", path).Msg("Removed route")
        }</span>
}

// GetBlackholeCount returns the number of blackholed requests
func (s *Server) GetBlackholeCount() int64 <span class="cov0" title="0">{
        return atomic.LoadInt64(&amp;s.blackholeMetric)
}</span>

// UpdateCertificates hot-reloads certificates without restarting the server
func (s *Server) UpdateCertificates(certificates []CertMapping) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        s.certificates = certificates
        log.Info().Int("count", len(certificates)).Msg("Certificates updated")
}</span>

// findBackend finds the best matching backend for a request
func (s *Server) findBackend(host, path string) *Backend <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        // Try exact match first
        key := s.routeKey(host, path)
        if backend, ok := s.routeMap[key]; ok </span><span class="cov0" title="0">{
                return backend
        }</span>

        // Try longest prefix match
        <span class="cov0" title="0">var bestMatch *Backend
        longestMatch := 0

        for _, route := range s.routes </span><span class="cov0" title="0">{
                for _, domain := range route.Domains </span><span class="cov0" title="0">{
                        if domain == host &amp;&amp; len(route.Path) &lt;= len(path) </span><span class="cov0" title="0">{
                                if path[:len(route.Path)] == route.Path </span><span class="cov0" title="0">{
                                        if len(route.Path) &gt; longestMatch </span><span class="cov0" title="0">{
                                                longestMatch = len(route.Path)
                                                bestMatch = route.Backend
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">return bestMatch</span>
}

// findRoute finds the route for header application
func (s *Server) findRoute(host, path string) *Route <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        var bestMatch *Route
        longestMatch := 0

        for _, route := range s.routes </span><span class="cov0" title="0">{
                for _, domain := range route.Domains </span><span class="cov0" title="0">{
                        if domain == host &amp;&amp; len(route.Path) &lt;= len(path) </span><span class="cov0" title="0">{
                                if path[:len(route.Path)] == route.Path </span><span class="cov0" title="0">{
                                        if len(route.Path) &gt; longestMatch </span><span class="cov0" title="0">{
                                                longestMatch = len(route.Path)
                                                bestMatch = route
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">return bestMatch</span>
}

// getOrCreateBackend gets or creates a backend
func (s *Server) getOrCreateBackend(target *url.URL, options map[string]interface{}) *Backend <span class="cov0" title="0">{
        // Check if backend already exists
        for _, route := range s.routes </span><span class="cov0" title="0">{
                if route.Backend.URL.String() == target.String() </span><span class="cov0" title="0">{
                        return route.Backend
                }</span>
        }

        // Create new backend
        <span class="cov0" title="0">proxy := httputil.NewSingleHostReverseProxy(target)

        // Customize transport
        transport := &amp;http.Transport{
                DialContext: (&amp;net.Dialer{
                        Timeout:   5 * time.Second,
                        KeepAlive: 30 * time.Second,
                }).DialContext,
                MaxIdleConns:          100,
                IdleConnTimeout:       90 * time.Second,
                TLSHandshakeTimeout:   10 * time.Second,
                ExpectContinueTimeout: 1 * time.Second,
        }

        proxy.Transport = transport

        // Customize director
        originalDirector := proxy.Director
        proxy.Director = func(req *http.Request) </span><span class="cov0" title="0">{
                originalDirector(req)
                // Add X-Forwarded headers
                req.Header.Set("X-Forwarded-Host", req.Host)
                req.Header.Set("X-Forwarded-Proto", "https")
                req.Header.Set("X-Real-IP", req.RemoteAddr)
        }</span>

        <span class="cov0" title="0">backend := &amp;Backend{
                URL:           target,
                Proxy:         proxy,
                Healthy:       true,
                HealthPath:    "/",
                HealthTimeout: 5 * time.Second,
                Timeout:       30 * time.Second,
                MaxBodySize:   100 * 1024 * 1024, // 100MB
        }

        // Apply options
        if options != nil </span><span class="cov0" title="0">{
                if v, ok := options["health_check_path"].(string); ok </span><span class="cov0" title="0">{
                        backend.HealthPath = v
                }</span>
                <span class="cov0" title="0">if v, ok := options["timeout"].(time.Duration); ok </span><span class="cov0" title="0">{
                        backend.Timeout = v
                }</span>
        }

        <span class="cov0" title="0">return backend</span>
}

// applyHeaders applies security headers to response
func (s *Server) applyHeaders(w http.ResponseWriter, route *Route) <span class="cov0" title="0">{
        headers := w.Header()

        // Apply global headers first
        if s.globalHeaders.HSTS != "" </span><span class="cov0" title="0">{
                headers.Set("Strict-Transport-Security", s.globalHeaders.HSTS)
        }</span>
        <span class="cov0" title="0">if s.globalHeaders.XFrameOptions != "" </span><span class="cov0" title="0">{
                headers.Set("X-Frame-Options", s.globalHeaders.XFrameOptions)
        }</span>
        <span class="cov0" title="0">if s.globalHeaders.XContentType != "" </span><span class="cov0" title="0">{
                headers.Set("X-Content-Type-Options", s.globalHeaders.XContentType)
        }</span>
        <span class="cov0" title="0">if s.globalHeaders.XSSProtection != "" </span><span class="cov0" title="0">{
                headers.Set("X-XSS-Protection", s.globalHeaders.XSSProtection)
        }</span>
        <span class="cov0" title="0">if s.globalHeaders.CSP != "" </span><span class="cov0" title="0">{
                headers.Set("Content-Security-Policy", s.globalHeaders.CSP)
        }</span>
        <span class="cov0" title="0">if s.globalHeaders.ReferrerPolicy != "" </span><span class="cov0" title="0">{
                headers.Set("Referrer-Policy", s.globalHeaders.ReferrerPolicy)
        }</span>
        <span class="cov0" title="0">if s.globalHeaders.PermissionsPolicy != "" </span><span class="cov0" title="0">{
                headers.Set("Permissions-Policy", s.globalHeaders.PermissionsPolicy)
        }</span>

        // Apply route-specific headers (override globals)
        <span class="cov0" title="0">if route != nil &amp;&amp; route.Headers != nil </span><span class="cov0" title="0">{
                for k, v := range route.Headers </span><span class="cov0" title="0">{
                        headers.Set(k, v)
                }</span>
        }
}

// blackhole handles unknown domains
func (s *Server) blackhole(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        atomic.AddInt64(&amp;s.blackholeMetric, 1)

        // Just close the connection without response
        if conn, _, err := w.(http.Hijacker).Hijack(); err == nil </span><span class="cov0" title="0">{
                conn.Close()
        }</span>
}

// redirectToHTTPS redirects HTTP to HTTPS
func (s *Server) redirectToHTTPS(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        target := "https://" + r.Host + r.URL.RequestURI()
        http.Redirect(w, r, target, http.StatusMovedPermanently)
}</span>

// tlsConfig returns TLS configuration
func (s *Server) tlsConfig() *tls.Config <span class="cov0" title="0">{
        return &amp;tls.Config{
                GetCertificate: s.getCertificate,
                NextProtos:     []string{"h3", "h2", "http/1.1"}, // HTTP/3, HTTP/2, HTTP/1.1
                MinVersion:     tls.VersionTLS12,
        }
}</span>

// getCertificate returns the appropriate certificate for a domain (supports wildcards)
func (s *Server) getCertificate(hello *tls.ClientHelloInfo) (*tls.Certificate, error) <span class="cov0" title="0">{
        domain := strings.ToLower(hello.ServerName)

        s.mu.RLock()
        defer s.mu.RUnlock()

        // Try exact match first
        for _, mapping := range s.certificates </span><span class="cov0" title="0">{
                for _, pattern := range mapping.Domains </span><span class="cov0" title="0">{
                        if strings.ToLower(pattern) == domain </span><span class="cov0" title="0">{
                                return &amp;mapping.Cert, nil
                        }</span>
                }
        }

        // Try wildcard match
        <span class="cov0" title="0">for _, mapping := range s.certificates </span><span class="cov0" title="0">{
                for _, pattern := range mapping.Domains </span><span class="cov0" title="0">{
                        if s.matchWildcard(pattern, domain) </span><span class="cov0" title="0">{
                                return &amp;mapping.Cert, nil
                        }</span>
                }
        }

        // Fallback to first certificate if available
        <span class="cov0" title="0">if len(s.certificates) &gt; 0 </span><span class="cov0" title="0">{
                log.Warn().Str("domain", domain).Msg("No matching certificate, using fallback")
                return &amp;s.certificates[0].Cert, nil
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("no certificate available for %s", domain)</span>
}

// matchWildcard checks if domain matches wildcard pattern
func (s *Server) matchWildcard(pattern, domain string) bool <span class="cov0" title="0">{
        pattern = strings.ToLower(pattern)
        domain = strings.ToLower(domain)

        // Not a wildcard pattern
        if !strings.HasPrefix(pattern, "*.") </span><span class="cov0" title="0">{
                return false
        }</span>

        // Extract base domain from pattern
        <span class="cov0" title="0">baseDomain := pattern[2:] // Remove "*."

        // Domain must end with base domain
        if !strings.HasSuffix(domain, baseDomain) </span><span class="cov0" title="0">{
                return false
        }</span>

        // Ensure there's at least one subdomain character
        <span class="cov0" title="0">prefix := domain[:len(domain)-len(baseDomain)]
        if len(prefix) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check that we're matching subdomain (not partial match)
        <span class="cov0" title="0">if prefix[len(prefix)-1] != '.' </span><span class="cov0" title="0">{
                return false
        }</span>

        // Wildcard should only match one level
        // e.g., *.example.com matches sub.example.com but not deep.sub.example.com
        <span class="cov0" title="0">subdomain := prefix[:len(prefix)-1]
        if strings.Contains(subdomain, ".") </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

// hostPolicy is no longer needed but kept for compatibility
func (s *Server) hostPolicy(ctx context.Context, host string) error <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        // Check if any route has this domain
        for _, route := range s.routes </span><span class="cov0" title="0">{
                for _, domain := range route.Domains </span><span class="cov0" title="0">{
                        if domain == host </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                }
        }

        <span class="cov0" title="0">return fmt.Errorf("domain not allowed: %s", host)</span>
}

// sortRoutes sorts routes by priority (longer paths first)
func (s *Server) sortRoutes() <span class="cov0" title="0">{
        // Simple bubble sort (routes list is small)
        for i := 0; i &lt; len(s.routes); i++ </span><span class="cov0" title="0">{
                for j := i + 1; j &lt; len(s.routes); j++ </span><span class="cov0" title="0">{
                        if s.routes[j].Priority &gt; s.routes[i].Priority </span><span class="cov0" title="0">{
                                s.routes[i], s.routes[j] = s.routes[j], s.routes[i]
                        }</span>
                }
        }
}

// routeKey generates a key for route map
func (s *Server) routeKey(domain, path string) string <span class="cov0" title="0">{
        return domain + path
}</span>

// routeMatches checks if route matches domains and path
func (s *Server) routeMatches(route *Route, domains []string, path string) bool <span class="cov0" title="0">{
        if route.Path != path </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">for _, d1 := range route.Domains </span><span class="cov0" title="0">{
                for _, d2 := range domains </span><span class="cov0" title="0">{
                        if d1 == d2 </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }
        <span class="cov0" title="0">return false</span>
}

// Shutdown gracefully shuts down all servers
func (s *Server) Shutdown(ctx context.Context) error <span class="cov0" title="0">{
        log.Info().Msg("Shutting down servers...")

        var err error
        if s.httpServer != nil </span><span class="cov0" title="0">{
                if e := s.httpServer.Shutdown(ctx); e != nil </span><span class="cov0" title="0">{
                        err = e
                }</span>
        }
        <span class="cov0" title="0">if s.httpsServer != nil </span><span class="cov0" title="0">{
                if e := s.httpsServer.Shutdown(ctx); e != nil </span><span class="cov0" title="0">{
                        err = e
                }</span>
        }
        <span class="cov0" title="0">if s.http3Server != nil </span><span class="cov0" title="0">{
                if e := s.http3Server.Close(); e != nil </span><span class="cov0" title="0">{
                        err = e
                }</span>
        }

        <span class="cov0" title="0">return err</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package ratelimit

import (
        "context"
        "fmt"
        "net"
        "net/http"
        "strings"
        "sync"
        "time"

        "github.com/rs/zerolog/log"
)

// Config holds rate limiting configuration
type Config struct {
        Enabled          bool
        RequestsPerMin   int           // Max requests per minute
        RequestsPerHour  int           // Max requests per hour
        BurstSize        int           // Burst allowance
        CleanupInterval  time.Duration // How often to clean old entries
        ViolationTimeout time.Duration // How long to block violators
}

// Limiter manages rate limiting using sliding window algorithm
type Limiter struct {
        mu        sync.RWMutex
        windows   map[string]*window // IP -&gt; window
        config    Config
        db        Database
        enabled   bool
        whitelist map[string]bool // Whitelisted IPs
}

// Database interface for storing violations
type Database interface {
        LogRateLimitViolation(ip, route, reason string, requestCount int) error
}

// window tracks request counts in sliding time windows
type window struct {
        minuteWindow []time.Time
        hourWindow   []time.Time
        violations   int
        blockedUntil time.Time
}

// NewLimiter creates a new rate limiter
func NewLimiter(config Config, db Database) *Limiter <span class="cov5" title="5">{
        if config.CleanupInterval == 0 </span><span class="cov5" title="5">{
                config.CleanupInterval = 5 * time.Minute
        }</span>
        <span class="cov5" title="5">if config.ViolationTimeout == 0 </span><span class="cov5" title="5">{
                config.ViolationTimeout = 15 * time.Minute
        }</span>
        <span class="cov5" title="5">if config.BurstSize == 0 </span><span class="cov5" title="5">{
                config.BurstSize = config.RequestsPerMin / 10 // 10% burst
        }</span>

        <span class="cov5" title="5">return &amp;Limiter{
                windows:   make(map[string]*window),
                config:    config,
                db:        db,
                enabled:   config.Enabled,
                whitelist: make(map[string]bool),
        }</span>
}

// Start begins background cleanup
func (l *Limiter) Start(ctx context.Context) <span class="cov0" title="0">{
        if !l.enabled </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">ticker := time.NewTicker(l.config.CleanupInterval)
        defer ticker.Stop()

        log.Info().Msg("Rate limiter started")

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        log.Info().Msg("Rate limiter stopped")
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        l.cleanup()</span>
                }
        }
}

// Middleware returns HTTP middleware for rate limiting
func (l *Limiter) Middleware(route string) func(http.Handler) http.Handler <span class="cov2" title="2">{
        return func(next http.Handler) http.Handler </span><span class="cov2" title="2">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov6" title="8">{
                        if !l.enabled </span><span class="cov0" title="0">{
                                next.ServeHTTP(w, r)
                                return
                        }</span>

                        <span class="cov6" title="8">ip := extractIP(r)

                        // Check whitelist
                        if l.isWhitelisted(ip) </span><span class="cov5" title="5">{
                                next.ServeHTTP(w, r)
                                return
                        }</span>

                        // Check rate limit
                        <span class="cov4" title="3">allowed, reason := l.Allow(ip, route)
                        if !allowed </span><span class="cov1" title="1">{
                                w.Header().Set("X-RateLimit-Limit", fmt.Sprintf("%d/min, %d/hour", l.config.RequestsPerMin, l.config.RequestsPerHour))
                                w.Header().Set("Retry-After", "900") // 15 minutes
                                http.Error(w, "Too Many Requests: "+reason, http.StatusTooManyRequests)

                                log.Warn().
                                        Str("ip", ip).
                                        Str("route", route).
                                        Str("reason", reason).
                                        Msg("Rate limit exceeded")

                                return
                        }</span>

                        <span class="cov2" title="2">next.ServeHTTP(w, r)</span>
                })
        }
}

// Allow checks if a request from the given IP is allowed
func (l *Limiter) Allow(ip, route string) (bool, string) <span class="cov7" title="11">{
        l.mu.Lock()
        defer l.mu.Unlock()

        now := time.Now()

        // Get or create window
        w, exists := l.windows[ip]
        if !exists </span><span class="cov4" title="4">{
                w = &amp;window{
                        minuteWindow: make([]time.Time, 0, l.config.RequestsPerMin),
                        hourWindow:   make([]time.Time, 0, l.config.RequestsPerHour),
                }
                l.windows[ip] = w
        }</span>

        // Check if IP is blocked
        <span class="cov7" title="11">if now.Before(w.blockedUntil) </span><span class="cov0" title="0">{
                remaining := w.blockedUntil.Sub(now)
                return false, fmt.Sprintf("blocked for %v due to repeated violations", remaining.Round(time.Second))
        }</span>

        // Clean expired entries from windows
        <span class="cov7" title="11">w.minuteWindow = filterExpired(w.minuteWindow, now.Add(-time.Minute))
        w.hourWindow = filterExpired(w.hourWindow, now.Add(-time.Hour))

        // Check minute limit
        minuteCount := len(w.minuteWindow)
        if minuteCount &gt;= l.config.RequestsPerMin+l.config.BurstSize </span><span class="cov2" title="2">{
                w.violations++
                if w.violations &gt;= 3 </span><span class="cov0" title="0">{
                        w.blockedUntil = now.Add(l.config.ViolationTimeout)
                        log.Warn().
                                Str("ip", ip).
                                Str("route", route).
                                Int("violations", w.violations).
                                Time("blocked_until", w.blockedUntil).
                                Msg("IP blocked due to repeated violations")
                }</span>

                // Log violation to database
                <span class="cov2" title="2">if l.db != nil </span><span class="cov2" title="2">{
                        l.db.LogRateLimitViolation(ip, route, "minute_limit_exceeded", minuteCount)
                }</span>

                <span class="cov2" title="2">return false, fmt.Sprintf("exceeded %d requests per minute (current: %d)", l.config.RequestsPerMin, minuteCount)</span>
        }

        // Check hour limit
        <span class="cov7" title="9">hourCount := len(w.hourWindow)
        if hourCount &gt;= l.config.RequestsPerHour </span><span class="cov1" title="1">{
                w.violations++
                if w.violations &gt;= 3 </span><span class="cov0" title="0">{
                        w.blockedUntil = now.Add(l.config.ViolationTimeout)
                }</span>

                // Log violation to database
                <span class="cov1" title="1">if l.db != nil </span><span class="cov1" title="1">{
                        l.db.LogRateLimitViolation(ip, route, "hour_limit_exceeded", hourCount)
                }</span>

                <span class="cov1" title="1">return false, fmt.Sprintf("exceeded %d requests per hour (current: %d)", l.config.RequestsPerHour, hourCount)</span>
        }

        // Add request to windows
        <span class="cov6" title="8">w.minuteWindow = append(w.minuteWindow, now)
        w.hourWindow = append(w.hourWindow, now)

        // Reset violation counter on successful request
        if w.violations &gt; 0 </span><span class="cov0" title="0">{
                w.violations--
        }</span>

        <span class="cov6" title="8">return true, ""</span>
}

// AddWhitelist adds an IP or CIDR to whitelist
func (l *Limiter) AddWhitelist(ipOrCIDR string) error <span class="cov1" title="1">{
        l.mu.Lock()
        defer l.mu.Unlock()

        // Check if it's a CIDR
        if strings.Contains(ipOrCIDR, "/") </span><span class="cov1" title="1">{
                _, _, err := net.ParseCIDR(ipOrCIDR)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid CIDR: %w", err)
                }</span>
        } else<span class="cov0" title="0"> {
                // Validate IP
                if net.ParseIP(ipOrCIDR) == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid IP address: %s", ipOrCIDR)
                }</span>
        }

        <span class="cov1" title="1">l.whitelist[ipOrCIDR] = true
        log.Info().Str("ip_or_cidr", ipOrCIDR).Msg("Added to rate limit whitelist")
        return nil</span>
}

// isWhitelisted checks if an IP is whitelisted
func (l *Limiter) isWhitelisted(ip string) bool <span class="cov6" title="8">{
        l.mu.RLock()
        defer l.mu.RUnlock()

        // Direct IP match
        if l.whitelist[ip] </span><span class="cov0" title="0">{
                return true
        }</span>

        // Check CIDR ranges
        <span class="cov6" title="8">parsedIP := net.ParseIP(ip)
        if parsedIP == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov6" title="8">for cidr := range l.whitelist </span><span class="cov5" title="5">{
                if !strings.Contains(cidr, "/") </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov5" title="5">_, network, err := net.ParseCIDR(cidr)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov5" title="5">if network.Contains(parsedIP) </span><span class="cov5" title="5">{
                        return true
                }</span>
        }

        <span class="cov4" title="3">return false</span>
}

// cleanup removes old entries and expired blocks
func (l *Limiter) cleanup() <span class="cov0" title="0">{
        l.mu.Lock()
        defer l.mu.Unlock()

        now := time.Now()
        oneHourAgo := now.Add(-time.Hour)

        for ip, w := range l.windows </span><span class="cov0" title="0">{
                // Clean windows
                w.minuteWindow = filterExpired(w.minuteWindow, now.Add(-time.Minute))
                w.hourWindow = filterExpired(w.hourWindow, oneHourAgo)

                // Remove window if no recent activity and not blocked
                if len(w.hourWindow) == 0 &amp;&amp; now.After(w.blockedUntil) </span><span class="cov0" title="0">{
                        delete(l.windows, ip)
                }</span>
        }

        <span class="cov0" title="0">log.Debug().Int("active_windows", len(l.windows)).Msg("Rate limiter cleanup completed")</span>
}

// GetStats returns current rate limiting statistics
func (l *Limiter) GetStats() map[string]interface{} <span class="cov1" title="1">{
        l.mu.RLock()
        defer l.mu.RUnlock()

        blockedCount := 0
        for _, w := range l.windows </span><span class="cov1" title="1">{
                if time.Now().Before(w.blockedUntil) </span><span class="cov0" title="0">{
                        blockedCount++
                }</span>
        }

        <span class="cov1" title="1">return map[string]interface{}{
                "active_windows": len(l.windows),
                "blocked_ips":    blockedCount,
                "whitelist_size": len(l.whitelist),
                "config": map[string]interface{}{
                        "requests_per_min":  l.config.RequestsPerMin,
                        "requests_per_hour": l.config.RequestsPerHour,
                        "burst_size":        l.config.BurstSize,
                },
        }</span>
}

// filterExpired removes timestamps older than the cutoff
func filterExpired(timestamps []time.Time, cutoff time.Time) []time.Time <span class="cov9" title="22">{
        result := make([]time.Time, 0, len(timestamps))
        for _, t := range timestamps </span><span class="cov10" title="24">{
                if t.After(cutoff) </span><span class="cov10" title="24">{
                        result = append(result, t)
                }</span>
        }
        <span class="cov9" title="22">return result</span>
}

// extractIP extracts the client IP from the request
func extractIP(r *http.Request) string <span class="cov6" title="8">{
        // Check X-Real-IP first (from our proxy)
        if ip := r.Header.Get("X-Real-IP"); ip != "" </span><span class="cov0" title="0">{
                return ip
        }</span>

        // Check X-Forwarded-For
        <span class="cov6" title="8">if xff := r.Header.Get("X-Forwarded-For"); xff != "" </span><span class="cov6" title="8">{
                // Take the first IP in the chain
                parts := strings.Split(xff, ",")
                if len(parts) &gt; 0 </span><span class="cov6" title="8">{
                        return strings.TrimSpace(parts[0])
                }</span>
        }

        // Fall back to RemoteAddr
        <span class="cov0" title="0">ip, _, _ := net.SplitHostPort(r.RemoteAddr)
        return ip</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package registry

import (
        "bufio"
        "context"
        "crypto/sha256"
        "encoding/hex"
        "fmt"
        "log"
        "net"
        "strings"
        "sync"
        "time"
)

// Service represents a registered service with persistent connection
type Service struct {
        Name            string
        Hostname        string
        Port            int
        MaintenancePort int
        Connection      net.Conn
        Connected       time.Time
        SessionID       string

        // Routes and config
        Routes  []ServiceRoute
        Headers map[string]string
        Options map[string]interface{}
}

// ServiceRoute represents a single route for a service
type ServiceRoute struct {
        Domains   []string
        Path      string
        Backend   string
        WebSocket bool
        Headers   map[string]string
}

// Registry manages service registrations and maintenance handshakes
type Registry struct {
        mu              sync.RWMutex
        services        map[string]*Service  // key: hostname:port
        sessions        map[string]*Service  // key: sessionID for reconnect
        disconnected    map[string]time.Time // track unexpected disconnections
        port            int
        upstreamTimeout time.Duration
        gracefulPeriod  time.Duration
        proxyServer     ProxyServer
        debug           bool
        maintenanceReqs chan maintenanceRequest
        switchbackReqs  chan switchbackRequest
}

type ProxyServer interface {
        AddRoute(domains []string, path, backendURL string, headers map[string]string, websocket bool, options map[string]interface{}) error
        RemoveRoute(domains []string, path string)
}

type maintenanceRequest struct {
        service string
        port    int
}

type switchbackRequest struct {
        service string
        port    int
}

func NewRegistry(port int, timeout time.Duration, proxyServer ProxyServer, debug bool) *Registry <span class="cov0" title="0">{
        return &amp;Registry{
                services:        make(map[string]*Service),
                sessions:        make(map[string]*Service),
                disconnected:    make(map[string]time.Time),
                port:            port,
                upstreamTimeout: timeout,
                gracefulPeriod:  5 * time.Minute,
                proxyServer:     proxyServer,
                debug:           debug,
                maintenanceReqs: make(chan maintenanceRequest, 10),
                switchbackReqs:  make(chan switchbackRequest, 10),
        }
}</span>

func (r *Registry) Start(ctx context.Context) <span class="cov0" title="0">{
        go r.processMaintenanceRequests(ctx)
        go r.processSwitchbackRequests(ctx)
        go r.cleanupExpiredSessions(ctx)

        listener, err := net.Listen("tcp", fmt.Sprintf(":%d", r.port))
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("[registry] Failed to start listener: %s", err)
        }</span>
        <span class="cov0" title="0">defer listener.Close()

        log.Printf("[registry] Service registry listening on port %d", r.port)

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                default:<span class="cov0" title="0">
                        conn, err := listener.Accept()
                        if err != nil </span><span class="cov0" title="0">{
                                if r.debug </span><span class="cov0" title="0">{
                                        log.Printf("[registry] Accept error: %s", err)
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }
                        <span class="cov0" title="0">go r.handleConnection(ctx, conn)</span>
                }
        }
}

func (r *Registry) handleConnection(ctx context.Context, conn net.Conn) <span class="cov0" title="0">{
        scanner := bufio.NewScanner(conn)

        for scanner.Scan() </span><span class="cov0" title="0">{
                line := scanner.Text()
                parts := strings.Split(line, "|")

                if len(parts) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">command := parts[0]

                switch command </span>{
                case "REGISTER":<span class="cov0" title="0">
                        r.handleRegister(ctx, conn, parts)
                        return</span> // handleRegister takes over the connection
                case "RECONNECT":<span class="cov0" title="0">
                        r.handleReconnect(ctx, conn, parts)
                        return</span>
                case "ROUTE":<span class="cov0" title="0">
                        r.handleRoute(ctx, conn, parts, scanner)</span>
                case "HEADER":<span class="cov0" title="0">
                        r.handleHeader(ctx, conn, parts)</span>
                case "OPTIONS":<span class="cov0" title="0">
                        r.handleOptions(ctx, conn, parts)</span>
                case "VALIDATE":<span class="cov0" title="0">
                        r.handleValidate(ctx, conn, parts)</span>
                case "SHUTDOWN":<span class="cov0" title="0">
                        r.handleShutdown(ctx, conn, parts)</span>
                case "MAINT_ENTER":<span class="cov0" title="0">
                        r.handleMaintenanceEnter(conn, parts)</span>
                case "MAINT_EXIT":<span class="cov0" title="0">
                        r.handleMaintenanceExit(conn, parts)</span>
                default:<span class="cov0" title="0">
                        if r.debug </span><span class="cov0" title="0">{
                                log.Printf("[registry] Unknown command: %s", command)
                        }</span>
                }
        }
}

func (r *Registry) handleRegister(ctx context.Context, conn net.Conn, parts []string) <span class="cov0" title="0">{
        // Format: REGISTER|service_name|hostname|service_port|maintenance_port
        if len(parts) != 5 </span><span class="cov0" title="0">{
                conn.Write([]byte("ERROR|Invalid format\n"))
                return
        }</span>

        <span class="cov0" title="0">serviceName := parts[1]
        hostname := parts[2]
        var servicePort, maintPort int
        fmt.Sscanf(parts[3], "%d", &amp;servicePort)
        fmt.Sscanf(parts[4], "%d", &amp;maintPort)

        serviceKey := fmt.Sprintf("%s:%d", hostname, servicePort)
        sessionID := fmt.Sprintf("%s-%d-%d", hostname, servicePort, time.Now().Unix())

        service := &amp;Service{
                Name:            serviceName,
                Hostname:        hostname,
                Port:            servicePort,
                MaintenancePort: maintPort,
                Connection:      conn,
                Connected:       time.Now(),
                SessionID:       sessionID,
                Routes:          make([]ServiceRoute, 0),
                Headers:         make(map[string]string),
                Options:         make(map[string]interface{}),
        }

        r.mu.Lock()
        r.services[serviceKey] = service
        r.sessions[sessionID] = service
        delete(r.disconnected, serviceKey) // Clear any pending disconnection
        r.mu.Unlock()

        log.Printf("[registry] Service registered: %s at %s (session: %s)", serviceName, serviceKey, sessionID)

        conn.Write([]byte(fmt.Sprintf("ACK|%s\n", sessionID)))

        r.monitorConnection(serviceKey, sessionID, serviceName, conn)</span>
}

func (r *Registry) handleReconnect(ctx context.Context, conn net.Conn, parts []string) <span class="cov0" title="0">{
        // Format: RECONNECT|session_id
        if len(parts) != 2 </span><span class="cov0" title="0">{
                conn.Write([]byte("ERROR|Invalid format\n"))
                return
        }</span>

        <span class="cov0" title="0">sessionID := parts[1]

        r.mu.Lock()
        service, exists := r.sessions[sessionID]
        r.mu.Unlock()

        if !exists </span><span class="cov0" title="0">{
                conn.Write([]byte("REREGISTER\n"))
                return
        }</span>

        // Update connection
        <span class="cov0" title="0">service.Connection = conn
        service.Connected = time.Now()

        serviceKey := fmt.Sprintf("%s:%d", service.Hostname, service.Port)

        r.mu.Lock()
        r.services[serviceKey] = service
        delete(r.disconnected, serviceKey)
        r.mu.Unlock()

        log.Printf("[registry] Service reconnected: %s at %s", service.Name, serviceKey)

        conn.Write([]byte("OK\n"))

        r.monitorConnection(serviceKey, sessionID, service.Name, conn)</span>
}

func (r *Registry) handleRoute(ctx context.Context, conn net.Conn, parts []string, scanner *bufio.Scanner) <span class="cov0" title="0">{
        // Format: ROUTE|session_id|domains|path|backend
        // domains can be comma-separated: domain1,domain2,domain3
        if len(parts) != 5 </span><span class="cov0" title="0">{
                conn.Write([]byte("ERROR|Invalid format\n"))
                return
        }</span>

        <span class="cov0" title="0">sessionID := parts[1]
        domainsStr := parts[2]
        path := parts[3]
        backend := parts[4]

        domains := strings.Split(domainsStr, ",")
        for i := range domains </span><span class="cov0" title="0">{
                domains[i] = strings.TrimSpace(domains[i])
        }</span>

        <span class="cov0" title="0">r.mu.Lock()
        service, exists := r.sessions[sessionID]
        r.mu.Unlock()

        if !exists </span><span class="cov0" title="0">{
                conn.Write([]byte("ERROR|Invalid session\n"))
                return
        }</span>

        // Create route
        <span class="cov0" title="0">route := ServiceRoute{
                Domains: domains,
                Path:    path,
                Backend: backend,
        }

        // Add to service
        service.Routes = append(service.Routes, route)

        // Apply to proxy
        err := r.proxyServer.AddRoute(domains, path, backend, service.Headers, false, service.Options)
        if err != nil </span><span class="cov0" title="0">{
                conn.Write([]byte(fmt.Sprintf("ERROR|%s\n", err.Error())))
                return
        }</span>

        <span class="cov0" title="0">log.Printf("[registry] Route added: %s at %v%s -&gt; %s", service.Name, domains, path, backend)

        conn.Write([]byte("ROUTE_OK\n"))</span>
}

func (r *Registry) handleHeader(ctx context.Context, conn net.Conn, parts []string) <span class="cov0" title="0">{
        // Format: HEADER|session_id|header_name|header_value
        if len(parts) != 4 </span><span class="cov0" title="0">{
                conn.Write([]byte("ERROR|Invalid format\n"))
                return
        }</span>

        <span class="cov0" title="0">sessionID := parts[1]
        headerName := parts[2]
        headerValue := parts[3]

        r.mu.Lock()
        service, exists := r.sessions[sessionID]
        r.mu.Unlock()

        if !exists </span><span class="cov0" title="0">{
                conn.Write([]byte("ERROR|Invalid session\n"))
                return
        }</span>

        // Add header to service
        <span class="cov0" title="0">service.Headers[headerName] = headerValue

        // Re-apply all routes with new headers
        for _, route := range service.Routes </span><span class="cov0" title="0">{
                r.proxyServer.AddRoute(route.Domains, route.Path, route.Backend, service.Headers, route.WebSocket, service.Options)
        }</span>

        <span class="cov0" title="0">log.Printf("[registry] Header added: %s = %s for %s", headerName, headerValue, service.Name)

        conn.Write([]byte("HEADER_OK\n"))</span>
}

func (r *Registry) handleOptions(ctx context.Context, conn net.Conn, parts []string) <span class="cov0" title="0">{
        // Format: OPTIONS|session_id|key|value
        if len(parts) != 4 </span><span class="cov0" title="0">{
                conn.Write([]byte("ERROR|Invalid format\n"))
                return
        }</span>

        <span class="cov0" title="0">sessionID := parts[1]
        key := parts[2]
        value := parts[3]

        r.mu.Lock()
        service, exists := r.sessions[sessionID]
        r.mu.Unlock()

        if !exists </span><span class="cov0" title="0">{
                conn.Write([]byte("ERROR|Invalid session\n"))
                return
        }</span>

        // Parse value based on key
        <span class="cov0" title="0">var parsedValue interface{} = value

        switch key </span>{
        case "timeout", "health_check_interval", "health_check_timeout":<span class="cov0" title="0">
                if dur, err := time.ParseDuration(value); err == nil </span><span class="cov0" title="0">{
                        parsedValue = dur
                }</span>
        case "websocket", "compression", "http2", "http3":<span class="cov0" title="0">
                parsedValue = value == "true"</span>
        }

        <span class="cov0" title="0">service.Options[key] = parsedValue

        // Re-apply all routes with new options
        for _, route := range service.Routes </span><span class="cov0" title="0">{
                r.proxyServer.AddRoute(route.Domains, route.Path, route.Backend, service.Headers, route.WebSocket, service.Options)
        }</span>

        <span class="cov0" title="0">log.Printf("[registry] Option set: %s = %v for %s", key, parsedValue, service.Name)

        conn.Write([]byte("OPTIONS_OK\n"))</span>
}

func (r *Registry) handleValidate(ctx context.Context, conn net.Conn, parts []string) <span class="cov0" title="0">{
        // Format: VALIDATE|session_id|hash
        if len(parts) != 3 </span><span class="cov0" title="0">{
                conn.Write([]byte("ERROR|Invalid format\n"))
                return
        }</span>

        <span class="cov0" title="0">sessionID := parts[1]
        clientHash := parts[2]

        r.mu.RLock()
        service, exists := r.sessions[sessionID]
        r.mu.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                conn.Write([]byte("ERROR|Invalid session\n"))
                return
        }</span>

        // Calculate server hash from routes
        <span class="cov0" title="0">serverHash := r.calculateRoutesHash(service)

        if clientHash == serverHash </span><span class="cov0" title="0">{
                parity := r.calculateParity(serverHash)
                conn.Write([]byte(fmt.Sprintf("VALID|%d\n", parity)))
        }</span> else<span class="cov0" title="0"> {
                conn.Write([]byte(fmt.Sprintf("MISMATCH|%s\n", serverHash)))
        }</span>
}

func (r *Registry) handleShutdown(ctx context.Context, conn net.Conn, parts []string) <span class="cov0" title="0">{
        // Format: SHUTDOWN|session_id
        if len(parts) != 2 </span><span class="cov0" title="0">{
                conn.Write([]byte("ERROR|Invalid format\n"))
                return
        }</span>

        <span class="cov0" title="0">sessionID := parts[1]

        r.mu.Lock()
        service, exists := r.sessions[sessionID]
        if !exists </span><span class="cov0" title="0">{
                r.mu.Unlock()
                conn.Write([]byte("ERROR|Invalid session\n"))
                return
        }</span>

        <span class="cov0" title="0">serviceKey := fmt.Sprintf("%s:%d", service.Hostname, service.Port)

        // Remove all routes
        for _, route := range service.Routes </span><span class="cov0" title="0">{
                r.proxyServer.RemoveRoute(route.Domains, route.Path)
        }</span>

        // Graceful shutdown - remove immediately
        <span class="cov0" title="0">delete(r.services, serviceKey)
        delete(r.sessions, sessionID)
        delete(r.disconnected, serviceKey)
        r.mu.Unlock()

        log.Printf("[registry] Graceful shutdown: %s at %s (routes removed immediately)", service.Name, serviceKey)

        conn.Write([]byte("SHUTDOWN_OK\n"))
        conn.Close()</span>
}

func (r *Registry) monitorConnection(serviceKey, sessionID, serviceName string, conn net.Conn) <span class="cov0" title="0">{
        buf := make([]byte, 1)
        _, err := conn.Read(buf)

        r.mu.Lock()
        delete(r.services, serviceKey)
        r.disconnected[serviceKey] = time.Now()
        r.mu.Unlock()

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[registry] Service unexpectedly disconnected: %s at %s (config retained for %v)", serviceName, serviceKey, r.gracefulPeriod)
        }</span> else<span class="cov0" title="0"> {
                log.Printf("[registry] Service connection closed: %s at %s (config retained for %v)", serviceName, serviceKey, r.gracefulPeriod)
        }</span>
}

func (r *Registry) handleMaintenanceEnter(conn net.Conn, parts []string) <span class="cov0" title="0">{
        // Format: MAINT_ENTER|hostname:port|maintenance_port
        if len(parts) != 3 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">service := parts[1]
        var maintPort int
        fmt.Sscanf(parts[2], "%d", &amp;maintPort)

        conn.Write([]byte("ACK\n"))

        r.maintenanceReqs &lt;- maintenanceRequest{service: service, port: maintPort}</span>
}

func (r *Registry) handleMaintenanceExit(conn net.Conn, parts []string) <span class="cov0" title="0">{
        // Format: MAINT_EXIT|hostname:port
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">service := parts[1]
        parts2 := strings.Split(service, ":")
        var port int
        if len(parts2) == 2 </span><span class="cov0" title="0">{
                fmt.Sscanf(parts2[1], "%d", &amp;port)
        }</span>

        <span class="cov0" title="0">conn.Write([]byte("ACK\n"))

        r.switchbackReqs &lt;- switchbackRequest{service: service, port: port + 1}</span>
}

func (r *Registry) processMaintenanceRequests(ctx context.Context) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case req := &lt;-r.maintenanceReqs:<span class="cov0" title="0">
                        go r.approveMaintenanceMode(req.service, req.port)</span>
                }
        }
}

func (r *Registry) processSwitchbackRequests(ctx context.Context) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case req := &lt;-r.switchbackReqs:<span class="cov0" title="0">
                        go r.approveSwitchback(req.service, req.port)</span>
                }
        }
}

func (r *Registry) approveMaintenanceMode(service string, maintPort int) <span class="cov0" title="0">{
        parts := strings.Split(service, ":")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">hostname := parts[0]
        log.Printf("[registry] Approving maintenance mode for %s (port %d)", service, maintPort)

        // TODO: Disable routes for this service in proxy

        time.Sleep(2 * time.Second)

        conn, err := net.DialTimeout("tcp", fmt.Sprintf("%s:%d", hostname, maintPort), r.upstreamTimeout)
        if err != nil </span><span class="cov0" title="0">{
                if r.debug </span><span class="cov0" title="0">{
                        log.Printf("[registry] Failed to connect to maintenance server: %s", err)
                }</span>
                <span class="cov0" title="0">return</span>
        }
        <span class="cov0" title="0">defer conn.Close()

        conn.Write([]byte("MAINT_APPROVED\n"))

        buf := make([]byte, 4)
        conn.SetReadDeadline(time.Now().Add(r.upstreamTimeout))
        conn.Read(buf)

        log.Printf("[registry] Maintenance mode approved for %s", service)</span>
}

func (r *Registry) approveSwitchback(service string, maintPort int) <span class="cov0" title="0">{
        parts := strings.Split(service, ":")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">hostname := parts[0]
        log.Printf("[registry] Approving switchback for %s (port %d)", service, maintPort)

        // TODO: Re-enable routes for this service in proxy

        time.Sleep(2 * time.Second)

        conn, err := net.DialTimeout("tcp", fmt.Sprintf("%s:%d", hostname, maintPort), r.upstreamTimeout)
        if err != nil </span><span class="cov0" title="0">{
                if r.debug </span><span class="cov0" title="0">{
                        log.Printf("[registry] Failed to connect to maintenance server: %s", err)
                }</span>
                <span class="cov0" title="0">return</span>
        }
        <span class="cov0" title="0">defer conn.Close()

        conn.Write([]byte("SWITCHBACK_APPROVED\n"))

        buf := make([]byte, 4)
        conn.SetReadDeadline(time.Now().Add(r.upstreamTimeout))
        conn.Read(buf)

        log.Printf("[registry] Switchback approved for %s", service)</span>
}

func (r *Registry) cleanupExpiredSessions(ctx context.Context) <span class="cov0" title="0">{
        ticker := time.NewTicker(1 * time.Minute)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        r.mu.Lock()
                        now := time.Now()
                        for serviceKey, disconnectTime := range r.disconnected </span><span class="cov0" title="0">{
                                if now.Sub(disconnectTime) &gt; r.gracefulPeriod </span><span class="cov0" title="0">{
                                        for sessionID, service := range r.sessions </span><span class="cov0" title="0">{
                                                if fmt.Sprintf("%s:%d", service.Hostname, service.Port) == serviceKey </span><span class="cov0" title="0">{
                                                        // Remove all routes
                                                        for _, route := range service.Routes </span><span class="cov0" title="0">{
                                                                r.proxyServer.RemoveRoute(route.Domains, route.Path)
                                                        }</span>

                                                        <span class="cov0" title="0">delete(r.sessions, sessionID)
                                                        log.Printf("[registry] Expired session cleanup: %s at %s (disconnected %v ago)", service.Name, serviceKey, now.Sub(disconnectTime))
                                                        break</span>
                                                }
                                        }
                                        <span class="cov0" title="0">delete(r.disconnected, serviceKey)</span>
                                }
                        }
                        <span class="cov0" title="0">r.mu.Unlock()</span>
                }
        }
}

func (r *Registry) NotifyShutdown() <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        log.Printf("[registry] Notifying %d connected services of shutdown", len(r.services))

        for serviceKey, service := range r.services </span><span class="cov0" title="0">{
                if service.Connection != nil </span><span class="cov0" title="0">{
                        _, err := service.Connection.Write([]byte("SHUTDOWN\n"))
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("[registry] Failed to notify %s of shutdown: %s", serviceKey, err)
                        }</span> else<span class="cov0" title="0"> {
                                log.Printf("[registry] Shutdown notification sent to %s", serviceKey)
                        }</span>
                }
        }
}

func (r *Registry) IsRegistered(hostname string, port int) bool <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        key := fmt.Sprintf("%s:%d", hostname, port)
        _, exists := r.services[key]
        return exists
}</span>

func (r *Registry) GetMaintenancePort(hostname string, port int) (int, bool) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        key := fmt.Sprintf("%s:%d", hostname, port)
        if service, exists := r.services[key]; exists </span><span class="cov0" title="0">{
                return service.MaintenancePort, true
        }</span>
        <span class="cov0" title="0">return port + 1, false</span>
}

func (r *Registry) calculateRoutesHash(service *Service) string <span class="cov0" title="0">{
        var data strings.Builder

        for _, route := range service.Routes </span><span class="cov0" title="0">{
                data.WriteString(strings.Join(route.Domains, ","))
                data.WriteString(route.Path)
                data.WriteString(route.Backend)
        }</span>

        <span class="cov0" title="0">for k, v := range service.Headers </span><span class="cov0" title="0">{
                data.WriteString(k)
                data.WriteString(v)
        }</span>

        <span class="cov0" title="0">hash := sha256.Sum256([]byte(data.String()))
        return hex.EncodeToString(hash[:])</span>
}

func (r *Registry) calculateParity(hash string) int <span class="cov0" title="0">{
        ones := 0
        for _, c := range hash </span><span class="cov0" title="0">{
                switch c </span>{
                case '1', '3', '5', '7', '9', 'b', 'd', 'f':<span class="cov0" title="0">
                        ones++</span>
                }
        }
        <span class="cov0" title="0">if ones%2 == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return 1</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package retention

import (
        "context"
        "time"

        "github.com/rs/zerolog/log"
)

// Policy represents a data retention policy
type Policy struct {
        Name             string
        RoutePattern     string // Route pattern to match (e.g., "*.private.com")
        AccessLogDays    int    // Days to keep access logs
        SecurityLogDays  int    // Days to keep security logs (WAF, rate limit)
        AuditLogDays     int    // Days to keep audit logs
        MetricsDays      int    // Days to keep metrics
        HealthCheckDays  int    // Days to keep health check logs
        WebSocketLogDays int    // Days to keep WebSocket logs
}

// Manager manages data retention policies
type Manager struct {
        policies        []Policy
        db              Database
        cleanupInterval time.Duration
        defaultPolicy   Policy
}

// Database interface for retention operations
type Database interface {
        CleanupOldData(retentionDays int) error
        CleanupAccessLogs(days int, routePattern string) error
        CleanupSecurityLogs(days int, routePattern string) error
        CleanupAuditLogs(days int) error
        CleanupMetrics(days int, routePattern string) error
        CleanupHealthChecks(days int) error
}

// NewManager creates a new retention policy manager
func NewManager(db Database, cleanupInterval time.Duration) *Manager <span class="cov0" title="0">{
        // Default policy (applies if no specific policy matches)
        defaultPolicy := Policy{
                Name:             "default",
                RoutePattern:     "*",
                AccessLogDays:    30,  // 30 days for general access logs
                SecurityLogDays:  90,  // 90 days for security events
                AuditLogDays:     365, // 1 year for audit logs
                MetricsDays:      90,  // 90 days for metrics
                HealthCheckDays:  7,   // 7 days for health checks
                WebSocketLogDays: 30,  // 30 days for WebSocket logs
        }

        if cleanupInterval == 0 </span><span class="cov0" title="0">{
                cleanupInterval = 24 * time.Hour // Daily by default
        }</span>

        <span class="cov0" title="0">return &amp;Manager{
                policies:        make([]Policy, 0),
                db:              db,
                cleanupInterval: cleanupInterval,
                defaultPolicy:   defaultPolicy,
        }</span>
}

// AddPolicy adds a retention policy
func (m *Manager) AddPolicy(policy Policy) <span class="cov0" title="0">{
        m.policies = append(m.policies, policy)
        log.Info().
                Str("name", policy.Name).
                Str("route_pattern", policy.RoutePattern).
                Int("access_log_days", policy.AccessLogDays).
                Int("security_log_days", policy.SecurityLogDays).
                Int("audit_log_days", policy.AuditLogDays).
                Msg("Added retention policy")
}</span>

// AddPublicPolicy adds a policy for public-facing services
func (m *Manager) AddPublicPolicy(routePattern string) <span class="cov0" title="0">{
        m.AddPolicy(Policy{
                Name:             "public",
                RoutePattern:     routePattern,
                AccessLogDays:    7,  // 7 days for public access logs
                SecurityLogDays:  30, // 30 days for security events
                AuditLogDays:     90, // 90 days for audit
                MetricsDays:      30, // 30 days for metrics
                HealthCheckDays:  7,  // 7 days for health checks
                WebSocketLogDays: 7,  // 7 days for WebSocket
        })
}</span>

// AddPrivatePolicy adds a policy for private/sensitive services
func (m *Manager) AddPrivatePolicy(routePattern string) <span class="cov0" title="0">{
        m.AddPolicy(Policy{
                Name:             "private",
                RoutePattern:     routePattern,
                AccessLogDays:    30,  // 30 days for private access logs
                SecurityLogDays:  90,  // 90 days for security events
                AuditLogDays:     365, // 1 year for audit (compliance)
                MetricsDays:      90,  // 90 days for metrics
                HealthCheckDays:  7,   // 7 days for health checks
                WebSocketLogDays: 30,  // 30 days for WebSocket
        })
}</span>

// Start starts the retention policy manager
func (m *Manager) Start(ctx context.Context) <span class="cov0" title="0">{
        log.Info().
                Dur("interval", m.cleanupInterval).
                Int("policies", len(m.policies)).
                Msg("Starting retention policy manager")

        // Run initial cleanup after a short delay
        time.Sleep(30 * time.Second)
        m.runCleanup()

        ticker := time.NewTicker(m.cleanupInterval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        log.Info().Msg("Retention policy manager stopped")
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        m.runCleanup()</span>
                }
        }
}

// runCleanup runs cleanup based on all policies
func (m *Manager) runCleanup() <span class="cov0" title="0">{
        log.Info().Msg("Running retention policy cleanup")
        startTime := time.Now()

        // Apply each policy
        for _, policy := range m.policies </span><span class="cov0" title="0">{
                m.applyPolicy(policy)
        }</span>

        // Apply default policy for unmatched routes
        <span class="cov0" title="0">m.applyPolicy(m.defaultPolicy)

        duration := time.Since(startTime)
        log.Info().
                Dur("duration", duration).
                Msg("Retention policy cleanup completed")</span>
}

// applyPolicy applies a single retention policy
func (m *Manager) applyPolicy(policy Policy) <span class="cov0" title="0">{
        log.Debug().
                Str("policy", policy.Name).
                Str("route_pattern", policy.RoutePattern).
                Msg("Applying retention policy")

        // Cleanup access logs
        if policy.AccessLogDays &gt; 0 </span><span class="cov0" title="0">{
                if err := m.db.CleanupAccessLogs(policy.AccessLogDays, policy.RoutePattern); err != nil </span><span class="cov0" title="0">{
                        log.Error().
                                Err(err).
                                Str("policy", policy.Name).
                                Msg("Failed to cleanup access logs")
                }</span>
        }

        // Cleanup security logs (WAF blocks, rate limit violations)
        <span class="cov0" title="0">if policy.SecurityLogDays &gt; 0 </span><span class="cov0" title="0">{
                if err := m.db.CleanupSecurityLogs(policy.SecurityLogDays, policy.RoutePattern); err != nil </span><span class="cov0" title="0">{
                        log.Error().
                                Err(err).
                                Str("policy", policy.Name).
                                Msg("Failed to cleanup security logs")
                }</span>
        }

        // Cleanup audit logs (global, not per-route)
        <span class="cov0" title="0">if policy.AuditLogDays &gt; 0 &amp;&amp; policy.RoutePattern == "*" </span><span class="cov0" title="0">{
                if err := m.db.CleanupAuditLogs(policy.AuditLogDays); err != nil </span><span class="cov0" title="0">{
                        log.Error().
                                Err(err).
                                Str("policy", policy.Name).
                                Msg("Failed to cleanup audit logs")
                }</span>
        }

        // Cleanup metrics
        <span class="cov0" title="0">if policy.MetricsDays &gt; 0 </span><span class="cov0" title="0">{
                if err := m.db.CleanupMetrics(policy.MetricsDays, policy.RoutePattern); err != nil </span><span class="cov0" title="0">{
                        log.Error().
                                Err(err).
                                Str("policy", policy.Name).
                                Msg("Failed to cleanup metrics")
                }</span>
        }

        // Cleanup health checks (global)
        <span class="cov0" title="0">if policy.HealthCheckDays &gt; 0 &amp;&amp; policy.RoutePattern == "*" </span><span class="cov0" title="0">{
                if err := m.db.CleanupHealthChecks(policy.HealthCheckDays); err != nil </span><span class="cov0" title="0">{
                        log.Error().
                                Err(err).
                                Str("policy", policy.Name).
                                Msg("Failed to cleanup health checks")
                }</span>
        }
}

// GetPolicies returns all configured policies
func (m *Manager) GetPolicies() []Policy <span class="cov0" title="0">{
        policies := make([]Policy, 0, len(m.policies)+1)
        policies = append(policies, m.policies...)
        policies = append(policies, m.defaultPolicy)
        return policies
}</span>

// GetStats returns retention policy statistics
func (m *Manager) GetStats() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "cleanup_interval_hours": m.cleanupInterval.Hours(),
                "policies_count":         len(m.policies),
                "default_policy": map[string]int{
                        "access_log_days":    m.defaultPolicy.AccessLogDays,
                        "security_log_days":  m.defaultPolicy.SecurityLogDays,
                        "audit_log_days":     m.defaultPolicy.AuditLogDays,
                        "metrics_days":       m.defaultPolicy.MetricsDays,
                        "health_check_days":  m.defaultPolicy.HealthCheckDays,
                        "websocket_log_days": m.defaultPolicy.WebSocketLogDays,
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package traffic

import (
        "net"
        "sort"
        "strings"
        "sync"
        "time"

        "github.com/rs/zerolog/log"
)

// Analyzer performs traffic pattern analysis
type Analyzer struct {
        ipStats   map[string]*IPStats
        uaStats   map[string]*UserAgentStats
        pathStats map[string]*PathStats
        timeSlots map[int64]*TimeSlotStats // unix timestamp -&gt; stats

        mu            sync.RWMutex
        windowSize    time.Duration // how far back to keep data
        cleanupTicker *time.Ticker
}

// IPStats tracks statistics for a single IP address
type IPStats struct {
        RequestCount    int
        ErrorCount      int
        BytesSent       uint64
        BytesReceived   uint64
        FirstSeen       int64
        LastSeen        int64
        Paths           map[string]int // path -&gt; count
        StatusCodes     map[int]int    // status code -&gt; count
        ReputationScore float64        // 0-100, lower is worse
}

// UserAgentStats tracks statistics for user agents
type UserAgentStats struct {
        RequestCount int
        ErrorCount   int
        FirstSeen    int64
        LastSeen     int64
        IPs          map[string]int // IP -&gt; count
        Browser      string         // parsed browser name
        OS           string         // parsed OS name
        IsBot        bool
}

// PathStats tracks statistics for request paths
type PathStats struct {
        RequestCount      int
        ErrorCount        int
        TotalResponseTime float64
        AvgResponseTime   float64
        StatusCodes       map[int]int
        Methods           map[string]int
        UniqueIPs         map[string]bool
}

// TimeSlotStats tracks statistics per time slot
type TimeSlotStats struct {
        Timestamp    int64
        RequestCount int
        ErrorCount   int
        UniqueIPs    int
        TotalBytes   uint64
}

// TrafficAnalysis represents analyzed traffic patterns
type TrafficAnalysis struct {
        // Top Statistics
        TopIPs        []IPRanking        `json:"top_ips"`
        TopPaths      []PathRanking      `json:"top_paths"`
        TopUserAgents []UserAgentRanking `json:"top_user_agents"`

        // Reputation Analysis
        SuspiciousIPs []string `json:"suspicious_ips"`
        BotTraffic    float64  `json:"bot_traffic_percent"`

        // Geographic Distribution (placeholder for future implementation)
        TopCountries []string `json:"top_countries,omitempty"`

        // Pattern Detection
        AnomalousPatterns []AnomalyDetection `json:"anomalous_patterns"`
        TrafficPeaks      []TrafficPeak      `json:"traffic_peaks"`

        // Summary
        TotalUniqueIPs   int   `json:"total_unique_ips"`
        TotalUniquePaths int   `json:"total_unique_paths"`
        TotalUniqueUAs   int   `json:"total_unique_user_agents"`
        AnalysisWindow   int64 `json:"analysis_window_seconds"`
}

// IPRanking represents an IP in rankings
type IPRanking struct {
        IP               string  `json:"ip"`
        RequestCount     int     `json:"request_count"`
        ErrorRate        float64 `json:"error_rate_percent"`
        BytesTransferred uint64  `json:"bytes_transferred"`
        ReputationScore  float64 `json:"reputation_score"`
}

// PathRanking represents a path in rankings
type PathRanking struct {
        Path            string  `json:"path"`
        RequestCount    int     `json:"request_count"`
        ErrorRate       float64 `json:"error_rate_percent"`
        AvgResponseTime float64 `json:"avg_response_time_ms"`
        UniqueIPs       int     `json:"unique_ips"`
}

// UserAgentRanking represents a user agent in rankings
type UserAgentRanking struct {
        UserAgent    string  `json:"user_agent"`
        RequestCount int     `json:"request_count"`
        ErrorRate    float64 `json:"error_rate_percent"`
        IsBot        bool    `json:"is_bot"`
        Browser      string  `json:"browser,omitempty"`
        OS           string  `json:"os,omitempty"`
}

// AnomalyDetection represents detected anomalous patterns
type AnomalyDetection struct {
        Type        string `json:"type"` // "high_error_rate", "unusual_pattern", "rapid_requests"
        Description string `json:"description"`
        Severity    string `json:"severity"` // "low", "medium", "high"
        IP          string `json:"ip,omitempty"`
        Path        string `json:"path,omitempty"`
        Timestamp   int64  `json:"timestamp"`
}

// TrafficPeak represents a traffic spike
type TrafficPeak struct {
        Timestamp    int64 `json:"timestamp"`
        RequestCount int   `json:"request_count"`
        UniqueIPs    int   `json:"unique_ips"`
}

// NewAnalyzer creates a new traffic analyzer
func NewAnalyzer(windowSize time.Duration) *Analyzer <span class="cov4" title="4">{
        if windowSize &lt;= 0 </span><span class="cov0" title="0">{
                windowSize = 1 * time.Hour // Default: 1 hour window
        }</span>

        <span class="cov4" title="4">a := &amp;Analyzer{
                ipStats:    make(map[string]*IPStats),
                uaStats:    make(map[string]*UserAgentStats),
                pathStats:  make(map[string]*PathStats),
                timeSlots:  make(map[int64]*TimeSlotStats),
                windowSize: windowSize,
        }

        // Start cleanup goroutine
        a.cleanupTicker = time.NewTicker(5 * time.Minute)
        go a.cleanupOldData()

        return a</span>
}

// RecordRequest records a request for traffic analysis
func (a *Analyzer) RecordRequest(ip, path, method, userAgent string, statusCode int, responseTime float64, bytesIn, bytesOut uint64) <span class="cov5" title="6">{
        a.mu.Lock()
        defer a.mu.Unlock()

        now := time.Now().Unix()

        // Update IP statistics
        if _, exists := a.ipStats[ip]; !exists </span><span class="cov4" title="4">{
                a.ipStats[ip] = &amp;IPStats{
                        FirstSeen:       now,
                        Paths:           make(map[string]int),
                        StatusCodes:     make(map[int]int),
                        ReputationScore: 100.0, // Start with perfect score
                }
        }</span>
        <span class="cov5" title="6">ipStat := a.ipStats[ip]
        ipStat.RequestCount++
        ipStat.LastSeen = now
        ipStat.BytesSent += bytesOut
        ipStat.BytesReceived += bytesIn
        ipStat.Paths[path]++
        ipStat.StatusCodes[statusCode]++
        if statusCode &gt;= 400 </span><span class="cov2" title="2">{
                ipStat.ErrorCount++
                // Decrease reputation on errors
                ipStat.ReputationScore = max(0, ipStat.ReputationScore-0.5)
        }</span>

        // Update user agent statistics
        <span class="cov5" title="6">if userAgent != "" </span><span class="cov5" title="6">{
                if _, exists := a.uaStats[userAgent]; !exists </span><span class="cov4" title="4">{
                        a.uaStats[userAgent] = &amp;UserAgentStats{
                                FirstSeen: now,
                                IPs:       make(map[string]int),
                                IsBot:     a.detectBot(userAgent),
                        }
                        a.parseUserAgent(a.uaStats[userAgent], userAgent)
                }</span>
                <span class="cov5" title="6">uaStat := a.uaStats[userAgent]
                uaStat.RequestCount++
                uaStat.LastSeen = now
                uaStat.IPs[ip]++
                if statusCode &gt;= 400 </span><span class="cov2" title="2">{
                        uaStat.ErrorCount++
                }</span>
        }

        // Update path statistics
        <span class="cov5" title="6">if _, exists := a.pathStats[path]; !exists </span><span class="cov4" title="4">{
                a.pathStats[path] = &amp;PathStats{
                        StatusCodes: make(map[int]int),
                        Methods:     make(map[string]int),
                        UniqueIPs:   make(map[string]bool),
                }
        }</span>
        <span class="cov5" title="6">pathStat := a.pathStats[path]
        pathStat.RequestCount++
        pathStat.TotalResponseTime += responseTime
        pathStat.AvgResponseTime = pathStat.TotalResponseTime / float64(pathStat.RequestCount)
        pathStat.StatusCodes[statusCode]++
        pathStat.Methods[method]++
        pathStat.UniqueIPs[ip] = true
        if statusCode &gt;= 400 </span><span class="cov2" title="2">{
                pathStat.ErrorCount++
        }</span>

        // Update time slot statistics (1-minute granularity)
        <span class="cov5" title="6">timeSlot := (now / 60) * 60
        if _, exists := a.timeSlots[timeSlot]; !exists </span><span class="cov3" title="3">{
                a.timeSlots[timeSlot] = &amp;TimeSlotStats{
                        Timestamp: timeSlot,
                }
        }</span>
        <span class="cov5" title="6">slot := a.timeSlots[timeSlot]
        slot.RequestCount++
        slot.TotalBytes += bytesIn + bytesOut
        if statusCode &gt;= 400 </span><span class="cov2" title="2">{
                slot.ErrorCount++
        }</span>
}

// Analyze performs traffic analysis and returns insights
func (a *Analyzer) Analyze(topN int) TrafficAnalysis <span class="cov1" title="1">{
        a.mu.RLock()
        defer a.mu.RUnlock()

        if topN &lt;= 0 </span><span class="cov0" title="0">{
                topN = 10
        }</span>

        <span class="cov1" title="1">analysis := TrafficAnalysis{
                TotalUniqueIPs:   len(a.ipStats),
                TotalUniquePaths: len(a.pathStats),
                TotalUniqueUAs:   len(a.uaStats),
                AnalysisWindow:   int64(a.windowSize.Seconds()),
        }

        // Rank IPs
        analysis.TopIPs = a.rankIPs(topN)

        // Rank paths
        analysis.TopPaths = a.rankPaths(topN)

        // Rank user agents
        analysis.TopUserAgents = a.rankUserAgents(topN)

        // Detect suspicious IPs (low reputation score)
        analysis.SuspiciousIPs = a.detectSuspiciousIPs()

        // Calculate bot traffic percentage
        analysis.BotTraffic = a.calculateBotTraffic()

        // Detect anomalies
        analysis.AnomalousPatterns = a.detectAnomalies()

        // Detect traffic peaks
        analysis.TrafficPeaks = a.detectTrafficPeaks()

        return analysis</span>
}

// rankIPs ranks IPs by request count
func (a *Analyzer) rankIPs(topN int) []IPRanking <span class="cov1" title="1">{
        rankings := make([]IPRanking, 0, len(a.ipStats))

        for ip, stats := range a.ipStats </span><span class="cov2" title="2">{
                errorRate := 0.0
                if stats.RequestCount &gt; 0 </span><span class="cov2" title="2">{
                        errorRate = float64(stats.ErrorCount) / float64(stats.RequestCount) * 100
                }</span>

                <span class="cov2" title="2">rankings = append(rankings, IPRanking{
                        IP:               ip,
                        RequestCount:     stats.RequestCount,
                        ErrorRate:        errorRate,
                        BytesTransferred: stats.BytesSent + stats.BytesReceived,
                        ReputationScore:  stats.ReputationScore,
                })</span>
        }

        // Sort by request count
        <span class="cov1" title="1">sort.Slice(rankings, func(i, j int) bool </span><span class="cov1" title="1">{
                return rankings[i].RequestCount &gt; rankings[j].RequestCount
        }</span>)

        <span class="cov1" title="1">if len(rankings) &gt; topN </span><span class="cov0" title="0">{
                rankings = rankings[:topN]
        }</span>

        <span class="cov1" title="1">return rankings</span>
}

// rankPaths ranks paths by request count
func (a *Analyzer) rankPaths(topN int) []PathRanking <span class="cov1" title="1">{
        rankings := make([]PathRanking, 0, len(a.pathStats))

        for path, stats := range a.pathStats </span><span class="cov2" title="2">{
                errorRate := 0.0
                if stats.RequestCount &gt; 0 </span><span class="cov2" title="2">{
                        errorRate = float64(stats.ErrorCount) / float64(stats.RequestCount) * 100
                }</span>

                <span class="cov2" title="2">rankings = append(rankings, PathRanking{
                        Path:            path,
                        RequestCount:    stats.RequestCount,
                        ErrorRate:       errorRate,
                        AvgResponseTime: stats.AvgResponseTime,
                        UniqueIPs:       len(stats.UniqueIPs),
                })</span>
        }

        // Sort by request count
        <span class="cov1" title="1">sort.Slice(rankings, func(i, j int) bool </span><span class="cov1" title="1">{
                return rankings[i].RequestCount &gt; rankings[j].RequestCount
        }</span>)

        <span class="cov1" title="1">if len(rankings) &gt; topN </span><span class="cov0" title="0">{
                rankings = rankings[:topN]
        }</span>

        <span class="cov1" title="1">return rankings</span>
}

// rankUserAgents ranks user agents by request count
func (a *Analyzer) rankUserAgents(topN int) []UserAgentRanking <span class="cov1" title="1">{
        rankings := make([]UserAgentRanking, 0, len(a.uaStats))

        for ua, stats := range a.uaStats </span><span class="cov2" title="2">{
                errorRate := 0.0
                if stats.RequestCount &gt; 0 </span><span class="cov2" title="2">{
                        errorRate = float64(stats.ErrorCount) / float64(stats.RequestCount) * 100
                }</span>

                <span class="cov2" title="2">rankings = append(rankings, UserAgentRanking{
                        UserAgent:    ua,
                        RequestCount: stats.RequestCount,
                        ErrorRate:    errorRate,
                        IsBot:        stats.IsBot,
                        Browser:      stats.Browser,
                        OS:           stats.OS,
                })</span>
        }

        // Sort by request count
        <span class="cov1" title="1">sort.Slice(rankings, func(i, j int) bool </span><span class="cov1" title="1">{
                return rankings[i].RequestCount &gt; rankings[j].RequestCount
        }</span>)

        <span class="cov1" title="1">if len(rankings) &gt; topN </span><span class="cov0" title="0">{
                rankings = rankings[:topN]
        }</span>

        <span class="cov1" title="1">return rankings</span>
}

// detectSuspiciousIPs returns IPs with low reputation scores
func (a *Analyzer) detectSuspiciousIPs() []string <span class="cov1" title="1">{
        suspicious := make([]string, 0)

        for ip, stats := range a.ipStats </span><span class="cov2" title="2">{
                // Flag IPs with reputation &lt; 50 and significant activity
                if stats.ReputationScore &lt; 50.0 &amp;&amp; stats.RequestCount &gt; 10 </span><span class="cov0" title="0">{
                        suspicious = append(suspicious, ip)
                }</span>
        }

        <span class="cov1" title="1">return suspicious</span>
}

// calculateBotTraffic calculates percentage of bot traffic
func (a *Analyzer) calculateBotTraffic() float64 <span class="cov1" title="1">{
        totalRequests := 0
        botRequests := 0

        for _, stats := range a.uaStats </span><span class="cov2" title="2">{
                totalRequests += stats.RequestCount
                if stats.IsBot </span><span class="cov0" title="0">{
                        botRequests += stats.RequestCount
                }</span>
        }

        <span class="cov1" title="1">if totalRequests == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov1" title="1">return float64(botRequests) / float64(totalRequests) * 100</span>
}

// detectAnomalies detects anomalous traffic patterns
func (a *Analyzer) detectAnomalies() []AnomalyDetection <span class="cov1" title="1">{
        anomalies := make([]AnomalyDetection, 0)
        now := time.Now().Unix()

        // Detect IPs with high error rates
        for ip, stats := range a.ipStats </span><span class="cov2" title="2">{
                if stats.RequestCount &gt; 20 </span><span class="cov0" title="0">{
                        errorRate := float64(stats.ErrorCount) / float64(stats.RequestCount) * 100
                        if errorRate &gt; 50 </span><span class="cov0" title="0">{
                                anomalies = append(anomalies, AnomalyDetection{
                                        Type:        "high_error_rate",
                                        Description: "IP has unusually high error rate",
                                        Severity:    "medium",
                                        IP:          ip,
                                        Timestamp:   now,
                                })
                        }</span>
                }

                // Detect rapid requests (potential attack)
                <span class="cov2" title="2">if stats.RequestCount &gt; 100 &amp;&amp; (now-stats.FirstSeen) &lt; 60 </span><span class="cov0" title="0">{
                        anomalies = append(anomalies, AnomalyDetection{
                                Type:        "rapid_requests",
                                Description: "IP made many requests in short time",
                                Severity:    "high",
                                IP:          ip,
                                Timestamp:   now,
                        })
                }</span>
        }

        // Detect paths with high error rates
        <span class="cov1" title="1">for path, stats := range a.pathStats </span><span class="cov2" title="2">{
                if stats.RequestCount &gt; 10 </span><span class="cov0" title="0">{
                        errorRate := float64(stats.ErrorCount) / float64(stats.RequestCount) * 100
                        if errorRate &gt; 75 </span><span class="cov0" title="0">{
                                anomalies = append(anomalies, AnomalyDetection{
                                        Type:        "high_error_rate",
                                        Description: "Path has unusually high error rate",
                                        Severity:    "high",
                                        Path:        path,
                                        Timestamp:   now,
                                })
                        }</span>
                }
        }

        <span class="cov1" title="1">return anomalies</span>
}

// detectTrafficPeaks detects traffic spikes in time slots
func (a *Analyzer) detectTrafficPeaks() []TrafficPeak <span class="cov1" title="1">{
        if len(a.timeSlots) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Calculate average requests per slot
        <span class="cov1" title="1">totalRequests := 0
        for _, slot := range a.timeSlots </span><span class="cov1" title="1">{
                totalRequests += slot.RequestCount
        }</span>
        <span class="cov1" title="1">avgRequests := float64(totalRequests) / float64(len(a.timeSlots))

        // Find slots with &gt; 2x average requests
        peaks := make([]TrafficPeak, 0)
        threshold := avgRequests * 2.0

        for _, slot := range a.timeSlots </span><span class="cov1" title="1">{
                if float64(slot.RequestCount) &gt; threshold </span><span class="cov0" title="0">{
                        peaks = append(peaks, TrafficPeak{
                                Timestamp:    slot.Timestamp,
                                RequestCount: slot.RequestCount,
                                UniqueIPs:    slot.UniqueIPs,
                        })
                }</span>
        }

        // Sort by timestamp
        <span class="cov1" title="1">sort.Slice(peaks, func(i, j int) bool </span><span class="cov0" title="0">{
                return peaks[i].Timestamp &gt; peaks[j].Timestamp
        }</span>)

        <span class="cov1" title="1">return peaks</span>
}

// detectBot checks if user agent string indicates a bot
func (a *Analyzer) detectBot(userAgent string) bool <span class="cov4" title="4">{
        ua := strings.ToLower(userAgent)
        botKeywords := []string{
                "bot", "crawler", "spider", "scraper", "curl", "wget",
                "python", "java", "ruby", "perl", "go-http-client",
        }

        for _, keyword := range botKeywords </span><span class="cov10" title="44">{
                if strings.Contains(ua, keyword) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov4" title="4">return false</span>
}

// parseUserAgent extracts browser and OS from user agent string
func (a *Analyzer) parseUserAgent(stats *UserAgentStats, userAgent string) <span class="cov4" title="4">{
        ua := strings.ToLower(userAgent)

        // Simple browser detection
        if strings.Contains(ua, "chrome") </span><span class="cov0" title="0">{
                stats.Browser = "Chrome"
        }</span> else<span class="cov4" title="4"> if strings.Contains(ua, "firefox") </span><span class="cov0" title="0">{
                stats.Browser = "Firefox"
        }</span> else<span class="cov4" title="4"> if strings.Contains(ua, "safari") </span><span class="cov0" title="0">{
                stats.Browser = "Safari"
        }</span> else<span class="cov4" title="4"> if strings.Contains(ua, "edge") </span><span class="cov0" title="0">{
                stats.Browser = "Edge"
        }</span>

        // Simple OS detection
        <span class="cov4" title="4">if strings.Contains(ua, "windows") </span><span class="cov0" title="0">{
                stats.OS = "Windows"
        }</span> else<span class="cov4" title="4"> if strings.Contains(ua, "mac") || strings.Contains(ua, "darwin") </span><span class="cov0" title="0">{
                stats.OS = "macOS"
        }</span> else<span class="cov4" title="4"> if strings.Contains(ua, "linux") </span><span class="cov0" title="0">{
                stats.OS = "Linux"
        }</span> else<span class="cov4" title="4"> if strings.Contains(ua, "android") </span><span class="cov0" title="0">{
                stats.OS = "Android"
        }</span> else<span class="cov4" title="4"> if strings.Contains(ua, "iphone") || strings.Contains(ua, "ipad") </span><span class="cov0" title="0">{
                stats.OS = "iOS"
        }</span>
}

// cleanupOldData removes data outside the time window
func (a *Analyzer) cleanupOldData() <span class="cov4" title="4">{
        for range a.cleanupTicker.C </span><span class="cov0" title="0">{
                a.mu.Lock()

                cutoff := time.Now().Add(-a.windowSize).Unix()

                // Clean up IP stats
                for ip, stats := range a.ipStats </span><span class="cov0" title="0">{
                        if stats.LastSeen &lt; cutoff </span><span class="cov0" title="0">{
                                delete(a.ipStats, ip)
                        }</span>
                }

                // Clean up user agent stats
                <span class="cov0" title="0">for ua, stats := range a.uaStats </span><span class="cov0" title="0">{
                        if stats.LastSeen &lt; cutoff </span><span class="cov0" title="0">{
                                delete(a.uaStats, ua)
                        }</span>
                }

                // Clean up time slots
                <span class="cov0" title="0">for ts := range a.timeSlots </span><span class="cov0" title="0">{
                        if ts &lt; cutoff </span><span class="cov0" title="0">{
                                delete(a.timeSlots, ts)
                        }</span>
                }

                <span class="cov0" title="0">a.mu.Unlock()

                log.Debug().
                        Int("ip_stats", len(a.ipStats)).
                        Int("ua_stats", len(a.uaStats)).
                        Int("path_stats", len(a.pathStats)).
                        Int("time_slots", len(a.timeSlots)).
                        Msg("Traffic analyzer cleanup complete")</span>
        }
}

// Stop stops the cleanup ticker
func (a *Analyzer) Stop() <span class="cov0" title="0">{
        if a.cleanupTicker != nil </span><span class="cov0" title="0">{
                a.cleanupTicker.Stop()
        }</span>
}

// GetIPReputation returns the reputation score for an IP
func (a *Analyzer) GetIPReputation(ip string) float64 <span class="cov1" title="1">{
        a.mu.RLock()
        defer a.mu.RUnlock()

        if stats, exists := a.ipStats[ip]; exists </span><span class="cov1" title="1">{
                return stats.ReputationScore
        }</span>
        <span class="cov0" title="0">return 100.0</span> // Default: innocent until proven guilty
}

// IsPrivateIP checks if an IP is in a private range
func IsPrivateIP(ip string) bool <span class="cov0" title="0">{
        parsedIP := net.ParseIP(ip)
        if parsedIP == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">privateRanges := []string{
                "10.0.0.0/8",
                "172.16.0.0/12",
                "192.168.0.0/16",
                "127.0.0.0/8",
                "169.254.0.0/16",
                "::1/128",
                "fc00::/7",
        }

        for _, cidr := range privateRanges </span><span class="cov0" title="0">{
                _, ipNet, _ := net.ParseCIDR(cidr)
                if ipNet.Contains(parsedIP) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

func max(a, b float64) float64 <span class="cov2" title="2">{
        if a &gt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov2" title="2">return b</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package updater

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "log"
        "net/http"
        "os"
        "strings"
        "time"
)

type CloudflareUpdater struct {
        interval        time.Duration
        nginxController NginxController
        debug           bool
        configPath      string
        lastIPs         string
}

type NginxController interface {
        ScheduleReload(reason string)
}

type cloudflareResponse struct {
        Result struct {
                IPv4CIDRs []string `json:"ipv4_cidrs"`
                IPv6CIDRs []string `json:"ipv6_cidrs"`
        } `json:"result"`
}

func NewCloudflareUpdater(interval time.Duration, nginxCtrl NginxController, debug bool) *CloudflareUpdater <span class="cov0" title="0">{
        return &amp;CloudflareUpdater{
                interval:        interval,
                nginxController: nginxCtrl,
                debug:           debug,
                configPath:      "/etc/nginx/cloudflare-realip.conf",
        }
}</span>

func (u *CloudflareUpdater) Start(ctx context.Context) <span class="cov0" title="0">{
        log.Println("[cf-updater] Starting Cloudflare IP updater")

        // Initial update
        u.updateCloudflareIPs()

        ticker := time.NewTicker(u.interval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        log.Println("[cf-updater] Stopping Cloudflare IP updater")
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        u.updateCloudflareIPs()</span>
                }
        }
}

func (u *CloudflareUpdater) updateCloudflareIPs() <span class="cov0" title="0">{
        if u.debug </span><span class="cov0" title="0">{
                log.Println("[cf-updater] Fetching Cloudflare IP ranges")
        }</span>

        // Fetch IP ranges from Cloudflare API
        <span class="cov0" title="0">ipv4Ranges, err := u.fetchIPRanges("https://api.cloudflare.com/client/v4/ips")
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[cf-updater] Failed to fetch Cloudflare IPs: %s", err)
                return
        }</span>

        // Generate configuration content
        <span class="cov0" title="0">var configLines []string
        configLines = append(configLines, "# Cloudflare IP ranges - auto-generated")
        configLines = append(configLines, fmt.Sprintf("# Last updated: %s", time.Now().Format(time.RFC3339)))
        configLines = append(configLines, "")

        for _, cidr := range ipv4Ranges </span><span class="cov0" title="0">{
                configLines = append(configLines, fmt.Sprintf("set_real_ip_from %s;", cidr))
        }</span>

        <span class="cov0" title="0">configLines = append(configLines, "")
        configLines = append(configLines, "real_ip_header CF-Connecting-IP;")

        newContent := strings.Join(configLines, "\n") + "\n"

        // Check if content changed
        if newContent == u.lastIPs </span><span class="cov0" title="0">{
                if u.debug </span><span class="cov0" title="0">{
                        log.Println("[cf-updater] Cloudflare IPs unchanged")
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // Write configuration file
        <span class="cov0" title="0">if err := os.WriteFile(u.configPath, []byte(newContent), 0644); err != nil </span><span class="cov0" title="0">{
                log.Printf("[cf-updater] Failed to write config: %s", err)
                return
        }</span>

        <span class="cov0" title="0">log.Printf("[cf-updater] Updated Cloudflare IP ranges (%d ranges)", len(ipv4Ranges))
        u.lastIPs = newContent
        u.nginxController.ScheduleReload("cloudflare IPs updated")</span>
}

func (u *CloudflareUpdater) fetchIPRanges(url string) ([]string, error) <span class="cov0" title="0">{
        client := &amp;http.Client{Timeout: 10 * time.Second}

        resp, err := client.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var cfResp cloudflareResponse
        if err := json.Unmarshal(body, &amp;cfResp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Combine IPv4 and IPv6 ranges
        <span class="cov0" title="0">allRanges := append(cfResp.Result.IPv4CIDRs, cfResp.Result.IPv6CIDRs...)

        if len(allRanges) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no IP ranges returned from Cloudflare API")
        }</span>

        <span class="cov0" title="0">return allRanges, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package waf

import (
        "context"
        "fmt"
        "net/http"
        "net/url"
        "regexp"
        "strings"

        "github.com/rs/zerolog/log"
)

// Config holds WAF configuration
type Config struct {
        Enabled      bool
        Sensitivity  string   // low, medium, high
        BlockMode    bool     // true = block, false = log only
        CheckPath    bool     // Check URL path
        CheckHeaders bool     // Check HTTP headers
        CheckQuery   bool     // Check query parameters
        CheckBody    bool     // Check request body
        MaxBodySize  int64    // Max body size to inspect (bytes)
        Whitelist    []string // Whitelisted IPs/CIDRs
        CustomRules  []Rule   // Custom detection rules
}

// Rule represents a custom WAF rule
type Rule struct {
        Name        string
        Pattern     *regexp.Regexp
        Description string
        Severity    string // low, medium, high, critical
}

// WAF implements Web Application Firewall
type WAF struct {
        config    Config
        db        Database
        rules     []Rule
        whitelist map[string]bool
}

// Database interface for logging blocks
type Database interface {
        LogWAFBlock(ip, route, attackType, payload, userAgent string) error
}

// AttackType constants
const (
        AttackSQLInjection  = "sql_injection"
        AttackXSS           = "xss"
        AttackPathTraversal = "path_traversal"
        AttackCommandInj    = "command_injection"
        AttackLDAPInjection = "ldap_injection"
        AttackXMLInjection  = "xml_injection"
)

// NewWAF creates a new WAF instance
func NewWAF(config Config, db Database) *WAF <span class="cov5" title="5">{
        if config.MaxBodySize == 0 </span><span class="cov5" title="5">{
                config.MaxBodySize = 1024 * 1024 // 1 MB default
        }</span>

        <span class="cov5" title="5">waf := &amp;WAF{
                config:    config,
                db:        db,
                whitelist: make(map[string]bool),
        }

        // Initialize built-in rules
        waf.initRules()

        // Add custom rules
        waf.rules = append(waf.rules, config.CustomRules...)

        // Initialize whitelist
        for _, ip := range config.Whitelist </span><span class="cov0" title="0">{
                waf.whitelist[ip] = true
        }</span>

        <span class="cov5" title="5">return waf</span>
}

// initRules initializes built-in detection rules
func (w *WAF) initRules() <span class="cov5" title="5">{
        w.rules = []Rule{
                // SQL Injection patterns
                {
                        Name:        "sql_union",
                        Pattern:     regexp.MustCompile(`(?i)(union\s+select|union\s+all\s+select)`),
                        Description: "SQL UNION injection attempt",
                        Severity:    "high",
                },
                {
                        Name:        "sql_comment",
                        Pattern:     regexp.MustCompile(`(?i)(--|\#|\/\*|\*\/)`),
                        Description: "SQL comment injection",
                        Severity:    "medium",
                },
                {
                        Name:        "sql_keywords",
                        Pattern:     regexp.MustCompile(`(?i)(;|\s)(drop|delete|update|insert|alter|create|exec|execute)\s+(table|database|index|view)`),
                        Description: "Dangerous SQL keywords",
                        Severity:    "critical",
                },
                {
                        Name:        "sql_always_true",
                        Pattern:     regexp.MustCompile(`(?i)('|\"|;)?\s*(or|and)\s+('|\")?\s*\d+\s*=\s*\d+`),
                        Description: "SQL always-true condition (1=1)",
                        Severity:    "high",
                },
                {
                        Name:        "sql_sleep",
                        Pattern:     regexp.MustCompile(`(?i)(sleep|benchmark|waitfor\s+delay)`),
                        Description: "SQL time-based injection",
                        Severity:    "high",
                },

                // XSS patterns
                {
                        Name:        "xss_script_tag",
                        Pattern:     regexp.MustCompile(`(?i)&lt;script[^&gt;]*&gt;.*?&lt;/script&gt;`),
                        Description: "Script tag injection",
                        Severity:    "high",
                },
                {
                        Name:        "xss_event_handler",
                        Pattern:     regexp.MustCompile(`(?i)on(load|error|click|mouse|focus|blur|change|submit)\s*=`),
                        Description: "Event handler injection",
                        Severity:    "high",
                },
                {
                        Name:        "xss_javascript_protocol",
                        Pattern:     regexp.MustCompile(`(?i)javascript\s*:`),
                        Description: "JavaScript protocol handler",
                        Severity:    "medium",
                },
                {
                        Name:        "xss_iframe",
                        Pattern:     regexp.MustCompile(`(?i)&lt;iframe[^&gt;]*&gt;`),
                        Description: "Iframe injection",
                        Severity:    "medium",
                },
                {
                        Name:        "xss_object_embed",
                        Pattern:     regexp.MustCompile(`(?i)&lt;(object|embed|applet)[^&gt;]*&gt;`),
                        Description: "Object/Embed tag injection",
                        Severity:    "medium",
                },

                // Path Traversal patterns
                {
                        Name:        "path_traversal_basic",
                        Pattern:     regexp.MustCompile(`\.\.(/|\\)`),
                        Description: "Path traversal attempt (../)",
                        Severity:    "high",
                },
                {
                        Name:        "path_traversal_encoded",
                        Pattern:     regexp.MustCompile(`(%2e%2e|%252e%252e|\.\.%2f|\.\.%5c)`),
                        Description: "Encoded path traversal",
                        Severity:    "high",
                },
                {
                        Name:        "path_traversal_absolute",
                        Pattern:     regexp.MustCompile(`(?i)(^|[^a-z0-9])(/etc/passwd|/etc/shadow|c:\\windows\\system32)`),
                        Description: "Absolute path to sensitive files",
                        Severity:    "critical",
                },

                // Command Injection patterns
                {
                        Name:        "command_injection",
                        Pattern:     regexp.MustCompile(`[;&amp;|]\s*(ls|cat|wget|curl|nc|bash|sh|cmd|powershell)`),
                        Description: "Shell command injection",
                        Severity:    "critical",
                },
                {
                        Name:        "command_backticks",
                        Pattern:     regexp.MustCompile("`[^`]+`"),
                        Description: "Backtick command execution",
                        Severity:    "high",
                },

                // LDAP Injection patterns
                {
                        Name:        "ldap_injection",
                        Pattern:     regexp.MustCompile(`\*\)|\(\|`),
                        Description: "LDAP filter injection",
                        Severity:    "high",
                },

                // XML Injection patterns
                {
                        Name:        "xml_entity",
                        Pattern:     regexp.MustCompile(`(?i)&lt;!entity`),
                        Description: "XML entity injection (XXE)",
                        Severity:    "critical",
                },
        }
}</span>

// Middleware returns HTTP middleware for WAF protection
func (w *WAF) Middleware(route string) func(http.Handler) http.Handler <span class="cov4" title="4">{
        return func(next http.Handler) http.Handler </span><span class="cov4" title="4">{
                return http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) </span><span class="cov4" title="4">{
                        if !w.config.Enabled </span><span class="cov0" title="0">{
                                next.ServeHTTP(rw, r)
                                return
                        }</span>

                        <span class="cov4" title="4">ip := extractIP(r)

                        // Check whitelist
                        if w.whitelist[ip] </span><span class="cov0" title="0">{
                                next.ServeHTTP(rw, r)
                                return
                        }</span>

                        // Check for attacks
                        <span class="cov4" title="4">if blocked, attackType, payload := w.checkRequest(r, route); blocked </span><span class="cov4" title="4">{
                                // Log to database
                                if w.db != nil </span><span class="cov4" title="4">{
                                        w.db.LogWAFBlock(ip, route, attackType, payload, r.UserAgent())
                                }</span>

                                <span class="cov4" title="4">log.Warn().
                                        Str("ip", ip).
                                        Str("route", route).
                                        Str("attack_type", attackType).
                                        Str("payload", truncate(payload, 100)).
                                        Msg("WAF blocked attack")

                                if w.config.BlockMode </span><span class="cov3" title="3">{
                                        http.Error(rw, "Forbidden", http.StatusForbidden)
                                        return
                                }</span> else<span class="cov1" title="1"> {
                                        log.Info().Msg("WAF in log-only mode, allowing request")
                                }</span>
                        }

                        <span class="cov1" title="1">next.ServeHTTP(rw, r)</span>
                })
        }
}

// checkRequest checks a request for malicious patterns
func (w *WAF) checkRequest(r *http.Request, route string) (blocked bool, attackType string, payload string) <span class="cov4" title="4">{
        // Check URL path
        if w.config.CheckPath </span><span class="cov2" title="2">{
                if matched, aType, p := w.checkString(r.URL.Path); matched </span><span class="cov2" title="2">{
                        return true, aType, p
                }</span>
        }

        // Check query parameters
        <span class="cov2" title="2">if w.config.CheckQuery </span><span class="cov1" title="1">{
                for key, values := range r.URL.Query() </span><span class="cov1" title="1">{
                        for _, value := range values </span><span class="cov1" title="1">{
                                if matched, aType, p := w.checkString(value); matched </span><span class="cov1" title="1">{
                                        return true, aType, fmt.Sprintf("%s=%s", key, p)
                                }</span>
                        }
                }
        }

        // Check headers
        <span class="cov1" title="1">if w.config.CheckHeaders </span><span class="cov1" title="1">{
                for key, values := range r.Header </span><span class="cov1" title="1">{
                        // Skip common safe headers
                        if isSafeHeader(key) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov1" title="1">for _, value := range values </span><span class="cov1" title="1">{
                                if matched, aType, p := w.checkString(value); matched </span><span class="cov1" title="1">{
                                        return true, aType, fmt.Sprintf("%s: %s", key, p)
                                }</span>
                        }
                }
        }

        // Check request body (for POST/PUT)
        <span class="cov0" title="0">if w.config.CheckBody &amp;&amp; (r.Method == "POST" || r.Method == "PUT" || r.Method == "PATCH") </span><span class="cov0" title="0">{
                if r.ContentLength &gt; 0 &amp;&amp; r.ContentLength &lt;= w.config.MaxBodySize </span><span class="cov0" title="0">{
                        body := make([]byte, r.ContentLength)
                        n, err := r.Body.Read(body)
                        if err == nil &amp;&amp; n &gt; 0 </span><span class="cov0" title="0">{
                                if matched, aType, p := w.checkString(string(body[:n])); matched </span><span class="cov0" title="0">{
                                        return true, aType, p
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return false, "", ""</span>
}

// checkString checks a string against all WAF rules
func (w *WAF) checkString(input string) (matched bool, attackType string, payload string) <span class="cov4" title="4">{
        // Decode URL encoding to catch encoded attacks
        decoded, err := url.QueryUnescape(input)
        if err != nil </span><span class="cov0" title="0">{
                decoded = input
        }</span>

        // Check both original and decoded
        <span class="cov4" title="4">for _, str := range []string{input, decoded} </span><span class="cov4" title="4">{
                for _, rule := range w.rules </span><span class="cov10" title="31">{
                        if rule.Pattern.MatchString(str) </span><span class="cov4" title="4">{
                                // Determine attack type based on rule name
                                aType := w.categorizeRule(rule.Name)

                                // Extract matched portion
                                match := rule.Pattern.FindString(str)

                                return true, aType, match
                        }</span>
                }
        }

        <span class="cov0" title="0">return false, "", ""</span>
}

// categorizeRule determines attack type from rule name
func (w *WAF) categorizeRule(ruleName string) string <span class="cov4" title="4">{
        if strings.HasPrefix(ruleName, "sql_") </span><span class="cov0" title="0">{
                return AttackSQLInjection
        }</span>
        <span class="cov4" title="4">if strings.HasPrefix(ruleName, "xss_") </span><span class="cov3" title="3">{
                return AttackXSS
        }</span>
        <span class="cov1" title="1">if strings.HasPrefix(ruleName, "path_") </span><span class="cov1" title="1">{
                return AttackPathTraversal
        }</span>
        <span class="cov0" title="0">if strings.HasPrefix(ruleName, "command_") </span><span class="cov0" title="0">{
                return AttackCommandInj
        }</span>
        <span class="cov0" title="0">if strings.HasPrefix(ruleName, "ldap_") </span><span class="cov0" title="0">{
                return AttackLDAPInjection
        }</span>
        <span class="cov0" title="0">if strings.HasPrefix(ruleName, "xml_") </span><span class="cov0" title="0">{
                return AttackXMLInjection
        }</span>
        <span class="cov0" title="0">return "unknown"</span>
}

// GetStats returns WAF statistics
func (w *WAF) GetStats() map[string]interface{} <span class="cov1" title="1">{
        return map[string]interface{}{
                "enabled":        w.config.Enabled,
                "block_mode":     w.config.BlockMode,
                "sensitivity":    w.config.Sensitivity,
                "rules_count":    len(w.rules),
                "whitelist_size": len(w.whitelist),
                "checks": map[string]bool{
                        "path":    w.config.CheckPath,
                        "headers": w.config.CheckHeaders,
                        "query":   w.config.CheckQuery,
                        "body":    w.config.CheckBody,
                },
        }
}</span>

// isSafeHeader checks if a header is safe to skip
func isSafeHeader(header string) bool <span class="cov1" title="1">{
        safeHeaders := map[string]bool{
                "accept":            true,
                "accept-encoding":   true,
                "accept-language":   true,
                "cache-control":     true,
                "connection":        true,
                "content-length":    true,
                "content-type":      true,
                "host":              true,
                "user-agent":        true,
                "x-forwarded-for":   true,
                "x-forwarded-host":  true,
                "x-forwarded-proto": true,
                "x-real-ip":         true,
                "x-request-id":      true,
        }
        return safeHeaders[strings.ToLower(header)]
}</span>

// extractIP extracts the client IP from the request
func extractIP(r *http.Request) string <span class="cov4" title="4">{
        if ip := r.Header.Get("X-Real-IP"); ip != "" </span><span class="cov0" title="0">{
                return ip
        }</span>
        <span class="cov4" title="4">if xff := r.Header.Get("X-Forwarded-For"); xff != "" </span><span class="cov0" title="0">{
                parts := strings.Split(xff, ",")
                if len(parts) &gt; 0 </span><span class="cov0" title="0">{
                        return strings.TrimSpace(parts[0])
                }</span>
        }
        <span class="cov4" title="4">ip := r.RemoteAddr
        if idx := strings.LastIndex(ip, ":"); idx != -1 </span><span class="cov4" title="4">{
                ip = ip[:idx]
        }</span>
        <span class="cov4" title="4">return ip</span>
}

// truncate truncates a string to maxLen
func truncate(s string, maxLen int) string <span class="cov4" title="4">{
        if len(s) &lt;= maxLen </span><span class="cov4" title="4">{
                return s
        }</span>
        <span class="cov0" title="0">return s[:maxLen] + "..."</span>
}

// Start starts background tasks (currently none needed)
func (w *WAF) Start(ctx context.Context) <span class="cov0" title="0">{
        // Future: Could add background tasks for:
        // - Updating threat intelligence feeds
        // - Analyzing attack patterns
        // - Auto-tuning sensitivity
        log.Info().Bool("enabled", w.config.Enabled).Msg("WAF initialized")
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package watcher

import (
        "context"
        "crypto/tls"
        "log"
        "path/filepath"
        "time"

        "github.com/chilla55/proxy-manager/config"
        "github.com/chilla55/proxy-manager/proxy"
        "github.com/fsnotify/fsnotify"
)

// CertWatcher watches certificate files for changes and reloads them
type CertWatcher struct {
        globalConfigPath string
        proxyServer      *proxy.Server
        debug            bool
        lastReload       time.Time
        reloadCooldown   time.Duration
}

// NewCertWatcher creates a new certificate watcher
func NewCertWatcher(globalConfigPath string, proxyServer *proxy.Server, debug bool) *CertWatcher <span class="cov0" title="0">{
        return &amp;CertWatcher{
                globalConfigPath: globalConfigPath,
                proxyServer:      proxyServer,
                debug:            debug,
                reloadCooldown:   5 * time.Second, // Prevent rapid reloads
        }
}</span>

// Start starts watching certificate files
func (w *CertWatcher) Start(ctx context.Context) error <span class="cov0" title="0">{
        watcher, err := fsnotify.NewWatcher()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer watcher.Close()

        // Load global config to get certificate paths
        globalCfg, err := config.LoadGlobalConfig(w.globalConfigPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Watch all certificate directories
        <span class="cov0" title="0">certDirs := make(map[string]bool)
        for _, certCfg := range globalCfg.TLS.Certificates </span><span class="cov0" title="0">{
                certDir := filepath.Dir(certCfg.CertFile)
                if !certDirs[certDir] </span><span class="cov0" title="0">{
                        if err := watcher.Add(certDir); err != nil </span><span class="cov0" title="0">{
                                log.Printf("[cert-watcher] Warning: Cannot watch %s: %s", certDir, err)
                        }</span> else<span class="cov0" title="0"> {
                                certDirs[certDir] = true
                                if w.debug </span><span class="cov0" title="0">{
                                        log.Printf("[cert-watcher] Watching certificate directory: %s", certDir)
                                }</span>
                        }
                }

                <span class="cov0" title="0">keyDir := filepath.Dir(certCfg.KeyFile)
                if !certDirs[keyDir] &amp;&amp; keyDir != certDir </span><span class="cov0" title="0">{
                        if err := watcher.Add(keyDir); err != nil </span><span class="cov0" title="0">{
                                log.Printf("[cert-watcher] Warning: Cannot watch %s: %s", keyDir, err)
                        }</span> else<span class="cov0" title="0"> {
                                certDirs[keyDir] = true
                                if w.debug </span><span class="cov0" title="0">{
                                        log.Printf("[cert-watcher] Watching key directory: %s", keyDir)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">if len(certDirs) == 0 </span><span class="cov0" title="0">{
                log.Println("[cert-watcher] No certificate directories to watch")
                return nil
        }</span>

        <span class="cov0" title="0">log.Printf("[cert-watcher] Started watching %d certificate directories", len(certDirs))

        // Periodic reload check (every 5 minutes) as backup
        ticker := time.NewTicker(5 * time.Minute)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        log.Println("[cert-watcher] Stopping certificate watcher")
                        return nil</span>

                case &lt;-ticker.C:<span class="cov0" title="0">
                        if w.debug </span><span class="cov0" title="0">{
                                log.Println("[cert-watcher] Periodic certificate check")
                        }</span>
                        <span class="cov0" title="0">w.reloadCertificates()</span>

                case event, ok := &lt;-watcher.Events:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                return nil
                        }</span>

                        // Watch for WRITE and CREATE events (certbot writes new files)
                        <span class="cov0" title="0">if event.Op&amp;fsnotify.Write == fsnotify.Write || event.Op&amp;fsnotify.Create == fsnotify.Create </span><span class="cov0" title="0">{
                                // Check if it's a certificate or key file
                                if w.isCertFile(event.Name, globalCfg) </span><span class="cov0" title="0">{
                                        if w.debug </span><span class="cov0" title="0">{
                                                log.Printf("[cert-watcher] Certificate file changed: %s", event.Name)
                                        }</span>

                                        // Debounce: wait a bit for certbot to finish writing all files
                                        <span class="cov0" title="0">time.Sleep(2 * time.Second)
                                        w.reloadCertificates()</span>
                                }
                        }

                case err, ok := &lt;-watcher.Errors:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">log.Printf("[cert-watcher] Error: %s", err)</span>
                }
        }
}

// isCertFile checks if the file is a certificate or key we're watching
func (w *CertWatcher) isCertFile(path string, cfg *config.GlobalConfig) bool <span class="cov0" title="0">{
        filename := filepath.Base(path)

        // Check if it's a fullchain.pem or privkey.pem (Let's Encrypt names)
        if filename == "fullchain.pem" || filename == "privkey.pem" </span><span class="cov0" title="0">{
                return true
        }</span>

        // Check if it matches any configured cert/key path
        <span class="cov0" title="0">for _, certCfg := range cfg.TLS.Certificates </span><span class="cov0" title="0">{
                if path == certCfg.CertFile || path == certCfg.KeyFile </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// reloadCertificates reloads all certificates from disk
func (w *CertWatcher) reloadCertificates() <span class="cov0" title="0">{
        // Cooldown check to prevent rapid reloads
        if time.Since(w.lastReload) &lt; w.reloadCooldown </span><span class="cov0" title="0">{
                if w.debug </span><span class="cov0" title="0">{
                        log.Println("[cert-watcher] Skipping reload (cooldown active)")
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">log.Println("[cert-watcher] Reloading certificates from disk...")
        w.lastReload = time.Now()

        // Load global config
        globalCfg, err := config.LoadGlobalConfig(w.globalConfigPath)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[cert-watcher] Failed to load global config: %s", err)
                return
        }</span>

        // Load certificates
        <span class="cov0" title="0">certificates := make([]proxy.CertMapping, 0, len(globalCfg.TLS.Certificates))
        for i, certCfg := range globalCfg.TLS.Certificates </span><span class="cov0" title="0">{
                cert, err := tls.LoadX509KeyPair(certCfg.CertFile, certCfg.KeyFile)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("[cert-watcher] Failed to load certificate %d (%s): %s", i+1, certCfg.CertFile, err)
                        continue</span>
                }

                <span class="cov0" title="0">if len(certCfg.Domains) == 0 </span><span class="cov0" title="0">{
                        log.Printf("[cert-watcher] Certificate %d has no domains defined", i+1)
                        continue</span>
                }

                <span class="cov0" title="0">mapping := proxy.CertMapping{
                        Domains: certCfg.Domains,
                        Cert:    cert,
                }

                certificates = append(certificates, mapping)
                if w.debug </span><span class="cov0" title="0">{
                        log.Printf("[cert-watcher] Loaded certificate for domains: %v", certCfg.Domains)
                }</span>
        }

        <span class="cov0" title="0">if len(certificates) == 0 </span><span class="cov0" title="0">{
                log.Println("[cert-watcher] Warning: No certificates loaded!")
                return
        }</span>

        // Update certificates in proxy server
        <span class="cov0" title="0">w.proxyServer.UpdateCertificates(certificates)
        log.Printf("[cert-watcher] Successfully reloaded %d certificate(s)", len(certificates))</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package watcher

import (
        "context"
        "log"
        "path/filepath"
        "time"

        "github.com/chilla55/proxy-manager/config"
        "github.com/fsnotify/fsnotify"
)

type ProxyServer interface {
        AddRoute(domains []string, path, backendURL string, headers map[string]string, websocket bool, options map[string]interface{}) error
        RemoveRoute(domains []string, path string)
}

type SiteWatcher struct {
        sitesPath   string
        proxyServer ProxyServer
        debug       bool
        loadedSites map[string]*config.SiteConfig // filename -&gt; config
}

func NewSiteWatcher(sitesPath string, proxyServer ProxyServer, debug bool) *SiteWatcher <span class="cov0" title="0">{
        return &amp;SiteWatcher{
                sitesPath:   sitesPath,
                proxyServer: proxyServer,
                debug:       debug,
                loadedSites: make(map[string]*config.SiteConfig),
        }
}</span>

func (w *SiteWatcher) Start(ctx context.Context) <span class="cov0" title="0">{
        // Initial load of all site configs
        w.loadAllSites()

        // Watch for changes
        watcher, err := fsnotify.NewWatcher()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[watcher] Failed to create file watcher: %s", err)
                return
        }</span>
        <span class="cov0" title="0">defer watcher.Close()

        if err := watcher.Add(w.sitesPath); err != nil </span><span class="cov0" title="0">{
                log.Printf("[watcher] Failed to watch directory: %s", err)
                return
        }</span>

        <span class="cov0" title="0">log.Printf("[watcher] Watching %s for YAML config changes", w.sitesPath)

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case event, ok := &lt;-watcher.Events:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">if event.Op&amp;(fsnotify.Write|fsnotify.Create) != 0 </span><span class="cov0" title="0">{
                                if filepath.Ext(event.Name) == ".yaml" || filepath.Ext(event.Name) == ".yml" </span><span class="cov0" title="0">{
                                        w.reloadSite(event.Name)
                                }</span>
                        } else<span class="cov0" title="0"> if event.Op&amp;fsnotify.Remove != 0 </span><span class="cov0" title="0">{
                                if filepath.Ext(event.Name) == ".yaml" || filepath.Ext(event.Name) == ".yml" </span><span class="cov0" title="0">{
                                        w.removeSite(event.Name)
                                }</span>
                        }
                case err, ok := &lt;-watcher.Errors:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">log.Printf("[watcher] Error: %s", err)</span>
                }
        }
}

func (w *SiteWatcher) loadAllSites() <span class="cov0" title="0">{
        files, err := filepath.Glob(filepath.Join(w.sitesPath, "*.yaml"))
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[watcher] Failed to list YAML files: %s", err)
                return
        }</span>

        <span class="cov0" title="0">ymlFiles, err := filepath.Glob(filepath.Join(w.sitesPath, "*.yml"))
        if err == nil </span><span class="cov0" title="0">{
                files = append(files, ymlFiles...)
        }</span>

        <span class="cov0" title="0">for _, file := range files </span><span class="cov0" title="0">{
                w.loadSite(file)
        }</span>
}

func (w *SiteWatcher) loadSite(filename string) <span class="cov0" title="0">{
        cfg, err := config.LoadSiteConfig(filename)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[watcher] Failed to load %s: %s", filename, err)
                return
        }</span>

        // Check if enabled
        <span class="cov0" title="0">if !cfg.Enabled </span><span class="cov0" title="0">{
                if w.debug </span><span class="cov0" title="0">{
                        log.Printf("[watcher] Skipping disabled site: %s", filename)
                }</span>
                // If it was previously loaded, remove it
                <span class="cov0" title="0">if oldCfg, exists := w.loadedSites[filename]; exists </span><span class="cov0" title="0">{
                        w.removeSiteRoutes(oldCfg)
                        delete(w.loadedSites, filename)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // Validate config
        <span class="cov0" title="0">if err := cfg.Validate(); err != nil </span><span class="cov0" title="0">{
                log.Printf("[watcher] Invalid config in %s: %s", filename, err)
                return
        }</span>

        // Get parsed options
        <span class="cov0" title="0">options, err := cfg.GetOptions()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[watcher] Invalid options in %s: %s", filename, err)
                return
        }</span>

        // Remove old routes if this site was previously loaded
        <span class="cov0" title="0">if oldCfg, exists := w.loadedSites[filename]; exists </span><span class="cov0" title="0">{
                w.removeSiteRoutes(oldCfg)
        }</span>

        // Add all routes
        <span class="cov0" title="0">for _, route := range cfg.Routes </span><span class="cov0" title="0">{
                // Merge global headers with route-specific headers
                headers := make(map[string]string)
                for k, v := range cfg.Headers </span><span class="cov0" title="0">{
                        headers[k] = v
                }</span>
                <span class="cov0" title="0">for k, v := range route.Headers </span><span class="cov0" title="0">{
                        headers[k] = v
                }</span>

                <span class="cov0" title="0">err := w.proxyServer.AddRoute(
                        route.Domains,
                        route.Path,
                        route.Backend,
                        headers,
                        route.WebSocket,
                        options,
                )

                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("[watcher] Failed to add route for %s: %s", filename, err)
                        continue</span>
                }

                <span class="cov0" title="0">if w.debug </span><span class="cov0" title="0">{
                        log.Printf("[watcher] Loaded route: %v%s -&gt; %s from %s",
                                route.Domains, route.Path, route.Backend, filepath.Base(filename))
                }</span>
        }

        // Store loaded config
        <span class="cov0" title="0">w.loadedSites[filename] = cfg
        log.Printf("[watcher] Loaded site config: %s (%d routes)", filepath.Base(filename), len(cfg.Routes))</span>
}

func (w *SiteWatcher) reloadSite(filename string) <span class="cov0" title="0">{
        // Small delay to ensure file write is complete
        time.Sleep(100 * time.Millisecond)

        if w.debug </span><span class="cov0" title="0">{
                log.Printf("[watcher] Reloading %s", filepath.Base(filename))
        }</span>

        <span class="cov0" title="0">w.loadSite(filename)</span>
}

func (w *SiteWatcher) removeSite(filename string) <span class="cov0" title="0">{
        cfg, exists := w.loadedSites[filename]
        if !exists </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">w.removeSiteRoutes(cfg)
        delete(w.loadedSites, filename)

        log.Printf("[watcher] Removed site config: %s", filepath.Base(filename))</span>
}

func (w *SiteWatcher) removeSiteRoutes(cfg *config.SiteConfig) <span class="cov0" title="0">{
        for _, route := range cfg.Routes </span><span class="cov0" title="0">{
                w.proxyServer.RemoveRoute(route.Domains, route.Path)

                if w.debug </span><span class="cov0" title="0">{
                        log.Printf("[watcher] Removed route: %v%s", route.Domains, route.Path)
                }</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
