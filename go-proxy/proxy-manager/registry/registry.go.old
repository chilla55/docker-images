package registry

import (
	"bufio"
	"context"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"log"
	"net"
	"strings"
	"sync"
	"time"
// Service represents a registered service with persistent connection
type Service struct {
	Name            string
	Hostname        string
	Port            int
	MaintenancePort int
	Connection      net.Conn
	Connected       time.Time
	RegistrationType string // "persistent", "template", "config"
	Config          string  // Custom config if provided
	ConfigHash      string  // SHA256 hash of config for validation
	SessionID       string  // For reconnect validation
}Config          string  // Custom config if provided
	SessionID       string  // For reconnect validation
}

// Registry manages service registrations and maintenance handshakes
type Registry struct {
	mu               sync.RWMutex
	services         map[string]*Service // key: hostname:port
	sessions         map[string]*Service // key: sessionID for reconnect
	port             int
	upstreamTimeout  time.Duration
	nginxController  NginxController
	debug            bool
	maintenanceReqs  chan maintenanceRequest
	switchbackReqs   chan switchbackRequest
}

type NginxController interface {
	ScheduleReload(reason string)
	ReloadNow(reason string) error
	TestConfig() error
}

type maintenanceRequest struct {
	service string
	port    int
}

type switchbackRequest struct {
	service string
	port    int
}

func NewRegistry(port int, timeout time.Duration, nginxCtrl NginxController, debug bool) *Registry {
	return &Registry{
		services:        make(map[string]*Service),
		sessions:        make(map[string]*Service),
		disconnected:    make(map[string]time.Time),
		port:            port,
		upstreamTimeout: timeout,
		gracefulPeriod:  5 * time.Minute, // Keep configs for 5min after unexpected disconnect
		nginxController: nginxCtrl,
		debug:           debug,
		maintenanceReqs: make(chan maintenanceRequest, 10),
		switchbackReqs:  make(chan switchbackRequest, 10),
	}
}maintenanceReqs  chan maintenanceRequest
	switchbackReqs   chan switchbackRequest
}

func (r *Registry) Start(ctx context.Context) {
	// Start request processors
	go r.processMaintenanceRequests(ctx)
	go r.processSwitchbackRequests(ctx)
	go r.cleanupExpiredSessions(ctx)

	// Start TCP listener
	listener, err := net.Listen("tcp", fmt.Sprintf(":%d", r.port))
	if err != nil {
		log.Fatalf("[registry] Failed to start listener: %s", err)
	}
	defer listener.Close()

	log.Printf("[registry] Listening on port %d for service registrations", r.port)

	go func() {
		<-ctx.Done()
		listener.Close()
	}()

	for {
		conn, err := listener.Accept()
		if err != nil {
			select {
			case <-ctx.Done():
				return
			default:
				log.Printf("[registry] Accept error: %s", err)
				continue
			}
		}

		go r.handleConnection(ctx, conn)
	}
}

func (r *Registry) handleConnection(ctx context.Context, conn net.Conn) {
	defer conn.Close()

	reader := bufio.NewReader(conn)
	message, err := reader.ReadString('\n')
	if err != nil {
		if r.debug {
			log.Printf("[registry] Read error: %s", err)
		}
		return
	}

	message = strings.TrimSpace(message)
	parts := strings.Split(message, "|")

	if len(parts) < 2 {
		if r.debug {
			log.Printf("[registry] Invalid message format: %s", message)
		}
		return
	}
	command := parts[0]

	switch command {
	case "REGISTER":
		r.handleRegister(ctx, conn, parts)
	case "RECONNECT":
		r.handleReconnect(ctx, conn, parts)
	case "CONFIG":
		r.handleConfig(ctx, conn, parts, reader)
	case "TEMPLATE":
		r.handleTemplate(ctx, conn, parts)
	case "VALIDATE":
		r.handleValidate(ctx, conn, parts)
	case "SHUTDOWN":
		r.handleShutdown(ctx, conn, parts)
	case "MAINT_ENTER":
		r.handleMaintenanceEnter(conn, parts)
	case "MAINT_EXIT":
		r.handleMaintenanceExit(conn, parts)
	default:
		if r.debug {
			log.Printf("[registry] Unknown command: %s", command)
		}
	}
}}
}

func (r *Registry) handleRegister(ctx context.Context, conn net.Conn, parts []string) {
	// Format: REGISTER|service_name|hostname|service_port|maintenance_port
	if len(parts) != 5 {
		conn.Write([]byte("ERROR|Invalid format\n"))
		return
	}

	serviceName := parts[1]
	hostname := parts[2]
	var servicePort, maintPort int
	fmt.Sscanf(parts[3], "%d", &servicePort)
	fmt.Sscanf(parts[4], "%d", &maintPort)

	serviceKey := fmt.Sprintf("%s:%d", hostname, servicePort)
	sessionID := fmt.Sprintf("%s-%d-%d", hostname, servicePort, time.Now().Unix())

	service := &Service{
		Name:             serviceName,
		Hostname:         hostname,
		Port:             servicePort,
		MaintenancePort:  maintPort,
		Connection:       conn,
		Connected:        time.Now(),
		RegistrationType: "persistent",
		SessionID:        sessionID,
	}

	r.mu.Lock()
	r.services[serviceKey] = service
	r.sessions[sessionID] = service
	r.mu.Unlock()

	log.Printf("[registry] Service registered: %s at %s (session: %s)", serviceName, serviceKey, sessionID)

	// Send ACK with session ID - client can now send CONFIG or TEMPLATE, or just keep connection
	conn.Write([]byte(fmt.Sprintf("ACK|%s\n", sessionID)))

	// Keep connection open and monitor it
	r.monitorConnection(serviceKey, sessionID, serviceName, conn)
}

func (r *Registry) handleReconnect(ctx context.Context, conn net.Conn, parts []string) {
	// Format: RECONNECT|session_id
	if len(parts) != 2 {
		conn.Write([]byte("ERROR|Invalid format\n"))
		return
	}

	sessionID := parts[1]

	r.mu.Lock()
	service, exists := r.sessions[sessionID]
	r.mu.Unlock()

	if !exists {
		// Session expired or invalid - need to re-register
		conn.Write([]byte("REREGISTER\n"))
		log.Printf("[registry] Reconnect failed - session not found: %s", sessionID)
		return
	}

	// Update connection
	serviceKey := fmt.Sprintf("%s:%d", service.Hostname, service.Port)
	
	// Close old connection if still open
	if service.Connection != nil {
		service.Connection.Close()
	}

	service.Connection = conn
	service.Connected = time.Now()

	r.mu.Lock()
	r.services[serviceKey] = service
	r.mu.Unlock()

	log.Printf("[registry] Service reconnected: %s at %s (session: %s)", service.Name, serviceKey, sessionID)
	conn.Write([]byte("OK\n"))

	// Keep connection open and monitor it
	r.monitorConnection(serviceKey, sessionID, service.Name, conn)
}

func (r *Registry) handleConfig(ctx context.Context, conn net.Conn, parts []string, reader *bufio.Reader) {
	// Format: CONFIG|session_id|config_lines
	if len(parts) != 3 {
		conn.Write([]byte("ERROR|Invalid format\n"))
		return
	}

	sessionID := parts[1]
	var configLines int
	fmt.Sscanf(parts[2], "%d", &configLines)

	r.mu.Lock()
	service, exists := r.sessions[sessionID]
	r.mu.Unlock()

	if !exists {
		conn.Write([]byte("ERROR|Invalid session\n"))
		return
	}

	// Read config lines
	var configBuilder strings.Builder
	for i := 0; i < configLines; i++ {
		line, err := reader.ReadString('\n')
		if err != nil {
			conn.Write([]byte("ERROR|Config read failed\n"))
			return
		}
	service.RegistrationType = "config"
	service.Config = configBuilder.String()
	service.ConfigHash = r.calculateConfigHash(service.Config)

	serviceKey := fmt.Sprintf("%s:%d", service.Hostname, service.Port)
	r.mu.Lock()
	r.services[serviceKey] = service
	r.mu.Unlock()

	log.Printf("[registry] Config received for %s at %s (%d lines, hash: %s)", service.Name, serviceKey, configLines, service.ConfigHash[:8])
	
	// TODO: Write config to /etc/nginx/sites-enabled/
	conn.Write([]byte(fmt.Sprintf("CONFIG_OK|%s\n", service.ConfigHash)))
}
	// TODO: Write config to /etc/nginx/sites-enabled/
	conn.Write([]byte("CONFIG_OK\n"))
}

func (r *Registry) handleTemplate(ctx context.Context, conn net.Conn, parts []string) {
	// Format: TEMPLATE|session_id|template_name
	if len(parts) != 3 {
		conn.Write([]byte("ERROR|Invalid format\n"))
		return
	}

	sessionID := parts[1]
	templateName := parts[2]

	r.mu.Lock()
	service, exists := r.sessions[sessionID]
	r.mu.Unlock()

	if !exists {
	service.RegistrationType = "template"
	service.Config = templateName
	service.ConfigHash = r.calculateConfigHash(templateName)

	serviceKey := fmt.Sprintf("%s:%d", service.Hostname, service.Port)
	r.mu.Lock()
	r.services[serviceKey] = service
	r.mu.Unlock()

	log.Printf("[registry] Template '%s' set for %s at %s (hash: %s)", templateName, service.Name, serviceKey, service.ConfigHash[:8])
	
	// TODO: Generate config from template
	conn.Write([]byte(fmt.Sprintf("TEMPLATE_OK|%s\n", service.ConfigHash)))
}

func (r *Registry) handleValidate(ctx context.Context, conn net.Conn, parts []string) {
	// Format: VALIDATE|session_id|client_hash
	if len(parts) != 3 {
		conn.Write([]byte("ERROR|Invalid format\n"))
		return
	}

	sessionID := parts[1]
	clientHash := parts[2]

	r.mu.RLock()
	service, exists := r.sessions[sessionID]
	r.mu.RUnlock()

	if !exists {
		conn.Write([]byte("ERROR|Invalid session\n"))
		return
	}

	// Calculate parity bits (simple even parity for each byte)
	serverHash := service.ConfigHash
	
	if serverHash == "" {
		conn.Write([]byte("ERROR|No config to validate\n"))
		return
	}

	// Compare hashes
	if clientHash == serverHash {
		// Calculate parity for additional verification
		parity := r.calculateParity(serverHash)
		conn.Write([]byte(fmt.Sprintf("VALID|%s\n", parity)))
		log.Printf("[registry] Config validated for %s (hash match, parity: %s)", service.Name, parity)
	} else {
		conn.Write([]byte(fmt.Sprintf("MISMATCH|%s\n", serverHash)))
		log.Printf("[registry] Config mismatch for %s (client: %s, server: %s)", service.Name, clientHash[:8], serverHash[:8])
	}
}

func (r *Registry) calculateConfigHash(config string) string {
	hash := sha256.Sum256([]byte(config))
	return hex.EncodeToString(hash[:])
}

func (r *Registry) calculateParity(hash string) string {
	// Calculate even parity for the hash string
	// Count 1s in binary representation of each hex digit
	var parity byte
	for _, char := range hash {
		var val byte
		if char >= '0' && char <= '9' {
			val = byte(char - '0')
		} else if char >= 'a' && char <= 'f' {
			val = byte(char-'a') + 10
		} else if char >= 'A' && char <= 'F' {
			val = byte(char-'A') + 10
		}
		
		// Count bits
		for val > 0 {
			parity ^= (val & 1)
			val >>= 1
		}
	}
	
	return fmt.Sprintf("%d", parity)
}log.Printf("[registry] Template '%s' set for %s at %s", templateName, service.Name, serviceKey)
	
	// TODO: Generate config from template
	conn.Write([]byte("TEMPLATE_OK\n"))
}

func (r *Registry) monitorConnection(serviceKey, sessionID, serviceName string, conn net.Conn) {
	buf := make([]byte, 1)
	_, err := conn.Read(buf)
	
	// Connection closed - service went down
	r.mu.Lock()
	delete(r.services, serviceKey)
	// Mark as unexpectedly disconnected - keep config for graceful period
	r.disconnected[serviceKey] = time.Now()
	r.mu.Unlock()

	if err != nil {
		log.Printf("[registry] Service unexpectedly disconnected: %s at %s (config retained for %v)", serviceName, serviceKey, r.gracefulPeriod)
	} else {
		log.Printf("[registry] Service connection closed: %s at %s (config retained for %v)", serviceName, serviceKey, r.gracefulPeriod)
	}
}

func (r *Registry) handleMaintenanceEnter(conn net.Conn, parts []string) {
		r.handleMaintenanceEnter(conn, parts)
	case "MAINT_EXIT":
		r.handleMaintenanceExit(conn, parts)
	default:
		if r.debug {
			log.Printf("[registry] Unknown command: %s", command)
		}
	}
}

func (r *Registry) handleShutdown(ctx context.Context, conn net.Conn, parts []string) {
	// Format: SHUTDOWN|session_id
	if len(parts) != 2 {
		conn.Write([]byte("ERROR|Invalid format\n"))
		return
	}

	sessionID := parts[1]

	r.mu.Lock()
	service, exists := r.sessions[sessionID]
	if !exists {
		r.mu.Unlock()
		conn.Write([]byte("ERROR|Invalid session\n"))
		return
	}

	serviceKey := fmt.Sprintf("%s:%d", service.Hostname, service.Port)
	
	// Graceful shutdown - remove immediately, don't keep config
	delete(r.services, serviceKey)
	delete(r.sessions, sessionID)
	delete(r.disconnected, serviceKey) // Clear any pending disconnection
	r.mu.Unlock()

	log.Printf("[registry] Graceful shutdown: %s at %s (config removed immediately)", service.Name, serviceKey)
	
	// TODO: Remove config from /etc/nginx/sites-enabled/
	// TODO: Trigger nginx reload
	
	conn.Write([]byte("SHUTDOWN_OK\n"))
	conn.Close()
}

func (r *Registry) handleMaintenanceEnter(conn net.Conn, parts []string) {
	// Format: MAINT_ENTER|hostname:port|maintenance_port
	if len(parts) != 3 {
		return
	}

	service := parts[1]
	var maintPort int
	fmt.Sscanf(parts[2], "%d", &maintPort)

	conn.Write([]byte("ACK\n"))

	r.maintenanceReqs <- maintenanceRequest{service: service, port: maintPort}
}

func (r *Registry) handleMaintenanceExit(conn net.Conn, parts []string) {
	// Format: MAINT_EXIT|hostname:port
	if len(parts) != 2 {
		return
	}

	service := parts[1]
	parts2 := strings.Split(service, ":")
	var port int
	if len(parts2) == 2 {
		fmt.Sscanf(parts2[1], "%d", &port)
	}

	conn.Write([]byte("ACK\n"))

	r.switchbackReqs <- switchbackRequest{service: service, port: port + 1}
}

func (r *Registry) processMaintenanceRequests(ctx context.Context) {
	for {
		select {
		case <-ctx.Done():
			return
		case req := <-r.maintenanceReqs:
			go r.approveMaintenanceMode(req.service, req.port)
		}
	}
}

func (r *Registry) processSwitchbackRequests(ctx context.Context) {
	for {
		select {
		case <-ctx.Done():
			return
		case req := <-r.switchbackReqs:
			go r.approveSwitchback(req.service, req.port)
		}
	}
}

func (r *Registry) approveMaintenanceMode(service string, maintPort int) {
	parts := strings.Split(service, ":")
	if len(parts) != 2 {
		return
	}

	hostname := parts[0]
	log.Printf("[registry] Approving maintenance mode for %s (port %d)", service, maintPort)

	conn, err := net.DialTimeout("tcp", fmt.Sprintf("%s:%d", hostname, maintPort), r.upstreamTimeout)
	if err != nil {
		if r.debug {
			log.Printf("[registry] Failed to connect to maintenance server: %s", err)
		}
		return
	}
	defer conn.Close()

	conn.Write([]byte("MAINT_APPROVED\n"))
	
	// Wait for ACK
	buf := make([]byte, 4)
	conn.SetReadDeadline(time.Now().Add(r.upstreamTimeout))
	conn.Read(buf)

	log.Printf("[registry] Maintenance mode approved for %s", service)
}

func (r *Registry) approveSwitchback(service string, maintPort int) {
	parts := strings.Split(service, ":")
	if len(parts) != 2 {
		return
	}

	hostname := parts[0]
	log.Printf("[registry] Approving switchback for %s (port %d)", service, maintPort)

	// Wait for nginx reload to complete first
	time.Sleep(2 * time.Second)

	conn, err := net.DialTimeout("tcp", fmt.Sprintf("%s:%d", hostname, maintPort), r.upstreamTimeout)
	if err != nil {
		if r.debug {
			log.Printf("[registry] Failed to connect to maintenance server: %s", err)
		}
		return
	}
	defer conn.Close()

	conn.Write([]byte("SWITCHBACK_APPROVED\n"))
	
	// Wait for ACK
	buf := make([]byte, 4)
	conn.SetReadDeadline(time.Now().Add(r.upstreamTimeout))
	conn.Read(buf)

	log.Printf("[registry] Switchback approved for %s", service)
}

func (r *Registry) cleanupExpiredSessions(ctx context.Context) {
	ticker := time.NewTicker(1 * time.Minute)
	defer ticker.Stop()

	for {
		select {
		case <-ctx.Done():
			return
		case <-ticker.C:
			r.mu.Lock()
			now := time.Now()
			for serviceKey, disconnectTime := range r.disconnected {
				if now.Sub(disconnectTime) > r.gracefulPeriod {
					// Find and remove session
					for sessionID, service := range r.sessions {
						if fmt.Sprintf("%s:%d", service.Hostname, service.Port) == serviceKey {
							delete(r.sessions, sessionID)
							log.Printf("[registry] Expired session cleanup: %s at %s (disconnected %v ago)", service.Name, serviceKey, now.Sub(disconnectTime))
							// TODO: Remove config from /etc/nginx/sites-enabled/
							// TODO: Trigger nginx reload
							break
						}
					}
					delete(r.disconnected, serviceKey)
				}
			}
			r.mu.Unlock()
		}
	}
}

// NotifyShutdown sends shutdown notification to all connected services
func (r *Registry) NotifyShutdown() {
	r.mu.RLock()
	defer r.mu.RUnlock()

	log.Printf("[registry] Notifying %d connected services of shutdown", len(r.services))
	
	for serviceKey, service := range r.services {
		if service.Connection != nil {
			_, err := service.Connection.Write([]byte("SHUTDOWN\n"))
			if err != nil {
				log.Printf("[registry] Failed to notify %s of shutdown: %s", serviceKey, err)
			} else {
				log.Printf("[registry] Shutdown notification sent to %s", serviceKey)
			}
		}
	}
}

// IsRegistered checks if a service is registered
func (r *Registry) IsRegistered(hostname string, port int) bool {
	r.mu.RLock()
	defer r.mu.RUnlock()

	key := fmt.Sprintf("%s:%d", hostname, port)
	_, exists := r.services[key]
	return exists
}

// GetMaintenancePort returns the maintenance port for a registered service
func (r *Registry) GetMaintenancePort(hostname string, port int) (int, bool) {
	r.mu.RLock()
	defer r.mu.RUnlock()

	key := fmt.Sprintf("%s:%d", hostname, port)
	if service, exists := r.services[key]; exists {
		return service.MaintenancePort, true
	}
	return port + 1, false // Default to port+1
}
