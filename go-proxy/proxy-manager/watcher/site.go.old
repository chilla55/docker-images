package watcher

import (
	"context"
	"fmt"
	"log"
	"net"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"time"

	"github.com/fsnotify/fsnotify"
)

type SiteWatcher struct {
	sitesPath         string
	sitesSourcePath   string
	interval          time.Duration
	fastCheckInterval time.Duration
	upstreamTimeout   time.Duration
	registry          ServiceRegistry
	nginxController   NginxController
	debug             bool
	disabledSites     map[string]time.Time
}

type ServiceRegistry interface {
	IsRegistered(hostname string, port int) bool
	GetMaintenancePort(hostname string, port int) (int, bool)
}

type NginxController interface {
	ScheduleReload(reason string)
	ReloadNow(reason string) error
	TestConfig() error
}

func NewSiteWatcher(sitesPath, sitesSourcePath string, interval, fastCheckInterval, upstreamTimeout time.Duration, registry ServiceRegistry, nginxCtrl NginxController, debug bool) *SiteWatcher {
	return &SiteWatcher{
		sitesPath:         sitesPath,
		sitesSourcePath:   sitesSourcePath,
		interval:          interval,
		fastCheckInterval: fastCheckInterval,
		upstreamTimeout:   upstreamTimeout,
		registry:          registry,
		nginxController:   nginxCtrl,
		debug:             debug,
		disabledSites:     make(map[string]time.Time),
	}
}

func (w *SiteWatcher) Start(ctx context.Context) {
	log.Println("[site-watcher] Starting site monitoring")

	// Start file watcher for immediate detection
	go w.watchSiteFiles(ctx)

	// Start periodic upstream checker
	ticker := time.NewTicker(w.interval)
	defer ticker.Stop()

	fastTicker := time.NewTicker(w.fastCheckInterval)
	defer fastTicker.Stop()

	// Initial check
	w.checkAllSites()

	for {
		select {
		case <-ctx.Done():
			log.Println("[site-watcher] Stopping site monitoring")
			return
		case <-ticker.C:
			w.checkAllSites()
		case <-fastTicker.C:
			w.checkDisabledSites()
		}
	}
}

func (w *SiteWatcher) watchSiteFiles(ctx context.Context) {
	watcher, err := fsnotify.NewWatcher()
	if err != nil {
		log.Printf("[site-watcher] Failed to create file watcher: %s", err)
		return
	}
	defer watcher.Close()

	// Watch both sites-enabled and sites-available
	watcher.Add(w.sitesPath)
	if w.sitesSourcePath != w.sitesPath {
		watcher.Add(w.sitesSourcePath)
	}

	for {
		select {
		case <-ctx.Done():
			return
		case event, ok := <-watcher.Events:
			if !ok {
				return
			}
			if event.Op&(fsnotify.Write|fsnotify.Create|fsnotify.Remove) != 0 {
				log.Printf("[site-watcher] Site configuration changed: %s", event.Name)
				w.nginxController.ScheduleReload(fmt.Sprintf("site config changed: %s", filepath.Base(event.Name)))
			}
		case err, ok := <-watcher.Errors:
			if !ok {
				return
			}
			log.Printf("[site-watcher] Watcher error: %s", err)
		}
	}
}

func (w *SiteWatcher) checkAllSites() {
	files, err := os.ReadDir(w.sitesPath)
	if err != nil {
		if w.debug {
			log.Printf("[site-watcher] Error reading sites directory: %s", err)
		}
		return
	}

	for _, file := range files {
		if file.IsDir() {
			continue
		}

		sitePath := filepath.Join(w.sitesPath, file.Name())
		w.checkSite(sitePath, file.Name())
	}
}

func (w *SiteWatcher) checkDisabledSites() {
	for siteName := range w.disabledSites {
		sitePath := filepath.Join(w.sitesPath, siteName)
		w.checkSite(sitePath, siteName)
	}
}

func (w *SiteWatcher) checkSite(sitePath, siteName string) {
	// Read site configuration
	content, err := os.ReadFile(sitePath)
	if err != nil {
		if w.debug {
			log.Printf("[site-watcher] Error reading %s: %s", siteName, err)
		}
		return
	}

	// Extract upstream hosts and ports
	upstreams := w.extractUpstreams(string(content))
	if len(upstreams) == 0 {
		return
	}

	// Check if site is currently disabled
	isDisabled := strings.Contains(sitePath, ".disabled")

	// Check each upstream
	allHealthy := true
	for _, upstream := range upstreams {
		if !w.checkUpstream(upstream.hostname, upstream.port) {
			allHealthy = false
			break
		}
	}

	// Handle state changes
	if isDisabled && allHealthy {
		// Site is disabled but upstreams are healthy - enable it
		w.enableSite(sitePath, siteName)
		delete(w.disabledSites, siteName)
	} else if !isDisabled && !allHealthy {
		// Site is enabled but upstreams are unhealthy - disable it
		w.disableSite(sitePath, siteName)
		w.disabledSites[siteName] = time.Now()
	}
}

type upstream struct {
	hostname string
	port     int
}

func (w *SiteWatcher) extractUpstreams(content string) []upstream {
	var upstreams []upstream

	// Match proxy_pass directives
	re := regexp.MustCompile(`proxy_pass\s+https?://([^:;/\s]+)(?::(\d+))?`)
	matches := re.FindAllStringSubmatch(content, -1)

	for _, match := range matches {
		hostname := match[1]
		port := 80
		if match[2] != "" {
			fmt.Sscanf(match[2], "%d", &port)
		}

		upstreams = append(upstreams, upstream{hostname: hostname, port: port})
	}

	return upstreams
}

func (w *SiteWatcher) checkUpstream(hostname string, port int) bool {
	// For registered services, check if connection is alive
	if w.registry.IsRegistered(hostname, port) {
		// Service has persistent connection, it's healthy
		if w.debug {
			log.Printf("[site-watcher] %s:%d is registered (persistent connection)", hostname, port)
		}
		return true
	}

	// Legacy: Direct TCP check for non-registered services
	maintPort, _ := w.registry.GetMaintenancePort(hostname, port)

	// Check maintenance mode first (port+1)
	if w.checkTCP(hostname, maintPort) {
		if w.debug {
			log.Printf("[site-watcher] %s:%d is in maintenance mode", hostname, port)
		}
		return false
	}

	// Check main service
	healthy := w.checkTCP(hostname, port)
	if w.debug {
		log.Printf("[site-watcher] %s:%d TCP check: %v", hostname, port, healthy)
	}

	return healthy
}

func (w *SiteWatcher) checkTCP(hostname string, port int) bool {
	address := fmt.Sprintf("%s:%d", hostname, port)
	conn, err := net.DialTimeout("tcp", address, w.upstreamTimeout)
	if err != nil {
		return false
	}
	conn.Close()
	return true
}

func (w *SiteWatcher) enableSite(sitePath, siteName string) {
	if !strings.Contains(sitePath, ".disabled") {
		return
	}

	newPath := strings.Replace(sitePath, ".disabled", "", 1)
	log.Printf("[site-watcher] Enabling site: %s", siteName)

	if err := os.Rename(sitePath, newPath); err != nil {
		log.Printf("[site-watcher] Failed to enable %s: %s", siteName, err)
		return
	}

	w.nginxController.ScheduleReload(fmt.Sprintf("enabled site: %s", siteName))
}

func (w *SiteWatcher) disableSite(sitePath, siteName string) {
	if strings.Contains(sitePath, ".disabled") {
		return
	}

	newPath := sitePath + ".disabled"
	log.Printf("[site-watcher] Disabling site: %s", siteName)

	if err := os.Rename(sitePath, newPath); err != nil {
		log.Printf("[site-watcher] Failed to disable %s: %s", siteName, err)
		return
	}

	w.nginxController.ScheduleReload(fmt.Sprintf("disabled site: %s", siteName))
}
