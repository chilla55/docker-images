package main

import (
	"fmt"
	"os"
	"os/exec"
	"os/signal"
	"strings"
	"syscall"
	"time"
)

var (
	registryClientV2 *RegistryClientV2
	routeID          string
	vaultwardenPID   int
	done             = make(chan os.Signal, 1)
)

func main() {
	signal.Notify(done, syscall.SIGINT, syscall.SIGTERM)
	defer cleanup()

	log("INFO", "Starting Vaultwarden entrypoint...")

	// Setup database URL from secret
	setupDatabaseURL()

	// Setup keys directory
	setupKeysDirectory()

	// Register with proxy if enabled
	if getEnv("ENABLE_REGISTRY", "true") == "true" {
		log("INFO", "Registry integration enabled")
		go func() {
			if err := registerWithProxy(); err != nil {
				log("WARN", "Failed to register with proxy: %v", err)
			}
		}()
	} else {
		log("INFO", "Registry integration disabled")
	}

	// Start vaultwarden server
	log("INFO", "Starting Vaultwarden server...")
	startVaultwarden()
}

func log(level, format string, args ...interface{}) {
	timestamp := time.Now().Format("2006-01-02 15:04:05")
	message := fmt.Sprintf(format, args...)
	fmt.Printf("[%s] [%s] %s\n", timestamp, level, message)
}

func getEnv(key, defaultVal string) string {
	if val := os.Getenv(key); val != "" {
		return val
	}
	return defaultVal
}

func readSecret(path string) string {
	data, err := os.ReadFile(path)
	if err != nil {
		return ""
	}
	return strings.TrimSpace(string(data))
}

func setupDatabaseURL() {
	// Check if DATABASE_URL is already set
	if os.Getenv("DATABASE_URL") != "" {
		log("INFO", "DATABASE_URL already set")
		return
	}

	// Build DATABASE_URL from secret if DB password file exists
	secretPath := "/run/secrets/vaultwarden_db_password"
	if _, err := os.Stat(secretPath); os.IsNotExist(err) {
		log("WARN", "No database secret found, skipping DATABASE_URL setup")
		return
	}

	dbPassword := readSecret(secretPath)
	if dbPassword == "" {
		log("WARN", "Database password secret is empty")
		return
	}

	dbHost := getEnv("DB_HOST", "mariadb")
	databaseURL := fmt.Sprintf("mysql://vaultwarden:%s@%s:3306/vaultwarden", dbPassword, dbHost)
	os.Setenv("DATABASE_URL", databaseURL)
	log("INFO", "DATABASE_URL configured for MySQL (host: %s)", dbHost)
}

func setupKeysDirectory() {
	keysDir := "/data/keys"

	// Check if keys directory is mounted
	if info, err := os.Stat(keysDir); err != nil || !info.IsDir() {
		log("INFO", "Storage Box keys directory not mounted")
		return
	}

	log("INFO", "Storage Box keys directory mounted at %s", keysDir)

	// Check if symlink already exists
	rsaKeyPath := "/data/rsa_key.pem"
	if info, err := os.Lstat(rsaKeyPath); err == nil && info.Mode()&os.ModeSymlink != 0 {
		log("INFO", "RSA key symlink already exists")
		return
	}

	// Check if key exists in Storage Box
	storageBoxKey := keysDir + "/rsa_key.pem"
	if _, err := os.Stat(storageBoxKey); err == nil {
		log("INFO", "Using existing RSA key from Storage Box")

		// Create symlinks
		os.Remove(rsaKeyPath)
		os.Remove("/data/rsa_key.pub.pem")

		if err := os.Symlink(storageBoxKey, rsaKeyPath); err != nil {
			log("WARN", "Failed to create RSA key symlink: %v", err)
		}
		if err := os.Symlink(keysDir+"/rsa_key.pub.pem", "/data/rsa_key.pub.pem"); err != nil {
			log("WARN", "Failed to create RSA pub key symlink: %v", err)
		}
	} else {
		log("INFO", "RSA key will be generated by Vaultwarden and moved to Storage Box")
		// Start post-start script in background
		go runPostStartScript()
	}
}

func runPostStartScript() {
	// Wait a bit for Vaultwarden to generate keys
	time.Sleep(10 * time.Second)

	cmd := exec.Command("/usr/local/bin/post-start.sh")
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	if err := cmd.Run(); err != nil {
		log("WARN", "Post-start script failed: %v", err)
	}
}

func cleanup() {
	log("INFO", "Shutting down...")

	if registryClientV2 != nil {
		log("INFO", "Closing registry connection...")
		registryClientV2.Shutdown()
		registryClientV2 = nil
	}

	if vaultwardenPID > 0 {
		log("INFO", "Stopping Vaultwarden server...")
		syscall.Kill(vaultwardenPID, syscall.SIGTERM)
		// Wait for graceful shutdown
		time.Sleep(2 * time.Second)
	}
}

func registerWithProxy() error {
	log("INFO", "Registering with go-proxy registry (V2 protocol)...")

	registryHost := getEnv("REGISTRY_HOST", "proxy")
	registryPort := getEnv("REGISTRY_PORT", "81")
	domains := getEnv("DOMAINS", "vw.chilla55.de")
	routePath := getEnv("ROUTE_PATH", "/")
	port := getEnv("PORT", "80")
	serviceName := getEnv("SERVICE_NAME", "vaultwarden")

	registryAddr := fmt.Sprintf("%s:%s", registryHost, registryPort)

	// Create metadata
	metadata := map[string]interface{}{
		"version": "latest",
		"service": "vaultwarden",
	}

	// Create client (doesn't connect yet)
	registryClientV2 = NewRegistryClient(registryAddr, serviceName, "", 0, metadata)

	// Register event handlers before connecting
	registryClientV2.On(EventConnected, func(event Event) {
		sessionID := event.Data["session_id"]
		localIP := event.Data["local_ip"]
		log("INFO", "✓ Connected to registry - Session: %v, IP: %v", sessionID, localIP)
	})

	registryClientV2.On(EventDisconnected, func(event Event) {
		reason := event.Data["reason"]
		log("WARN", "⚠ Disconnected from registry - Reason: %v", reason)
	})

	registryClientV2.On(EventRetrying, func(event Event) {
		attempt := event.Data["attempt"]
		log("WARN", "⚠ Retrying connection (attempt %v)...", attempt)
	})

	registryClientV2.On(EventExtendedRetry, func(event Event) {
		interval := event.Data["interval"]
		log("WARN", "⚠ Switching to extended retry mode (interval: %v)", interval)
	})

	registryClientV2.On(EventReconnected, func(event Event) {
		attempt := event.Data["attempt"]
		sessionID := event.Data["session_id"]
		log("INFO", "✓ Reconnected to registry after %v attempts - Session: %v", attempt, sessionID)
	})

	registryClientV2.On(EventRouteAdded, func(event Event) {
		routeID := event.Data["route_id"]
		domains := event.Data["domains"]
		backendURL := event.Data["backend_url"]
		log("INFO", "✓ Route registered - ID: %v", routeID)
		log("INFO", "  Domains: %v", domains)
		log("INFO", "  Backend: %v", backendURL)
	})

	registryClientV2.On(EventHealthCheckSet, func(event Event) {
		routeID := event.Data["route_id"]
		path := event.Data["path"]
		interval := event.Data["interval"]
		timeout := event.Data["timeout"]
		log("INFO", "✓ Health check configured for route %v", routeID)
		log("INFO", "  Path: %v, Interval: %v, Timeout: %v", path, interval, timeout)
	})

	registryClientV2.On(EventConfigApplied, func(event Event) {
		log("INFO", "✓ Configuration applied and active on proxy")
	})

	// Connect and register (with automatic cleanup of old routes)
	if err := registryClientV2.Init(); err != nil {
		return fmt.Errorf("failed to initialize registry client: %w", err)
	}

	log("INFO", "Using container IP: %s", registryClientV2.GetLocalIP())

	// Build backend URL using the detected IP and configured port
	backendURL := registryClientV2.BuildBackendURL(port)
	domainList := strings.Split(strings.ReplaceAll(domains, " ", ""), ",")

	routeID, err := registryClientV2.AddRoute(domainList, routePath, backendURL, 10)
	if err != nil {
		return fmt.Errorf("failed to add route: %w", err)
	}
	log("INFO", "Route added with ID: %s", routeID)
	log("INFO", "Backend URL: %s", backendURL)

	// Configure health check
	err = registryClientV2.SetHealthCheck(routeID, "/", "30s", "5s")
	if err != nil {
		log("WARN", "Warning: failed to set health check: %v", err)
	}

	// Configure options
	err = registryClientV2.SetOptions("compression", "true")
	if err != nil {
		log("WARN", "Warning: failed to set compression: %v", err)
	}

	// Apply all configuration
	err = registryClientV2.ApplyConfig()
	if err != nil {
		return fmt.Errorf("failed to apply config: %w", err)
	}

	log("INFO", "Successfully registered with V2 protocol")

	// Start automatic keepalive with retry logic
	go registryClientV2.StartKeepalive()

	return nil
}

func startVaultwarden() {
	// Execute original Vaultwarden entrypoint
	cmd := exec.Command("/start.sh")
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	cmd.Stdin = os.Stdin

	// Pass through all environment variables
	cmd.Env = os.Environ()

	if err := cmd.Start(); err != nil {
		log("ERROR", "Failed to start Vaultwarden: %v", err)
		os.Exit(1)
	}

	vaultwardenPID = cmd.Process.Pid
	log("INFO", "Vaultwarden server started (PID: %d)", vaultwardenPID)

	// Wait for vaultwarden to exit
	if err := cmd.Wait(); err != nil {
		log("ERROR", "Vaultwarden exited with error: %v", err)
		os.Exit(1)
	}

	log("INFO", "Vaultwarden exited")
}
